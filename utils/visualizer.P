/* 
** Author(s): Miguel Calejo
** Contact:   info@interprolog.com, http://interprolog.com
** Copyright (C) InterProlog Consulting / Renting Point - Serviços de Informática Lda., Portugal 2016
** Use and distribution, without any warranties, under the terms of the 
** Apache 2.0 License, readable in http://www.apache.org/licenses/LICENSE-2.0.html
*/

/* Utilities for visualizing LPS executions; this version depends on http://interprolog.com/interprolog-studio/ */

:- export visual/1, gov/1, gov/2, gov/3.

:- import load_test_file_for/1, go/3, my_load_dyn/1, my_term_to_atom/2 from interpreter.
:- import lps_test_result_item/3 from usermod. 
:- import member/2,append/3 from basics.
:- import concat_atom/2 from string.
:- import variant/2 from subsumes.
:- import java/3, term2json/2, create_counter/1, get_increment_counter/2 from interprolog.
:- import xjShowURL/1 from usermod. % xj2.P

% gov(ProgramFile) "go visual": executes generating results file and displays its timeline
gov(File) :- gov(File,[]).

% gov(ProgramFile,Options)

gov(File,Options) :- gov(File,Options,[]).

gov(File,Options,Results) :- go(File,[make_test|Options],Results), visual(File).


% visual(TestResultsFile)  
% This needs to be in sync with test/3 calls in interpreter.P
% Omits lps_gigantic(...) terms (which by the way usually popup in other Stages, e.g. goals)
visual(File) :- 
	my_load_dyn(File), % we need the meta info about events
	load_test_file_for(File),
	% Collect all <T1-T2,Group,Term>
	% For events and actions times T1 and T2 are the usual; for fluents, they are time of initiation and termination
	% OFF BY ONE BUG HERE???
	findall(t(X,T1-T2,G), (
		lps_test_result_item('Observations:',T2,X), T1 is T2-1, G=observation
		;
		lps_test_result_item('Selected actions:',TT2,happens(XX,TT1,TT2)), 
		(action(XX)->G=action;G=event),
		(XX=lps_meta(happens(X,T1,T2)) -> true ; XX=X, TT1=T1, TT2=T2)
		;
		lps_test_result_item('Database state:',T1,X), T2 is T1+1, functor(X,F,N), G=F/N % fluent
	), Tuples),
	% Find groups
	setof(G, T^X^member(t(X,T,G),Tuples), GroupIds),
	findall({id:Gatom,content:Gsignature},(
		member(F/N,GroupIds), 
		my_term_to_atom(F/N,Gatom), functor(GG,F,N), my_term_to_atom(GG,Gsignature)
	), FluentGroups),
	( member(t(_,_,event),Tuples) -> G1 = [{id:observation,content:'Observations'},{id:event,content:'Events'}|FluentGroups]
		; G1 = [{id:observation,content:'Observations'}|FluentGroups]),
	append(G1, [{id:action,content:'Actions'}], Groups ),
	% term2json(Groups,GroupsJSON),
	% Aggregate fluent ranges
	sort(Tuples,Sorted),
	join_fluent_ranges(Sorted,Ranged),
	create_counter(IDs),
	% Render fluents
	findall({id:ID,content:Atom,start:T1,end:T2,group:Gatom,title:Tip},(
		member(t(X,T1-T2,F/N),Ranged),  
		my_term_to_atom(F/N,Gatom), my_term_to_atom(X,Atom),
		concat_atom(['Fluent initiated at ',T1,' and terminated at ',T2],Tip),
		get_increment_counter(IDs,ID)
	), Fluents),
	%... and the rest:
	findall(Item,(
		member(t(X,T1-T2,G),Sorted),  
		\+ functor(G,/,2), % not a fluent
		my_term_to_atom(G,Gatom), my_term_to_atom(X,Atom),
		(G==observation -> S='color:Peru'; G==action -> S='color:green' ; S='color:orange'),
		(T2 is T1+1 -> Item={id:ID,content:Atom,start:T2,group:Gatom,type:point,style:S,title:Tip} ;
			Item = {id:ID,content:Atom,start:T1,end:T2,group:Gatom,type:range,style:'background-color: lightGray; color:orange',title:Tip}),
		my_term_to_atom(happens(X,T1,T2),Tip),
		get_increment_counter(IDs,ID)
	), Others),
	append(Fluents,Others,Items),
	% render to JSON:
	term2json({groups:Groups,items:Items},JSON),
	concat_atom([File,'-timeline.json'],JSONfile),
	tell(JSONfile),
	forall(member(Char,JSON),put(Char)),
	told,
	concat_atom(['Fluent and event timeline for LPS program ',File],Subtitle),
	concat_atom([File,'-timeline.html'],HTMLfile),
	java( 'com.declarativa.fiji.reporting.VisjsUtils',
		string(F),
		generateTimeline(string('LPS program timeline'),string(Subtitle),string(JSONfile),string(HTMLfile))
		),
	replace_backslashes(F,FF), str_replace(FF, ' ', '%20', FFF),
	concat_atom(['file:///',FFF],FFFF),
	xjShowURL(FFFF).

replace_backslashes(P,NP) :- atom(P), str_replace(P,'\\','/',NP).

str_replace(A, X, Y, B) :-
    atom_chars(A, Ac), atom_chars(X, Xc), atom_chars(Y, Yc),
    str_replace1(Ac, Xc, Yc, Bc), concat_atom(Bc, B).

str_replace1([], _, _, []).
str_replace1(Ac, Xc, Yc, [B|C]) :-
    (append(Xc, Zc, Ac)
     -> B = Yc, str_replace1(Zc, Xc, Yc, C)
     ;  Ac = [A|Acs], B = A, str_replace1(Acs, Xc, Yc, C)
    ).
    
% join_fluent_ranges(Sorted,Ranged)
join_fluent_ranges([t(X,T,G)|S],[t(X,T,G)|R]) :- \+ functor(G,/,2), !, % not a fluent
	join_fluent_ranges(S,R).
join_fluent_ranges([t(X,T1-T2,G),t(XX,T2-T3,G)|S],R) :- variant(X,XX), !, 	
	join_fluent_ranges([t(X,T1-T3,G)|S],R).
join_fluent_ranges([T|S],[T|R]) :- !, join_fluent_ranges(S,R).
join_fluent_ranges([],[]).
