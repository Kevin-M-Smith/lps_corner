/* 
** Author(s): Miguel Calejo
** Contact:   info@interprolog.com, http://interprolog.com
** Copyright (C) InterProlog Consulting / Renting Point - Serviços de Informática Lda., Portugal 2016
** Use and distribution, without any warranties, under the terms of the 
** Apache 2.0 License, readable in http://www.apache.org/licenses/LICENSE-2.0.html
*/

/* Utilities for visualizing LPS executions; 
the XSB version depends on http://interprolog.com/interprolog-studio , the SWI one on SWISH */

:- module(visualizer,[ gov/1, gov/2, gov/3, gojson/1, gojson/4, golv/3, golv/2, golv/1, golpsv/3, golpsv/2, golpsv/1]).

%%% XSB specific section:
:- if(current_prolog_flag(dialect, xsb)).
:- use_module(interpreter,[go/3, my_term_to_atom/2, endTime/1]). % assumed preloaded
:- use_module(db,[
	lps_test_result_item/3, action/1
	]).
:- use_module(psyntax,[syntax2p_file/4]).

:- use_module(subsumes,[variant/2]).
:- use_module(basics, [member/2, append/3, length/2]).
:- use_module(string,[concat_atom/2]).
% namely for use with Prolog Studio:
:- use_module(interprolog,[java/3, term2json/2, create_counter/1, get_increment_counter/2]).
:- use_module(usermod,[xjShowURL/1]).

www_open_url(URL) :- xjShowURL(URL). % xj2.P

% make_json_object(PairsList,Object) Generate a JSON object in Prolog syntax from a list of Attribute:JSONValue 
% Shame on me for the following, but I had enough of syntax idiosyncrasies...:
make_json_object([A],{A}) :- !.
make_json_object([A,B],{A,B}) :- !.
make_json_object([A,B,C],{A,B,C}) :- !.
make_json_object([A,B,C,D],{A,B,C,D}) :- !.
make_json_object([A,B,C,D,E],{A,B,C,D,E}) :- !.
make_json_object([A,B,C,D,E,F],{A,B,C,D,E,F}) :- !.
make_json_object([A,B,C,D,E,F,G],{A,B,C,D,E,F,G}) :- !.
make_json_object([A,B,C,D,E,F,G,H],{A,B,C,D,E,F,G,H}) :- !.
make_json_object(L,_) :- length(L,N), N>8, !, writeln('*** JSON object with too many attributes in visualizer.P'), fail.


displayTimeline(File,JSON) :-
	concat_atom([File,'-timeline.json'],JSONfile),
	tell(JSONfile),
	forall(member(Char,JSON),put(Char)),
	told,
	concat_atom(['Fluent and event timeline for LPS program ',File],Subtitle),
	concat_atom([File,'-timeline.html'],HTMLfile),
	java( 'com.declarativa.fiji.reporting.VisjsUtils',
		string(F),
		generateTimeline(string('LPS program timeline'),string(Subtitle),string(JSONfile),string(HTMLfile))
		),
	replace_backslashes(F,FF), str_replace(FF, ' ', '%20', FFF),
	concat_atom(['file:///',FFF],FFFF),
	www_open_url(FFFF).
	
:- endif.

%%% end of XSB specific section; now for SWI:


% SWISH special case
:- if((current_prolog_flag(dialect, swi), current_module(swish))).
:- use_module(library(pengines),[pengine_self/1]).
lps_test_result_item(X,Y,Z) :- pengine_self(M), catch(M:lps_test_result_item(X,Y,Z),_,fail).
action(X) :- pengine_self(M), catch(M:action(X),_,fail).
:- endif.
% now non-swish SWI...
:- if((current_prolog_flag(dialect, swi), \+ current_module(swish) )).
:- use_module('../Wei-engine/db.P',[
	lps_test_result_item/3, action/1
	]).
:- endif.

% ... and generic SWI:
:- if(current_prolog_flag(dialect, swi)).

:- use_module(library(http/json)).
:- use_module('../engine/interpreter.P',[
	go/3, my_term_to_atom/2, endTime/1
	]).

:- prolog_load_context(directory, Dir), asserta(user:file_search_path(lpsUtils, Dir)).
:- use_module(lpsUtils('psyntax.P'),[
	syntax2p_file/4
	]).
  
make_json_object(L,json(NL)) :- json_colons_to_equals(L,NL).

json_colons_to_equals(V,NV) :- var(V), !, NV=V.
json_colons_to_equals([],[]) :- !.
json_colons_to_equals([A:V|L],[A=NV|NL]) :- !, json_colons_to_equals(V,NV), json_colons_to_equals(L,NL).
json_colons_to_equals([X|L],[NX|NL]) :- !, json_colons_to_equals(X,NX), json_colons_to_equals(L,NL).
json_colons_to_equals(json(L),json(NL)) :- json_colons_to_equals(L,NL), !.
json_colons_to_equals(X,X).

% converts one of our terms to a JSON dictionary 
term2json(Term,JSONDict) :- 
	json_colons_to_equals(Term,SWIterm), 
	% TODO: one step too many! merge into json_colons_to_equals
	atom_json_term(JSONAtom,SWIterm,[as(atom)]),
	atom_json_dict(JSONAtom, JSONDict, []).

create_counter(Dict) :- dict_create(Dict,'$_visualizer_counter',[value=0]).

get_increment_counter(Dict,CurrentValue) :- 
	get_dict(value,Dict,CurrentValue), New is CurrentValue+1, nb_set_dict(value,Dict,New).

displayTimeline(_File,_JSON). 


:- endif.

%%% end of SWI and Prolog engine-specific code

%%% From here on, generic Prolog code

% gov(ProgramFile) "go visual": executes LPSW file generating results and displays its timeline
gov(File) :- gov(File,[]).

% gov(ProgramFile,Options)
gov(File,Options) :- gov(File,Options,[]).

gov(File,Options,Results) :- go(File,[make_test|Options],Results), visual(File,_JSON).

% Top level predicates to visualize timelines of a psyntax file
golv(LPSP_file) :- golv(LPSP_file,[]).

golv(LPSP_file,Options) :- golv(LPSP_file,Options,[]).

golv(LPSP_file,Options,Results) :-
	concat_atom([LPSP_file,'_.P'],Pfile),
	syntax2p_file(LPSP_file,Pfile,lpsp2p,true),
	gov(Pfile,Options,Results).

% Top level predicates to visualize timelines of a LPS (new syntax) file
golpsv(LPSP_file) :- golpsv(LPSP_file,[]).

golpsv(LPSP_file,Options) :- golpsv(LPSP_file,Options,[]).

golpsv(LPSP_file,Options,Results) :-
	concat_atom([LPSP_file,'_.P'],Pfile),
	syntax2p_file(LPSP_file,Pfile,lps2p,true),
	gov(Pfile,Options,Results).

% for SWISH:
gojson(JSON) :- gojson(_File,[],[],JSON).
gojson(File,Options,Results,JSON) :- go(File,[silent,make_test,swish|Options],Results), visual(File,JSON).


% visual(TestResultsFile,timeline(JSON))  This MUST be called after go(File,[...make_test,...],...)
% Uses test facts still in memory
% This needs to be in sync with test/3 calls in interpreter.P
% Omits lps_gigantic(...) terms (which by the way usually popup in other Stages, e.g. goals)
% works on facts asserted by either Wei (Stage = 'Observations', ...) or rak interpreter (Stage = fluent,event)
visual(File,timeline(JSON)) :- 
	% The following two loads can be skipped IF we execute IMMEDIATELY after go(...)
	% my_load_dyn(File), % we need the meta info about events
	% load_test_file_for(File),
	
	% Collect all <T1-T2,Group,Term>
	% For events and actions times T1 and T2 are the usual; for fluents, they are time of initiation and termination
	% OFF BY ONE BUG HERE???
	findall(t(X,T1-T2,G), (
		lps_test_result_item('Observations:',T2,X), T1 is T2-1, G=observation
		;
		(lps_test_result_item('Selected actions:',TT2,happens(XX,TT1,TT2)) ; lps_test_result_item(events,TT2,XX), T1 is TT2-1), 
		(action(XX)->G=action;G=event),
		(XX=lps_meta(happens(X,T1,T2)) -> true ; XX=X, TT1=T1, TT2=T2)
		;
		(lps_test_result_item('Database state:',T1,X) ; lps_test_result_item(fluents,T1,X)), 
		T1 \== 0, % hack to discard irrelevant state information
		T2 is T1+1, functor(X,F,N), G=F/N % fluent
	), Tuples),
	% Find groups
	(setof(G, T^X^member(t(X,T,G),Tuples), GroupIds)->true;GroupIds=[]), % allow for empty timelines
	findall(FluentGroup,(
		make_json_object([id:Gatom,content:Gsignature],FluentGroup),
		member(F/N,GroupIds), 
		my_term_to_atom(F/N,Gatom), functor(GG,F,N), nicer_vars(GG), my_term_to_atom(GG,Gsignature)
	), FluentGroups),
	make_json_object([id:observation,content:'Observations'],ObsGroup), % TODO: get rid of empty Observations 
	( member(t(_,_,event),Tuples) -> 
		make_json_object([id:event,content:'Events'],EventsGroup),
		G1 = [ObsGroup,EventsGroup|FluentGroups]
		; 
		G1 = [ObsGroup|FluentGroups]),
	make_json_object([id:action,content:'Actions'],ActionsGroup),
	append(G1, [ActionsGroup], Groups ),
	
	% term2json(Groups,GroupsJSON),
	% Aggregate fluent ranges
	sort(Tuples,Sorted),
	join_fluent_ranges(Sorted,Ranged),
	create_counter(IDs),
	% Render fluents
	endTime(End), LastRelevantTime is End+1,
	findall(Fluent,(
		make_json_object([id:ID,content:AtomAbridged,start:T1,end:T2,group:Gatom,title:Tip],Fluent),
		member(t(X,T1-T2,F/N),Ranged),  
		abridge_fluent(X,AtomAbridged),
		my_term_to_atom(F/N,Gatom), my_term_to_atom(X,Atom), 
		(T2==LastRelevantTime -> FluentSuffix = [' (end of time)'] ; FluentSuffix = []),
		concat_atom(['Fluent ',Atom,' initiated at ',T1,'<br/>and terminated at transition to ',T2|FluentSuffix],Tip),
		get_increment_counter(IDs,ID)
	), Fluents),
	%... and the rest:
	findall(Item,(
		member(t(X,T1-T2,G),Sorted),  
		\+ functor(G,/,2), % not a fluent
		my_term_to_atom(G,Gatom), my_term_to_atom(X,Atom),
		(G==observation -> S='color:Peru'; G==action -> S='color:green' ; S='color:#E19735'),
		(T2 is T1+1 -> make_json_object([id:ID,content:Atom,start:T2,group:Gatom,type:point,style:S,title:Tip],Item);
			make_json_object([id:ID,content:Atom,start:T1,end:T2,group:Gatom,type:range,style:'background-color: lightGray; color:orange',title:Tip],Item)),
		my_term_to_atom(happens(X,T1,T2),Tip),
		get_increment_counter(IDs,ID)
	), Others),
	append(Fluents,Others,Items),
	% render to JSON:
	make_json_object([groups:Groups,items:Items],All),
	term2json(All,JSON),
	displayTimeline(File,JSON). 

abridge_fluent(X,X) :- atomic(X), !.
abridge_fluent(X,AtomAbridged) :- X=..[_|Args], abridge_fluent_args(Args,Atoms), concat_atom(Atoms,AtomAbridged).

abridge_fluent_args([A1,A2|An],[Atom1, ','| Atoms]) :- !, my_term_to_atom(A1,Atom1), abridge_fluent_args([A2|An],Atoms).
abridge_fluent_args([A],[Atom]) :- my_term_to_atom(A,Atom).

nicer_vars(T) :- nicer_vars(T,65,_).

nicer_vars(T,V1,Vn) :- var(T), !, atom_codes(T,[V1]), Vn is V1+1.
nicer_vars([T1|Tn],V1,Vn) :- !, nicer_vars(T1,V1,V2), nicer_vars(Tn,V2,Vn).
nicer_vars(T,V,V) :- atomic(T), !.
nicer_vars(T,V1,Vn) :- T=..L, nicer_vars(L,V1,Vn).


replace_backslashes(P,NP) :- atom(P), str_replace(P,'\\','/',NP).

str_replace(A, X, Y, B) :-
    atom_chars(A, Ac), atom_chars(X, Xc), atom_chars(Y, Yc),
    str_replace1(Ac, Xc, Yc, Bc), concat_atom(Bc, B).

str_replace1([], _, _, []).
str_replace1(Ac, Xc, Yc, [B|C]) :-
    (append(Xc, Zc, Ac)
     -> B = Yc, str_replace1(Zc, Xc, Yc, C)
     ;  Ac = [A|Acs], B = A, str_replace1(Acs, Xc, Yc, C)
    ).
    
% join_fluent_ranges(Sorted,Ranged)
join_fluent_ranges([t(X,T,G)|S],[t(X,T,G)|R]) :- \+ functor(G,/,2), !, % not a fluent
	join_fluent_ranges(S,R).
join_fluent_ranges([t(X,T1-T2,G),t(XX,T2-T3,G)|S],R) :- variant(X,XX), !, 	
	join_fluent_ranges([t(X,T1-T3,G)|S],R).
join_fluent_ranges([T|S],[T|R]) :- !, join_fluent_ranges(S,R).
join_fluent_ranges([],[]).
