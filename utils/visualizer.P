/* 
** Author(s): Miguel Calejo
** Contact:   info@interprolog.com, http://interprolog.com
** Copyright (C) InterProlog Consulting / Renting Point - Serviços de Informática Lda., Portugal 2016
** Use and distribution, without any warranties, under the terms of the 
** Apache 2.0 License, readable in http://www.apache.org/licenses/LICENSE-2.0.html
*/

/* Utilities for visualizing LPS executions; the XSB version depends on http://interprolog.com/interprolog-studio/ */

:- module(visualizer,[ gov/1, gov/2, gov/3, gojson/2, gojson/4]).

%%% XSB specific section:
:- if(current_prolog_flag(dialect, xsb)).
:- use_module(interpreter,[go/3, my_term_to_atom/2]). % assumed preloaded
:- use_module(db,[
	lps_test_result_item/3, action/1
	]).

:- use_module(subsumes,[variant/2]).
:- use_module(basics, [member/2, append/3, length/2]).
:- use_module(string,[concat_atom/2]).
% namely for use with Prolog Studio:
:- use_module(interprolog,[java/3, term2json/2, create_counter/1, get_increment_counter/2]).
:- use_module(usermod,[xjShowURL/1]).

www_open_url(URL) :- xjShowURL(URL). % xj2.P

% make_json_object(PairsList,Object) Generate a JSON object in Prolog syntax from a list of Attribute:JSONValue 
% Shame on me for the following, but I had enough of syntax idiosyncrasies...:
make_json_object([A],{A}) :- !.
make_json_object([A,B],{A,B}) :- !.
make_json_object([A,B,C],{A,B,C}) :- !.
make_json_object([A,B,C,D],{A,B,C,D}) :- !.
make_json_object([A,B,C,D,E],{A,B,C,D,E}) :- !.
make_json_object([A,B,C,D,E,F],{A,B,C,D,E,F}) :- !.
make_json_object([A,B,C,D,E,F,G],{A,B,C,D,E,F,G}) :- !.
make_json_object([A,B,C,D,E,F,G,H],{A,B,C,D,E,F,G,H}) :- !.
make_json_object(L,_) :- length(L,N), N>8, !, writeln('*** JSON object with too many attributes in visualizer.P'), fail.


displayTimeline(File,JSON) :-
	concat_atom([File,'-timeline.json'],JSONfile),
	tell(JSONfile),
	forall(member(Char,JSON),put(Char)),
	told,
	concat_atom(['Fluent and event timeline for LPS program ',File],Subtitle),
	concat_atom([File,'-timeline.html'],HTMLfile),
	java( 'com.declarativa.fiji.reporting.VisjsUtils',
		string(F),
		generateTimeline(string('LPS program timeline'),string(Subtitle),string(JSONfile),string(HTMLfile))
		),
	replace_backslashes(F,FF), str_replace(FF, ' ', '%20', FFF),
	concat_atom(['file:///',FFF],FFFF),
	www_open_url(FFFF).
	
:- endif.

%%% end of XSB specific section; now for SWI:

% TODO: needs SWISH special case too!!

:- if(current_prolog_flag(dialect, swi)).

:- use_module(library(http/json)).
:- use_module('../Wei-engine/db.P',[
	lps_test_result_item/3
	]).
:- use_module('../Wei-engine/interpreter.P',[
	go/3, my_term_to_atom/2
	]).

make_json_object(L,json(NL)) :- json_colons_to_equals(L,NL).

json_colons_to_equals(V,NV) :- var(V), !, NV=V.
json_colons_to_equals([],[]) :- !.
json_colons_to_equals([A:V|L],[A=NV|NL]) :- !, json_colons_to_equals(V,NV), json_colons_to_equals(L,NL).
json_colons_to_equals([X|L],[NX|NL]) :- !, json_colons_to_equals(X,NX), json_colons_to_equals(L,NL).
json_colons_to_equals(json(L),json(NL)) :- json_colons_to_equals(L,NL), !.
json_colons_to_equals(X,X).

% converts one of our terms to a JSON dictionary 
term2json(Term,JSONDict) :- 
	json_colons_to_equals(Term,SWIterm), 
	% TODO: one step too many! merge into json_colons_to_equals
	atom_json_term(JSONAtom,SWIterm,[as(atom)]),
	atom_json_dict(JSONAtom, JSONDict, []).

create_counter(Dict) :- dict_create(Dict,'$_visualizer_counter',[value=0]).

get_increment_counter(Dict,CurrentValue) :- 
	get_dict(value,Dict,CurrentValue), New is CurrentValue+1, nb_set_dict(value,Dict,New).

displayTimeline(_File,_JSON). 


:- endif.

%%% end of SWI and Prolog engine-specific code

%%% From here on, generic Prolog code

% gov(ProgramFile) "go visual": executes generating results file and displays its timeline
gov(File) :- gov(File,[]).

% gov(ProgramFile,Options)
gov(File,Options) :- gov(File,Options,[]).

gov(File,Options,Results) :- go(File,[make_test|Options],Results), visual(File,_JSON).

gojson(File,JSON) :- gojson(File,[],[],JSON).

gojson(File,Options,Results,JSON) :- go(File,[silent,make_test|Options],Results), visual(File,JSON).


% visual(TestResultsFile,timeline(JSON))  This MUST be called after go(File,[...make_test,...],...)
% Uses test facts still in memory
% This needs to be in sync with test/3 calls in interpreter.P
% Omits lps_gigantic(...) terms (which by the way usually popup in other Stages, e.g. goals)
visual(File,timeline(JSON)) :- 
	% The following two loads can be skipped IF we execute IMMEDIATELY after go(...)
	% my_load_dyn(File), % we need the meta info about events
	% load_test_file_for(File),
	
	% Collect all <T1-T2,Group,Term>
	% For events and actions times T1 and T2 are the usual; for fluents, they are time of initiation and termination
	% OFF BY ONE BUG HERE???
	findall(t(X,T1-T2,G), (
		lps_test_result_item('Observations:',T2,X), T1 is T2-1, G=observation
		;
		lps_test_result_item('Selected actions:',TT2,happens(XX,TT1,TT2)), 
		(db:action(XX)->G=action;G=event),
		(XX=lps_meta(happens(X,T1,T2)) -> true ; XX=X, TT1=T1, TT2=T2)
		;
		lps_test_result_item('Database state:',T1,X), T2 is T1+1, functor(X,F,N), G=F/N % fluent
	), Tuples),
	% Find groups
	setof(G, T^X^member(t(X,T,G),Tuples), GroupIds),
	
	findall(FluentGroup,(
		make_json_object([id:Gatom,content:Gsignature],FluentGroup),
		member(F/N,GroupIds), 
		my_term_to_atom(F/N,Gatom), functor(GG,F,N), my_term_to_atom(GG,Gsignature)
	), FluentGroups),
	make_json_object([id:observation,content:'Observations'],ObsGroup),
	( member(t(_,_,event),Tuples) -> 
		make_json_object([id:event,content:'Events'],EventsGroup),
		G1 = [ObsGroup,EventsGroup|FluentGroups]
		; 
		G1 = [ObsGroup|FluentGroups]),
	make_json_object([id:action,content:'Actions'],ActionsGroup),
	append(G1, [ActionsGroup], Groups ),
	
	% term2json(Groups,GroupsJSON),
	% Aggregate fluent ranges
	sort(Tuples,Sorted),
	join_fluent_ranges(Sorted,Ranged),
	create_counter(IDs),
	% Render fluents
	findall(Fluent,(
		make_json_object([id:ID,content:Atom,start:T1,end:T2,group:Gatom,title:Tip],Fluent),
		member(t(X,T1-T2,F/N),Ranged),  
		my_term_to_atom(F/N,Gatom), my_term_to_atom(X,Atom),
		concat_atom(['Fluent initiated at ',T1,' and terminated at ',T2],Tip),
		get_increment_counter(IDs,ID)
	), Fluents),
	%... and the rest:
	findall(Item,(
		member(t(X,T1-T2,G),Sorted),  
		\+ functor(G,/,2), % not a fluent
		my_term_to_atom(G,Gatom), my_term_to_atom(X,Atom),
		(G==observation -> S='color:Peru'; G==action -> S='color:green' ; S='color:orange'),
		(T2 is T1+1 -> make_json_object([id:ID,content:Atom,start:T2,group:Gatom,type:point,style:S,title:Tip],Item);
			make_json_object([id:ID,content:Atom,start:T1,end:T2,group:Gatom,type:range,style:'background-color: lightGray; color:orange',title:Tip],Item)),
		my_term_to_atom(happens(X,T1,T2),Tip),
		get_increment_counter(IDs,ID)
	), Others),
	append(Fluents,Others,Items),
	% render to JSON:
	make_json_object([groups:Groups,items:Items],All),
	term2json(All,JSON),
	displayTimeline(File,JSON). 
	
replace_backslashes(P,NP) :- atom(P), str_replace(P,'\\','/',NP).

str_replace(A, X, Y, B) :-
    atom_chars(A, Ac), atom_chars(X, Xc), atom_chars(Y, Yc),
    str_replace1(Ac, Xc, Yc, Bc), concat_atom(Bc, B).

str_replace1([], _, _, []).
str_replace1(Ac, Xc, Yc, [B|C]) :-
    (append(Xc, Zc, Ac)
     -> B = Yc, str_replace1(Zc, Xc, Yc, C)
     ;  Ac = [A|Acs], B = A, str_replace1(Acs, Xc, Yc, C)
    ).
    
% join_fluent_ranges(Sorted,Ranged)
join_fluent_ranges([t(X,T,G)|S],[t(X,T,G)|R]) :- \+ functor(G,/,2), !, % not a fluent
	join_fluent_ranges(S,R).
join_fluent_ranges([t(X,T1-T2,G),t(XX,T2-T3,G)|S],R) :- variant(X,XX), !, 	
	join_fluent_ranges([t(X,T1-T3,G)|S],R).
join_fluent_ranges([T|S],[T|R]) :- !, join_fluent_ranges(S,R).
join_fluent_ranges([],[]).
