/* 
** Author(s): Miguel Calejo
** Contact:   info@interprolog.com, http://interprolog.com
** Copyright (C) InterProlog Consulting / Renting Point - Serviços de Informática Lda., Portugal 2016
** Use and distribution, without any warranties, under the terms of the 
** Apache 2.0 License, readable in http://www.apache.org/licenses/LICENSE-2.0.html
*/

/* Implement surface syntax. To launch LPS, cd to the LPS home directory and:
	swipl -l utils/psyntax.P
*/

:- module(psyntax,[ syntax2p/4, lpsp2p_file/2, lpsp2p/3, 
	lps2p_file/2, lps2p/3, syntax2p_file/4, syntax2p/4, syntax2p_literal/7,
	gol/2, gol/1, golps/2, golps/1,
	file_generator_name/2,
	may_clear_hints/0,term_colours/2,timeless_ref/1, set_top_term/1, dumploaded/1]).

%%% XSB specific section:
:- if(current_prolog_flag(dialect, xsb)).

:- use_module(interpreter,[go/3,uassert/1, uretractall/1, collect_guessed_declarations/1,bindAllVars/1,intensional/1,macroaction/1,system_fluent/1,system_action/1]). % assumed preloaded
:- use_module(db,[head_hint/3, '_currenty__defining'/1]).
:- use_module(basics, [member/2, append/3]).
:- use_module(string,[concat_atom/2]).
:- consult:add_this_lib_dir. % is this needed??
:- use_module(xsb_read,[ file_read/3]).
:- use_module(subsumes,[variant/2]).

my_file_read(Stream,Term,Vars) :- file_read(Stream,Term,Vars).

% New syntax .lps
:- op(1200,xfx,then).
:- op(1185,fx,if).
:- op(1200,xfx,if).
:- op(1050,xfx,(terminates)).
:- op(1050,xfx,(initiates)).
:- op(1050,xfx,(updates)).
% Rejected:-( :- op(1050,fx,impossible). 
:- op(1050,fx,observe).
:- op(1050,fx,false).
:- op(1050,fx,initially).
:- op(1050,fx,fluents).
:- op(1050,fx,events).
:- op(1050,fx,actions).
:- op(1050,fx,unserializable).
% notice ',' has priority 1000
:- op(999,fx,update).
:- op(999,fx,initiate).
:- op(999,fx,terminate).
:- op(997,xfx,in).
:- op(995,xfx,at).
:- op(995,xfx,during).
:- op(995,xfx,from). % Already defined in XSB with higher priority... so parenthesis needed e.g. (event 1 from 1 to 2), event 2 to 3
:- op(994,xfx,to). % from's priority higher
:- op(1050,xfy,::).
% older syntax lpsp2p:
:- op(1200,xfx,--->). % for reactive rules
:- op(1190,xfx,priority). %... with priority
:- op(900,fy,terminated).
:- op(900,fy,initiated).

may_clear_hints :- throw(only_for_swi).

% hook into test suite runner:
:- multifile interpreter:regenerate_file/1.
% regenerate_file(F) F is an existing Wei syntax file that needs to be regenerated...if a source file for it can be found
regenerate_file(F) :- generate_file(F), !.

% SWI only:
dumploaded(_).
clear_timeless_refs. 
may_add_timeless_ref(_).
set_top_term(_).
:- dynamic timeless_ref/1, current_top_term/1. % dummy declaration to please XSB's compiler

:- endif.

%%% end of XSB specific section; now for SWI:

:- if((current_prolog_flag(dialect, swi), current_module(swish))). 
% first, SWISH specific; see comments in interpreter.P

:- use_module(library(pengines),[pengine_self/1]).
:- use_module(library(prolog_clause)).

:- use_module(library(pengines),[pengine_self/1]).


% dumploaded(ShowExternalSyntax) if == true dumps surface syntax, otherwise internal (Wei) syntax
dumploaded(External) :- 
	% TODO: warn about generated clauses (e.g. from English) than will not appear here
	lps_swish_clause(H,Body,Vars),
	(External -> 
		(Body==true -> InternalTerm=H ; InternalTerm=(H:-Body)),
		syntax2p(Clause,Vars,lps2p,_,InternalTerm) 
		; 
		Clause = (H:-Body)),
	% bindAllVars(Vars),
	% term_variables((H:-Body),VarValues),    _Vars: [Name1=VarValue1,...]
	%_TermPos = term_position(Char,CharEnd,_,_,_),
	%print_message(error,error(syntax_error(whatever),file(File,LineNumber,_one,_Char))),
	pretty_write_withvars(Clause,Vars), writeln('.'),
	%write('  '), writeln(File), % e.g. pengine://fa945952-355c-47a3-bb48-bdf8dfdb4229/src
	%write('  '), writeln(TermPos/Vars), % e.g. term_position(384,446,416,420,[term_position(.... ])/[N=_1022]
	fail.
dumploaded(_).

lps_swish_clause(H,Body,Vars) :-
	interpreter:check_lps_program_swish_module,
	interpreter:lps_program_clause_file(H,Body,File),
	(atom_prefix(File,'pengine://') ; File==asserted, interpreter:program_predicate(H)), % hack to circumvent SWI/SWISH term_expansion bug
	( interpreter:lps_source_position(H,_,_,Vars) -> true ; Vars=[]).
	
:- endif.

:- if((current_prolog_flag(dialect, swi), \+ current_module(swish))).
% Now support for vanilla/barebones SWI Prolog:
dumploaded(_).
:- endif.

:- if(current_prolog_flag(dialect, swi)).
% ...and finally the generic SWI support:

:- use_module('../engine/db.P',[head_hint/3, '_currenty__defining'/1]).
	
:- thread_local((timeless_ref/1, current_top_term/1)).
clear_timeless_refs :- retractall(timeless_ref(_)).

may_add_timeless_ref(G) :- 
	functor(G,F,N), ( current_top_term(F/N); timeless_ref(F/N) ; assert(timeless_ref(F/N))), !.

set_top_term(T) :- retractall(current_top_term(_)), (var(T)->F=var, N = -1 ; functor(T,F,N)), assert(current_top_term(F/N)).


:- use_module('../engine/interpreter.P',[go/3, print_error/2, 
	uassert/1, uretractall/1, collect_guessed_declarations/1,bindAllVars/1,intensional/1,
	macroaction/1,system_fluent/1,system_action/1, get_lps_program_module/1]).
:- use_module(library(dialect/sicstus/system),[file_exists/1]).
my_file_read(Stream,Term,Vars) :- read_term(Stream,Term,[variable_names(Vars)]).

% New syntax .lps
:- op(900,fy,user:(not)). 
:- op(1200,xfx,user:(then)).
:- op(1185,fx,user:(if)).
:- op(1200,xfx,user:(if)).
:- op(1050,xfx,user:(terminates)).
:- op(1050,xfx,user:(initiates)).
:- op(1050,xfx,user:(updates)).
% Rejected:-( :- op(1050,fx,impossible). 
:- op(1050,fx,user:(observe)).
:- op(1050,fx,user:(false)).
:- op(1050,fx,user:initially).
:- op(1050,fx,user:fluents).
:- op(1050,fx,user:events).
:- op(1050,fx,user:prolog_events).
:- op(1050,fx,user:actions).
:- op(1050,fx,user:unserializable).
% notice ',' has priority 1000
:- op(999,fx,user:update).
:- op(999,fx,user:initiate).
:- op(999,fx,user:terminate).
:- op(997,xfx,user:in).
:- op(995,xfx,user:at).
:- op(995,xfx,user:during).
:- op(995,xfx,user:from). % Already defined in XSB with higher priority... so parenthesis needed e.g. (event 1 from 1 to 2), event 2 to 3
:- op(994,xfx,user:to). % from's priority higher
:- op(1050,xfy,::).
% older syntax lpsp2p:
:- op(1200,xfx,--->). % for reactive rules
:- op(1190,xfx,priority). %... with priority
:- op(900,fy,terminated).
:- op(900,fy,initiated).


% This colours lps2p terms, articulated with SWI's prolog_colour.pl
term_colours(T,C) :- 
	may_clear_hints,  
	syntax2p(T,[],lps2p,NiceC,_Pterm), NiceC \== null, 
	!, 
	NiceC=C.
	

% Resets the psyntax context when using a different thread, e.g. a different file tokenization
% Controlling this elsewhere (e.g. hooking into either xref_open_source/close_source, swish_highlight:server_tokens) does not work
may_clear_hints :- thread_self(T), expanding_in_thread(T,_), !.
may_clear_hints :- % garbage collect after 5 minutes:
	get_time(Now), expanding_in_thread(_,Then), Now>Then+300, retract(expanding_in_thread(_,Then)), fail.
may_clear_hints :- thread_self(T), get_time(Now), assert(expanding_in_thread(T,Now)), clear_hints.
% ASSUMES that thread ids are unique!!
:- dynamic expanding_in_thread/2. % thread, timestamp

% hook into test suite runner:
:- multifile interpreter:regenerate_file/1.
% regenerate_file(F) F is an existing Wei syntax file that needs to be regenerated...if a source file for it can be found
interpreter:regenerate_file(F) :- generate_file(F), !.

:- endif.

%%% From here on, generic Prolog code

%clear_head_hint(HH,Type,X) :- uretractall(head_hint(HH,Type,X)).
%add_head_hint(HH,Type,X) :- uassert(head_hint(HH,Type,X)).
clear_head_hint(HH,Type,X) :- retractall(head_hint(HH,Type,X)).
add_head_hint(HH,Type,X) :- assert(head_hint(HH,Type,X)).

closetail([]) :- !.
closetail([_|L]) :- closetail(L).

% comma_to_list(?NiceSyntax,+Syntaxclass,-Spec,?List). SyntaxClass and Spec as per SWI's Prolog_colour.pl
comma_to_list(NS,_,_,L) :- var(NS), var(L), !, writeln('*** Bad var item'), fail.
comma_to_list((One,Two),SC,delimiter-[SpecOne,SpecTwo],[One|Twol]):- Twol \== [], !,
	spec_for_one(One,SC,SpecOne),
	comma_to_list(Two,SC,SpecTwo,Twol).
comma_to_list(One,SC,SpecOne,[One]) :- spec_for_one(One,SC,SpecOne).

% spec_for_one(+NiceItem,+SyntaxClass,-ItemColourSpec)
spec_for_one(_/_,SC,delimiter-[SC,classify]) :- !.
spec_for_one(One,SC,SC) :- atom(One), !.
spec_for_one(_One,SC,SC-classify).

% functor_arityze(TemplatesOrFA,TemplatesList) replaces term functor/arities by their templates; 
% bidirectional (albeit losing information of course)
functor_arityze([F/A|TOFAL],[G|FAL]) :- functor(G,F,A), !, functor_arityze(TOFAL,FAL).
functor_arityze([T|TOFAL],[T|FAL]) :- !, functor_arityze(TOFAL,FAL).
functor_arityze([],[]).

% Convert a file in LPSP into Wei syntax and execute it 
gol(LPSP_file,Options,Results) :-
	concat_atom([LPSP_file,'_.P'],Pfile),
	syntax2p_file(LPSP_file,Pfile,lpsp2p,true),
	go(Pfile,Options,Results).

gol(LPSP_file,Options) :- gol(LPSP_file,Options,[]).

gol(LPSP_file) :- gol(LPSP_file,[]).

% Convert a file in LPS (new syntax) into Wei syntax and execute it 
golps(LPSP_file,Options,Results) :-
	(member(background(_),Options) -> % use unique file names to avoid clashs with other threads
		gensym('_f',ID), concat_atom([LPSP_file,ID, '_.P'],Pfile)
	; concat_atom([LPSP_file,'_.P'],Pfile)),
	syntax2p_file(LPSP_file,Pfile,lps2p,true),
	go(Pfile,Options,Results).

golps(LPSP_file,Options) :- golps(LPSP_file,Options,[]).

golps(LPSP_file) :- golps(LPSP_file,[]).
	
% File converters:

% Fails if no source file exists
% [46,108,112,115,119] .lpsw
% [95,46,80] _.P
% [46,108,112,115] .lps
% generate_file(FilenameCodes)
generate_file(Fcodes) :- 
	% _.P or .lpsw?
	(append(SourceCodes,[95,46,80],Fcodes) ; append(SourceCodes,[46,108,112,115,119],Fcodes)),
	!,
	(append(_,[46,108,112,115],SourceCodes) ; append(_,[46,112,108],SourceCodes)), % a LPS or pl file
	atom_codes(Source,SourceCodes),
	file_exists(Source),
	atom_codes(F,Fcodes),
	syntax2p_file(Source,F,lps2p,true).

file_generator_name(F,FG) :- atom_codes(F,Codes), file_generator_name_(Codes,FG).

file_generator_name_(Codes,FG) :- append(FGcodes,[95,46,80],Codes), !, atom_codes(FG,FGcodes). % _.P
file_generator_name_(Codes,FG) :- append(FGcodes,[46,108,112,115,119],Codes), !, atom_codes(FG,FGcodes). % .lpsw

% lpsp2p_file(?LPSPfile,?LPSWfile) "papers syntax"
lpsp2p_file(LPSPfile,LPSWfile) :- atom(LPSPfile), !,
	(atom(LPSWfile)->true;concat_atom([LPSPfile,'_.lpsw'],LPSWfile)),
	syntax2p_file(LPSPfile,LPSWfile,lpsp2p,true).
lpsp2p_file(LPSPfile,LPSWfile) :- 
	atom(LPSWfile), 
	(atom(LPSPfile)->true;concat_atom([LPSWfile,'_.lpsp'],LPSPfile)),
	syntax2p_file(LPSPfile,LPSWfile,lpsp2p,false).

% lps2p_file(?LPSfile,?LPSWfile) "new syntax", Nov-Dec 2016
lps2p_file(LPSfile,LPSWfile) :- atom(LPSfile), !,
	(atom(LPSWfile)->true;concat_atom([LPSfile,'_.lpsw'],LPSWfile)),
	syntax2p_file(LPSfile,LPSWfile,lps2p,true).
lps2p_file(LPSfile,LPSWfile) :- 
	atom(LPSWfile), 
	(atom(LPSfile)->true;concat_atom([LPSWfile,'_.lps'],LPSfile)),
	syntax2p_file(LPSfile,LPSWfile,lps2p,false).


% Main file to file syntax converter
% syntax2p_file(+OtherSyntaxFile,+P_Wei_file,+Translator,+ToWei) Translator is a functor for a predicate Translate(Term,Vars,NewTerm)
% If ToWei==true it generates a .P file from the first file, else vice-versa
syntax2p_file(Lfile,Pfile,Translator,ToWei) :-
	( member(Translator,[/* no longer:lpsp2p,*/lps2p]) -> true 
		; throw('Bad syntax translator:'(Translator))),
	init_definition_newliner,
	clear_hints, clear_timeless_refs,
	( current_prolog_flag(write_depth,Old) -> set_xsb_flag(write_depth,10000) ; true), % XSB specific, ignore otherwise
	(ToWei==true -> 
		(file_exists(Lfile)->true;throw(non_existing_file(Lfile))), 
		open(Lfile,read,IStr), open(Pfile,write,OStr), 
		Convert =.. [Translator,Term,Vars,NewTerm]
		; 
		(file_exists(Pfile)->true;throw(non_existing_file(Pfile))), 
		open(Pfile,read,IStr), open(Lfile,write,OStr),
		Convert =.. [Translator,NewTerm,Vars,Term]
		),
	% IStr >= 0, OStr>=0,
	nonvar(IStr), nonvar(OStr),
	repeat,
	catch(my_file_read(IStr,Term_,Vars_),Ex,writeln(ex-Ex)), 
	term_includer(Term_,Vars_,Term,Vars), % inject terms from included files
	closetail(Vars),
	( Term==end_of_file -> true
	;  
		set_top_term(Term),
		(Convert->true; write('*** failed '), writeln(Convert), fail), 
		% When converting back to our syntax from Wei's, make sure T vars are not misinterpreted:
		% NO! Too strong
		% ((ToWei\==true, member(V,Vars), is_time_var(V)) -> true
		%	; 
		% This combined with writeq.... can't do: bindAllVars(Vars), 
		may_write_newline(NewTerm,OStr),
		pretty_write(NewTerm,OStr), writeln(OStr,'.'), 
		fail
	),
	!,
	(ToWei==true ->
		% may generate missing declarations
		collect_guessed_declarations(Facts),
		forall( 
			member(Fact,Facts), 
			(may_write_newline(Fact,OStr), pretty_write(Fact,OStr), writeln(OStr,'.'))
			)
	; true),
	close(OStr),close(IStr),
	(nonvar(Old)->set_xsb_flag(write_depth,Old);true).

term_includer((:- include(F)), _, Term,Vars) :- !, absolute_file_name(F,File), 
	term_in_file(File, Term, Vars).
term_includer(T,V,T,V).

% Inspired from http://www.swi-prolog.org/pldoc/man?predicate=setup_call_cleanup/3:
term_in_file(File,Term,Vars) :-
	setup_call_cleanup( open(File, read, In), term_in_stream(In, Term, Vars), close(In) ).

term_in_stream(In, Term, Vars) :-
        repeat, my_file_read(In,T,Vars), 
        (   T == end_of_file
        ->  !, fail
        ;   T = Term
        ).
        
% head_hint(HeadTemplate,Sort,Declared) Sort maybe l_timeless,event,fluent
%  a fact means that some head was read before and tagged as Sort
%  used only when transforming from some nicer to Wei syntax 
%  Declared is 'true' if a declaration (not just usage) was detected
head_hint(X,Sort) :- head_hint(X,Sort,_), !.
head_hint(X,fluent) :- intensional(X).
head_hint(X,event) :- macroaction(X).
	
remember_hint(Type,H) :- 
	nonvar(Type), nonvar(H),
	member(Type,[fluent,event,action,timeless]),
	functor(H,F,N), functor(HH,F,N),
	( head_hint(HH,Type,_) ->  true; add_head_hint(HH,Type,false) ).

remember_timeless_hint(TL) :- remember_hint(timeless,TL).

remember_event_hint((E from _T1 to _T2)) :- !, remember_event_hint(E).
remember_event_hint((E during _Interval)) :- !, remember_event_hint(E).
remember_event_hint(TL) :- remember_hint(event,TL).

% Do we need events and actions??
%remember_action_hint((E during _Interval)) :- !, remember_action_hint(E).
%remember_action_hint(TL) :- remember_hint(action,TL).

remember_fluent_hint((F at _T)) :- !, remember_fluent_hint(F).
remember_fluent_hint(TL) :- remember_hint(fluent,TL).

remember_declaration(Type,H) :- 
	nonvar(Type), nonvar(H),
	member(Type,[fluent,event,action,timeless]),
	functor(H,F,N), functor(HH,F,N),
	( head_hint(HH,Type,true) ->  true; clear_head_hint(HH,Type,_), add_head_hint(HH,Type,true) ).
	
% remember_hints(Type,LiteralOrList)
remember_hints(_Type,X) :- var(X), ! . %, !, write('*** Underspecified term of sort '), writeln(Type).
remember_hints(_Type,[]) :- !.
remember_hints(Type,[X1|Xn]) :- !, remember_hint(Type,X1), remember_hints(Type,Xn).
remember_hints(Type,X) :- remember_hint(Type,X).

% remember_declarations(Type,LiteralOrList)
remember_declarations(Type,X) :- var(X), !, 
	format(atom(M),"Underspecified declared term of sort ~w",[Type]), print_error(warning,M).
remember_declarations(_Type,[]) :- !.
remember_declarations(Type,[X1|Xn]) :- !, remember_declaration(Type,X1), remember_declarations(Type,Xn).
remember_declarations(Type,X) :- remember_declaration(Type,X).

clear_hints :- clear_head_hint(_,_,_).
	
% convenience predicates for environment syntax checkers:
lpsp2p(LPSPterm,Vars,Pterm) :- syntax2p(LPSPterm,Vars,lpsp2p,Pterm).
lps2p(LPSPterm,Vars,Pterm) :- syntax2p(LPSPterm,Vars,lps2p,Pterm).

% Main term syntax converter
syntax2p(NicerSyntaxTerm,Vars,Translator,Pterm) :- 
	syntax2p(NicerSyntaxTerm,Vars,Translator,_NiceColouring,Pterm).

% syntax2p(?NicerSyntaxTerm,+Vars,+Translator,NiceColouring,?Pterm) 
% Vars is a (closed tail) list of some_functor(Name,Variable)
% Translator: lpsp2p ("papers syntax") or lps2p ("new syntax"); 
% Either NicerSyntaxTerm or Pterm must be bound; the other should be unbound
% NiceColouring is a colouring specificatin term as per SWI's prolog_colouring.pl, for the NicerSyntaxTerm
%   null if undefined colouring, e.g. for timeless/Prolog literals (they'll be coloured elsewhere in SWI)
%   needs to be defined only for nonvar(NicerSyntaxTerm)
% Probably needs to evolve to return error messages
syntax2p(L,_,_TT,_,PT) :- var(L), var(PT), !, fail.
syntax2p(NT,_,TT,Spec,(H:-B)) :- 
	(nonvar(NT)->ToWei=true;ToWei=false),
	NT = (H:-B),
	do_not_transform_may_hint(H,TT,ToWei,B,Spec), !.
syntax2p(NT,_,TT,Spec,Fact) :- 
	(nonvar(NT)->ToWei=true;ToWei=false),
	NT=Fact,
	do_not_transform_may_hint(NT,TT,ToWei,true,Spec), !.
% convenience notation for declarations:
syntax2p((initially States),_Vars,lps2p, lps_delimiter - [Specs] , initial_state(StatesList)) :- !, 
% syntax2p((initially States),_Vars,lps2p, null , initial_state(StatesList)) :- !, 
	comma_to_list(States,fluent,Specs,StatesList).
% observe o1, o2, o3 from ... to ...:
syntax2p((observe Obs),_Vars,lps2p,lps_delimiter - [Specs],observe([O1,O2|On],T2)) :- (nonvar(Obs)-> functor(Obs,',',2) ; true), !,
	((syntax2p_observations(Obs,CT2,[O1,O2|On],T2,Specs), T2=CT2, nonvar(T2)) -> true
		% cannot use comma_to_list, which assumes DECLARATIONS, e.g. NOT usage with time variables and their auxiliary functors
	; 
		format(atom(M),"Bad observations: ~w",[(observe Obs)/observe([O1,O2|On],T2)]),
		print_error(error,M),
		fail). 
	
% single observations, declared as fact declarations; observations list case handled further below
syntax2p((observe E from T1 to T2),_Vars,lps2p, lps_delimiter - [SpecHead], observe([E],T2)) :- !, 
	syntax2p_literal((E from T1 to T2),[],lps2p,_,_,SpecHead,_).
syntax2p((observe E to T2),_Vars,lps2p, lps_delimiter - [SpecHead],observe([E],T2)) :- !,
	syntax2p_literal((E to T2),[],lps2p,_,_,SpecHead,_).
syntax2p((observe E at T2),_Vars,lps2p, lps_delimiter - [SpecHead],observe([E],T2)) :- atom(T2), !,
	syntax2p_literal((E to T2),[],lps2p,_,_,SpecHead,_).
syntax2p((observe E from T1),_Vars,lps2p, lps_delimiter - [SpecHead],observe([E],T2)) :- number(T1), !, T2 is T1+1,
	syntax2p_literal((E to T2),[],lps2p,_,_,SpecHead,_).
syntax2p((unserializable A),Vars,lps2p,Spec,unserializable(NL)) :- !, syntax2p((actions A),Vars,lps2p,Spec,actions(NL)).
syntax2p((actions A),_Vars,lps2p,lps_delimiter - [Specs],actions(NL)) :- nonvar(A), !, comma_to_list(A,event,Specs,L), functor_arityze(L,NL), remember_declarations(event,NL).
syntax2p((actions A),_Vars,lps2p,lps_delimiter - [Specs],actions(L)) :- !, comma_to_list(A,event,Specs,L).
syntax2p((events A),_Vars,lps2p,lps_delimiter - [Specs],events(NL)) :- nonvar(A), !, comma_to_list(A,event,Specs,L), functor_arityze(L,NL), remember_declarations(event,NL).
syntax2p((events A),_Vars,lps2p,lps_delimiter - [Specs],events(L)) :- !, comma_to_list(A,event,Specs,L).
syntax2p((prolog_events A),_Vars,lps2p,lps_delimiter - [Specs],prolog_events(NL)) :- nonvar(A), !, 
	comma_to_list(A,event,Specs,L), functor_arityze(L,NL), remember_declarations(event,NL).
syntax2p((prolog_events A),_Vars,lps2p,lps_delimiter - [Specs],prolog_events(L)) :- !, comma_to_list(A,event,Specs,L).

syntax2p((fluents A),_Vars,lps2p,lps_delimiter - [Specs],fluents(NL)) :- nonvar(A), !, comma_to_list(A,fluent,Specs,L), functor_arityze(L,NL), remember_declarations(fluent,NL).
syntax2p((fluents A),_Vars,lps2p,lps_delimiter - [Specs],fluents(L)) :- !, comma_to_list(A,fluent,Specs,L).
% reactive rules:
syntax2p((if A then C priority P), Vars,TT, null,reactive_rule(NA,NC,P)) :- TT=lps2p, !, % TODO: should add T3>=T1?? interpreter enforced?
	syntax2p_sequence(A,Vars,TT,[_T1,_T2],_,NA), syntax2p_sequence(C,Vars,TT,[_T3,_T4],_,NC).
syntax2p((A--->C priority P), Vars,TT, null,reactive_rule(NA,NC,P)) :- TT=lpsp2p, !, 
	syntax2p_sequence(A,Vars,TT,[_T1,_T2],_,NA), syntax2p_sequence(C,Vars,TT,[_T3,_T4],_,NC).
syntax2p((if A then C), Vars,TT, lps_delimiter-[lps_delimiter-SpecA,SpecC],reactive_rule(NA,NC)) :- TT=lps2p, !, 
	syntax2p_sequence(A,Vars,TT,[_T1,_T2],SpecA,NA), syntax2p_sequence(C,Vars,TT,[_T3,_T4],SpecC,NC).
syntax2p((A--->C),Vars,TT,null,reactive_rule(NA,NC)) :- TT=lpsp2p, !, 
	syntax2p_sequence(A,Vars,TT,[_T1,_T2],_,NA), syntax2p_sequence(C,Vars,TT,[_T3,_T4],_,NC).
% pre-conditions:
syntax2p((false B),Vars,lps2p,lps_delimiter-[SpecB],d_pre(IC)) :- !, 
	syntax2p_sequence(B,Vars,lps2p,[_T1,_T2],single,_ET,SpecB,IC).
syntax2p(((false):-B),Vars,lpsp2p,null,d_pre(IC)) :- !, 
	syntax2p_sequence(B,Vars,lpsp2p,[_T1,_T2],single,_ET,_,IC).
% now post-conditions:	
syntax2p((IT:-B),Vars,lpsp2p,null,PT) :- % LPSP -> Wei term
	var(PT),
	IT=..[F,H], ((F==terminated) ; (F==initiated)), 
	!,
	syntax2p_sequence(B,Vars,lpsp2p,[_T1,_T2],single,_ET,_,[NB1|NBn]), % should be strictier wrt NB1 ?
	PT=..[F,NB1,H,NBn].
syntax2p((H if B),Vars,lps2p,Spec,PT) :- % 
	var(PT),( 
		H= (Event initiates Fluent), PT=initiated(NB1,Fluent,NBn), Spec=lps_delimiter-[lps_delimiter-[EC,FC],SpecB] ; 
		H= (Event terminates Fluent), PT=terminated(NB1,Fluent,NBn), Spec=lps_delimiter-[lps_delimiter-[EC,FC],SpecB] ;
		H = (Event updates Old to New in Fluent), PT = updated(NB1,Fluent,Old-New,NBn), 
			Spec=lps_delimiter-[lps_delimiter-[EC,lps_delimiter-[lps_delimiter-[classify,classify],FC]],SpecB]
		),
	!,
	remember_fluent_hint(Fluent), remember_event_hint(Event),
	simple_event_colour(Event,EC), simple_fluent_colour(Fluent,FC),
	syntax2p_literal(Event,Vars,lps2p,[T1,T2], _ETL, _Spec1, NB1),
	syntax2p_sequence(B,Vars,lps2p,[T1,T2],single,_ET,SpecB,NBn). 
syntax2p(H,Vars,lps2p,Spec,PT) :- % 
	var(PT),( 
		H= (Event initiates Fluent), PT=initiated(NB1,Fluent,NBn), Spec=lps_delimiter-[SpecE,FC] ; 
		H= (Event terminates Fluent), PT=terminated(NB1,Fluent,NBn), Spec=lps_delimiter-[SpecE,FC] ;
		H = (Event updates Old to New in Fluent), PT = updated(NB1,Fluent,Old-New,NBn),  
			Spec = lps_delimiter-[SpecE,lps_delimiter-[lps_delimiter-[classify,classify],FC]]
		),
	!,
	remember_fluent_hint(Fluent),
	simple_fluent_colour(Fluent,FC),
	syntax2p_sequence(Event,Vars,lps2p,[_T1,_T2],single,_ET,SpecE,[NB1|NBn]).
syntax2p(L,Vars,lpsp2p,null,PT) :- % LPSP <- Wei term
	var(L), PT=..[F,NB1,H,NBn], 
	((F==terminated) ; (F==initiated)), 
	!,
	LH=..[F,H], L = (LH:-B),
	syntax2p_sequence(B,Vars,lpsp2p,[_T1,_T2],single,_ET,_,[NB1|NBn]). % should be strictier wrt NB1 ?
syntax2p(L,Vars,lps2p,null,PT) :-
	var(L), PT=..[F,NB1,Fluent,NBn], 
	((F==terminated), L_ = (Event terminates Fluent) ; (F==initiated), L_ = (Event initiates Fluent)), 
	!,
	syntax2p_sequence(Conditions,Vars,lps2p,[_T1,_T2],single,_ET,_,[NB1|NBn]),
	(Conditions = (Event,Body) -> L = (L_ if Body) ; L = L_, Conditions=Event).
syntax2p(L,Vars,lps2p,null,updated(NB1,Fluent,Old-New,NBn)) :-
	var(L),
	!,
	L_ = (Event updates Old to New in Fluent), 
	syntax2p_sequence(Conditions,Vars,lps2p,[_T1,_T2],single,_ET,_,[NB1|NBn]),
	(Conditions = (Event,Body) -> L = (L_ if Body) ; L = L_, Conditions=Event).
% intentional fluents and composite events, and more
syntax2p((Head if Body),Vars,lps2p,lps_delimiter-[SpecHead,SpecBody],PT) :-
	(var(PT) -> ToWei=true; ToWei=false),
	(ToWei==true -> syntax2p_literal(Head,Vars,lps2p,[T1,T2],_,SpecHead,NH); true),
	( 
		PT = l_events(NH,NB), NH=happens(_,_,_);
		PT = l_int(NH,NB), NH = holds(_,_)
	),
	!,
	(PT=l_int(_,_) -> IntervalType=single ; IntervalType = _),
	((ToWei==false) -> syntax2p_literal(Head,Vars,lps2p,[T1,T2],_,_,NH) ; true),
	syntax2p_sequence(Body,Vars,lps2p,[T1,T2],IntervalType,_ET,SpecBody,NB).
syntax2p((H:-B),_,_TT,null,PT) :- var(PT), (var(H);var(B)), !, fail.
% time-dependent facts:
syntax2p(Head,Vars,lps2p,Spec,l_int(WHead,[])) :-
	syntax2p_literal(Head,Vars,lps2p,[_T1,_T2],_,Spec,WHead), WHead = holds(_,_),
	!.
syntax2p(Head,Vars,lps2p,Spec,l_events(WHead,[])) :-
	syntax2p_literal(Head,Vars,lps2p,[_T1,_T2],_,Spec,WHead), WHead = happens(_,_,_),
	!.
syntax2p(L,Vars,lpsp2p,null,PT) :- 
	(var(PT) -> ToWei=true; ToWei=false),
	(L = (LH:-LB)->true;LH=L,LB=true), 
	(ToWei==true -> syntax2p_literal(LH,Vars,Translator,[T1,T2],_,_,NH); true),
	( 
		PT = l_events(NH,NB), NH=happens(_,_,_) ;
		PT = l_int(NH,NB), NH = holds(_,_) ;
		% if a timeless head, remember that to override "time looks" in body if need be:
		PT = l_timeless(NH,NB), \+ (nonvar(NH), (NH = holds(_,_);NH = happens(_,_,_)) ), remember_timeless_hint(NH)
	),
	!,
	((ToWei==false) -> syntax2p_literal(LH,Vars,Translator,[T1,T2],_,_,NH) ; true),
	syntax2p_sequence(LB,Vars,Translator,[T1,T2],_,NB).
syntax2p(Term, _, _Translator, classify,Term).  % pass through for Wei terms or other Prolog facts

% syntax2p_observations(ObsCommaList,CommaT2,ObsList,ListT2,-ColourSpec) CommaT2 must be unique
syntax2p_observations(CL,CommaT2,[E],CommonT2,Spec) :- (nonvar(CL)-> \+ functor(CL,',',2) ; true), !, 
	syntax2p_one_obsservation(CL,CommaT2,E,CommonT2,Spec).
syntax2p_observations((Ob,CL),CommaT2,[E|L],CommonT2,delimiter-[Spec1,Specs]) :-
	syntax2p_one_obsservation(Ob,CommaT2,E,CommonT2,Spec1),
	syntax2p_observations(CL,CommaT2,L,CommonT2,Specs).

syntax2p_one_obsservation((E from _ to CT2),T2,E,LT2,delimiter-[EC,classify]) :- !, CT2=T2,CT2=LT2, simple_event_colour(E,EC).
syntax2p_one_obsservation((E to CT2),T2,E,LT2,delimiter-[EC,classify]) :- !, T2=CT2,CT2=LT2, simple_event_colour(E,EC).
syntax2p_one_obsservation((E at CT2),T2,E,LT2,delimiter-[EC,classify]) :- atom(CT2), !, T2=CT2,CT2=LT2, simple_event_colour(E,EC). % for real times/dates
syntax2p_one_obsservation(E,T2,E,T2,EC) :- simple_event_colour(E,EC). 
	% assume T2 defined by another observation

simple_event_colour(E,EC) :- atom(E) -> EC = event ; EC = event-classify.
simple_fluent_colour(E,EC) :- atom(E) -> EC = fluent ; EC = fluent-classify.

% syntax2p_sequence(NicerSequence,Vars,Translator,[Start,End],NiceColouring,WeiPsequence)  [Start,End] may constrain time arguments
syntax2p_sequence(NS,Vars,Translator,Interval,NC,W) :-
	syntax2p_sequence(NS,Vars,Translator,Interval,_IT,_ET,NC,W).

% syntax2p_sequence(NS,Vars,Translator,[T1,T6],+IntervalType,ExplicitTime,NiceColouring,W)  if  IntervalType==single, T6 must be T1+1
syntax2p_sequence((L1,L2),Vars,Translator,[T1,T6],IT, ET, delimiter-[Spec1,Spec2],[PT1|PT2]) :- PT2 \== [], !,
	syntax2p_literal(L1,Vars,Translator,[T2,T3], ETL, Spec1, PT1), 
	syntax2p_sequence(L2,Vars,Translator,[T4,T5],IT,ETS,Spec2, PT2),
	% if no explicit time arguments, the literals are assumed in timely sequence with neighbors
	 % 'single' too strict, should probably reflect into a tc(...) ???
	( (ETL == (false), ETS == (false)) -> ET= (false) ; ET = true),
	(IT==single -> 
		((PT1=happens(_,_,_),ETL==true) -> T3=T6 ; T1=T4,T3=T6)
		; ( (ETL == (false), ETS == (false)) -> T4=T3 ; true)
		),
	T1=T2, T6=T5.
syntax2p_sequence(true,_,_TT,[_T1,_T2],_,false,classify,[]) :- !.
syntax2p_sequence(L,Vars,Translator,Interval,_,ET,Spec,[PT]) :- syntax2p_literal(L,Vars,Translator,Interval,ET,Spec,PT).

% syntax2p_literal(NicerLiteral,+Vars,+Translator,[T1,T2],-ExplicitTime,-NiceColouring,WeiLiteral)
%  for events, [T1,T2] is their interval; for fluents, T1 is the time
% ExplicitTime == true if the given literal has explicit time arguments, false otherwise
syntax2p_literal(tc(TC),_Vars,lpsp2p,[_T1,_T2],true,null,tc(TC)) :- !. % no tc(_) allowed in new syntax... lpsp2p TODO: check Vars for (some) Ts
% event cases first...
syntax2p_literal(L,Vars,lpsp2p,[T1,T2],true,null,happens(NL,T1,T2)) :- 
	nonvar(L),
	L=..LL, append(Tless,[T1,T2],LL),  Tless=[_|_], % last 2 args of term 
	is_time_var(Vars,T1), is_time_var(Vars,T2),	
	\+ head_hint(L,l_timeless),
	!,
	NL=..Tless.
syntax2p_literal(NT,_Vars,lps2p,[T1,T2],ET,event-NC,happens(NEA,T1,T2)) :- 
	(nonvar(NT) -> ToInternal=true, NT=..[EA,LT] ; ToInternal=(false), NEA=..[EA,NL]),
	(EA=initiate ; EA = terminate),
	% tricky handling to avoid infinite terms in the first branch:
	( ToInternal, LT = (L from T1_), (var(T1_);number(T1_)), T1=T1_, ET=true, NC=[delimiter-[EF,classify]] ; 
		ToInternal, LT = (L to T2), ET=true, NC=[delimiter-[EF,classify]] ; 
		LT = (L from T1 to T2), ET=true, NC=[delimiter-[EF,classify]] ; % reverse translation uses this form
		ToInternal, LT = (L during [T1,T2]), ET=true, NC=[delimiter-[EF,classify]] ; 
		ToInternal, LT=L, ET= (false), NC=EF
	),
	!,
	NL=L, 
	simple_fluent_colour(L,EF),
	remember_fluent_hint(L),
	(ToInternal -> NEA=..[EA,NL] ; NT =..[EA,LT]). 
syntax2p_literal(update(in(to(Old,New),LT)),_Vars,lps2p,[T1,T2],ET,event-[delimiter-[classify,NC]],happens(update(Old-New,NL),T1,T2)) :- 
	(nonvar(LT) -> ToInternal=true ; ToInternal=(false)),
	% tricky handling to avoid infinite terms in the first branch:
	( ToInternal, LT = (L from T1_), (var(T1_);number(T1_)), T1=T1_, ET=true, NC=[delimiter-[EF,classify]] ; 
		ToInternal, LT = (L to T2), ET=true, NC=[delimiter-[EF,classify]] ; 
		LT = (L from T1 to T2), ET=true, NC=[delimiter-[EF,classify]] ; % reverse translation uses this form
		ToInternal, LT = (L during [T1,T2]), ET=true, NC=[delimiter-[EF,classify]] ; 
		ToInternal, LT=L, ET= (false), NC=EF
	),
	!,
	NL=L, 
	simple_fluent_colour(L,EF),
	remember_fluent_hint(L). 
syntax2p_literal(LT,_Vars,lps2p,[T1,T2],true,delimiter-[EC,classify],happens(NL,T1,T2)) :- 
	nonvar(LT), 
	% tricky handling to avoid infinite terms in the first branch:
	( LT = (L from T1_), (var(T1_);number(T1_)), T1=T1_; LT = (L to T2); LT = (L from T1 to T2) ; LT = (L during [T1,T2])),
	!,
	simple_event_colour(L,EC),
	remember_event_hint(L),
	NL=L.
syntax2p_literal(LT,_Vars,lps2p,[T1,T2],false,EC,happens(NL,T1,T2)) :- 
	nonvar(LT), ( head_hint(LT,event) /* too strong, due to external_predicate_for_lps/1:  system_action(LT)*/ ),
	!,
	simple_event_colour(LT,EC),
	NL=LT.
syntax2p_literal(L,Vars,lpsp2p,[T1,T2],true,null,happens(NL,T1,T2)) :- 
	var(L),
	!,
	NL=..NLL, append(NLL,[T1,T2],Tplus),  
	!,
	check_time_var(T1,Vars), check_time_var(T2,Vars),
	L=..Tplus.
syntax2p_literal(L,_Vars,lps2p,[T1,T2],true,null,happens(NL,T1,T2)) :- 
	var(L),
	!,
	% L = (NL during [T1,T2]). % ...thus ommitting "..during..." in events is not fully supported when reversing the transform
	L = (NL from T1 to T2). % ...thus ommitting "..during..." in events is not fully supported when reversing the transform

% ... now on to fluents...
syntax2p_literal(not(L),Vars,lpsp2p,[T1,T2],ET,null,holds(not(NL),T)) :- 
	% Wei syntax seems to preclude 'not' elsewhere!
	!,
	syntax2p_literal(L,Vars,lpsp2p,[T1,T2],ET,_,holds(NL,T)),
	check_time_var(T,Vars).
	% Should probably ...? \+ head_hint(L,l_timeless),
syntax2p_literal(LT,_Vars,lps2p,[T1,_T2],ET,Spec,holds(not(NL),T)) :- % not(fluent) at T is the preferred form, but 2 others available
	( 
		LT= (not(F) at T), Spec = delimiter - [delimiter-[EF],classify], ET=true ; 
		LT= not(F at T), Spec = delimiter - [delimiter - [EF,classify]], ET=true ; 
		LT= not(F), head_hint(F,fluent), Spec = delimiter - [EF], ET=false
		),
	!,
	simple_fluent_colour(F,EF),
	NL=F,
	remember_fluent_hint(F),
	T1=T.	
syntax2p_literal(not(FS),Vars,lps2p,[T1,T2],ET,Spec,holds(not(NL),T)) :- 
	syntax2p_sequence(FS,Vars,lps2p,[T1,T2],single,ET,NiceColouring,NL),
	member(holds(_,_),NL), 
	!,
	Spec = delimiter - NiceColouring, T1=T.
syntax2p_literal(LT,Vars,lps2p,[T1,T2],ET,Spec,holds(findall(X,WFS,L),T)) :- 
	( 
		LT= (findall(X,FS,L) at T), Spec = lps_delimiter - [delimiter-[classify,NiceColouring,classify],classify], ET=true ; 
		LT= findall(X,FS,L), Spec = delimiter-[classify,NiceColouring,classify], ET=false),
	syntax2p_sequence(FS,Vars,lps2p,[T1,T2],single,_ET,NiceColouring,WFS),
	member(holds(_,_),WFS),
	!,
	T1=T.	
syntax2p_literal(L,Vars,lpsp2p,[T1,_T2],true,null,holds(NL,T)) :- 
	nonvar(L),
	L=..LL, LL=[_,_|_], append(Tless,[T],LL), 
	is_time_var(Vars,T),
	\+ head_hint(L,l_timeless),
	!,
	NL=..Tless, T=T1.
syntax2p_literal(LT,_Vars,lps2p,[T1,_T2],true,delimiter-[FC,classify],holds(NL,T)) :- 
	nonvar(LT), LT = (F at T),
	!,
	NL=F, T=T1,
	simple_fluent_colour(F,FC),
	remember_fluent_hint(F).
syntax2p_literal(F,_Vars,lps2p,[T1,_T2],false,EF,holds(NL,T)) :- 
	nonvar(F), ( head_hint(F,fluent) ; system_fluent(F)),
	!,
	simple_fluent_colour(F,EF),
	NL=F, T=T1.
syntax2p_literal(L,Vars,lpsp2p,[T1,_T2],true,null,holds(NL,T)) :- 
	var(L),
	!,
	is_time_var(Vars,T), T=T1,
	NL=..NLL, append(NLL,[T],Tplus),
	L=..Tplus.
syntax2p_literal(L,_Vars,lps2p,[T1,_T2],true,null,holds(NL,T)) :- 
	var(L),
	!,
	L = (NL at T), T1=T. % ...thus ommitting "..at..." in fluents is not fully supported when reversing the transform
syntax2p_literal(L,_,_Translator,[_T1,_T2],false,body(L),L) :- may_add_timeless_ref(L). % some timeless literal

check_time_var(V,Vars) :- is_time_var(Vars,V), !.
check_time_var(V,Vars) :-
	writeln('*** Warning: time variable in a time predicate should start with T:'), 
	\+ \+ (bindAllVars(Vars), writeln(V)).
	
% is_time_var(AllVars,Var)
% Accepting any Txxx variable as time variable
is_time_var([],_T) :-!, fail.
is_time_var([VV|_Vars], T) :- arg(2,VV,V), V==T, !,
	is_time_var(VV).
is_time_var([_VV|Vars], T) :- is_time_var(Vars, T).

is_time_var(VV) :- 
	arg(1,VV,Name), atom_codes(Name,Codes), 
	(append("T",Rest,Codes);append("_T",Rest,Codes)),
	!,
	(Rest=[] -> true ; 
		Rest=[C|_], 
		% T_... or T0/9...
		(C==95->true;C>=48,C=<57)
	).
	

% Declare here predicates you wish to keep unchanged accross the transform
% For some specific cases, predicate sort hints are remembered
% Most bodies left var, as we may want to use Prolog there, for some kind of "meta-level"
% Finally, we leave Wei syntax terms untouched when translating TO that syntax, so we can mixing them in
% do_not_transform_may_hint(Head,SyntaxName,ToWei,Body,-ColourSpec)
do_not_transform_may_hint(observe(Events,_),_,_,_,lps_delimiter-classify) :-!, remember_hints(event,Events). 
do_not_transform_may_hint(fluent(F),_,_,_,lps_delimiter-[fluent-classify]) :- !, remember_declarations(fluent,F).
do_not_transform_may_hint(fluents(Fls),_,true,_,lps_delimiter-[(fluents/* huh?? weird but probably irrelevant*/)-classify]) :- is_list(Fls), !, 
	remember_declarations(fluent,Fls).
do_not_transform_may_hint(event(E),_,_,_,lps_delimiter-[event-classify]) :- !, remember_declarations(event,E).
do_not_transform_may_hint(events(Evs),_,true,_,lps_delimiter-[(events)-classify]) :- is_list(Evs), !, 
	remember_declarations(event,Evs).
do_not_transform_may_hint(prolog_events(Evs),_,true,_,lps_delimiter-[(events)-classify]) :- is_list(Evs), !, 
	remember_declarations(event,Evs).
do_not_transform_may_hint(action(A),_,_,_,lps_delimiter-[event-classify]) :- !, remember_declarations(event,A).
do_not_transform_may_hint(actions(As),_,true,_,lps_delimiter-[(actions)-classify]) :- is_list(As), !, 
	remember_declarations(action,As).
do_not_transform_may_hint(unserializable(As),_,true,_,null) :- is_list(As), !.
do_not_transform_may_hint(initial_state(S),_,true,_,lps_delimiter-[Specs]) :- !, remember_hints(fluent,S), comma_to_list(_,fluent,Specs,S).
do_not_transform_may_hint(l_int(_,_),_,true,_,null).
do_not_transform_may_hint(l_events(_,_),_,true,_,null).
do_not_transform_may_hint(l_timeless(_,_),_,true,_,null).
do_not_transform_may_hint(initiated(_,_,_),_,true,_,null).
do_not_transform_may_hint(terminated(_,_,_),_,true,_,null).
do_not_transform_may_hint(reactive_rule(_,_,_),_,true,_,null).
do_not_transform_may_hint(reactive_rule(_,_),_,true,_,null).
do_not_transform_may_hint(d_pre(_),_,true,_,null).
do_not_transform_may_hint(maxTime(_),lps2p,_,_,lps_delimiter-classify).
do_not_transform_may_hint(maxRealTime(_),lps2p,_,_,lps_delimiter-classify).
do_not_transform_may_hint(minCycleTime(_),lps2p,_,_,lps_delimiter-classify).
do_not_transform_may_hint(simulatedRealTimePerCycle(_),lps2p,_,_,lps_delimiter-classify).
do_not_transform_may_hint(simulatedRealTimeBeginning(_),lps2p,_,_,lps_delimiter-classify).


% pretty printing for all syntaxes; although not doing anything specific to the new (lps2p translator) syntax
% pretty_write_withvars(Clause,VarsList)
pretty_write_withvars(Term,Vars) :- pretty_write(Term,0,Vars,user_output).

pretty_write(Term,Stream) :- pretty_write(Term,0,[],Stream).

% my_write(Stream,Term,Vars) like writeq but printing nice variable names
my_write(S,T,Vars) :- write_term(S,T,[quoted(true),variable_names(Vars)]).

% pretty_write(Term,Indent,Vars,Stream)
pretty_write((if A then C priority P),I,Vars,S) :- !, 
	my_tab(S,I), write(S,'if '), my_write(S,A,Vars), nl(S),
	my_tab(S,I), write(S,'then '), writeln(S,''), 
	NI is I+4, pretty_write(C,NI,Vars,S), 
	write(S,'  priority '), my_write(S,P,Vars).
pretty_write((if A then C),I,Vars,S) :- !, 
	my_tab(S,I), write(S,'if '), my_write(S,A,Vars), nl(S),
	my_tab(S,I), write(S,'then '), writeln(S,''), 
	NI is I+4, pretty_write(C,NI,Vars,S).
pretty_write((H if B),I,Vars,S) :- !, 
	my_tab(S,I), my_write(S,H,Vars), writeln(S,' if'), 
	my_tab(S,I), NI is I+4, pretty_write(B,NI,Vars,S).
pretty_write((A--->C priority P),I,Vars,S) :- !, 
	my_tab(S,I), my_write(S,A,Vars), writeln(S,' --->'), 
	NI is I+4, pretty_write(C,NI,Vars,S),
	write(S,'  priority '), my_write(S,P,Vars).
pretty_write((A--->C),I,Vars,S) :- !, 
	my_tab(S,I), my_write(S,A,Vars), writeln(S,' --->'), NI is I+4, pretty_write(C,NI,Vars,S).
pretty_write(Declaration,I,Vars,S) :- Declaration=..[Op,C], member(Op,[false,initially,fluents,events,prolog_events,actions]), !,
	my_tab(S,I), write(S,Op), writeln(S,''), NI is I+4,
	pretty_write(C,NI,Vars,S).
pretty_write(PostCondition,I,Vars,S) :- 
	(
		PostCondition = (E terminates F :- C), Op=(terminates) ; 
		PostCondition = (E initiates F :- C), Op=(initiates) ;
		PostCondition = (E terminates F), C=true, Op=(terminates) ;
		PostCondition = (E initiates F), C=true, Op=(initiates)
	), !,
	my_tab(S,I), my_write(S,E,Vars), write(S,' '), 
	write(S,Op), write(S,' '), pretty_write((F:-C),I,Vars,S).
	

pretty_write((H:-true),I,Vars,S) :- !, pretty_write(H,I,Vars,S).
pretty_write((H:-B),I,Vars,S) :- !, 
	my_tab(S,I), my_write(S,H,Vars), writeln(S,' :-'), NI is I+4, pretty_write(B,NI,Vars,S).
pretty_write((G1,G2),I,Vars,S) :- !, 
	my_tab(S,I), my_write(S,G1,Vars), writeln(S,','), pretty_write(G2,I,Vars,S).
pretty_write(G,I,Vars,S) :- my_tab(S,I), my_write(S,G,Vars).

my_tab(_S,0) :- !.
my_tab(S,I) :- I>0, write(S,' '), NI is I-1, my_tab(S,NI).

% predicate_for(Term,Spec)
predicate_for(V,none) :- var(V), !.
predicate_for((H:-_),F/A) :- !, functor(H,F,A).
predicate_for(H,F/A) :- functor(H,F,A).

init_definition_newliner :- set_currently_defining(none).

set_currently_defining(P) :- 
	retractall('_currenty__defining'(_)), assert('_currenty__defining'(P)).
	
may_write_newline(Term,S) :- 
	predicate_for(Term,P), 
	( '_currenty__defining'(P) -> true ; set_currently_defining(P), writeln(S,'')).
