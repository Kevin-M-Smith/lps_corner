/* 
** Author(s): Miguel Calejo
** Contact:   info@interprolog.com, http://interprolog.com
** Copyright (C) InterProlog Consulting / Renting Point - Serviços de Informática Lda., Portugal 2016
** Use and distribution, without any warranties, under the terms of the 
** Apache 2.0 License, readable in http://www.apache.org/licenses/LICENSE-2.0.html
*/

/* Implement a surface syntax closer to that used on papers (.LPSP extension), 
mapping both to/from "Wei syntax" (.P or .pl extension) as assumed in the engine .
The syntax is as follows:

Antecedent ---> Consequent.
Antecedent ---> Consequent priority P.
myEvent(X,T1,T2) :- 
   whatever(T1), blah(X), ev(T1,Tx),  tc(Tx>T1), anotherEvent(Tx,T2).
intensional(A,T) :- some_fluent(B,T), timelessP(A,B).
false :- pickup_forks(F1, philosopher(N), F2,T1,T2),   not available(F1,T1).
initiated available(F2) :- 
  putdown_forks(F1, philosopher(N), F2,T1,T2).
terminated available(F2) :- 
  putdown_forks(F1, philosopher(N), F2,T1,T2).

Time variables must start with T or _T, followed by _ or a digit.
Prolog facts in general are not transformed.
In particular, initial_state(FluentsList) and observe(EventsList,Time) should be present.

IMPORTSNT LIMITATION wrt time variable convention: 
If a l_timeless predicate has T variables, it's (reverse) conversion to our syntax will be wrong...
... because on a subsequent conversion (from ours to Wei's) that predicate will become a timefull predicate
Ditto for "timeful" predicates with non-T variables
--------------
ALSO...implements another, nicer syntax  (.LPS extension), 
mapping both to/from "Wei syntax" (.P or .pl extension) as assumed in the engine .
This syntax is as follows:

if Antecedent then Consequent.
if Antecedent then Consequent priority P.
myEvent(X) during [T1,T2] if 
   someFluent at T1, prolog_goal(X), ev during [T1,Tx],  tc(Tx>T1), anotherEvent during [Tx,T2].
intensional(A) at T :- some_fluent(B) at T, timelessP(A,B).
...myEvent1(X) : myFluent(X) : myEvent2(X)...  % implicit time arguments, all contiguous, same as:
%  ...myEvent1(X) during [T1,T2], myFluent(X) at T2, myEvent2(X) during [T2,T3]...
%  assuming these predicates to be time-dependent predicates already declared
initial_state1(foo) at 0.
initial_state2(bar) at 0.

false pickup_forks(F1, philosopher(N), F2), not available(F1). % same instant/interval

putdown_forks(F1, philosopher(N), F2) initiates available(F1). % if true.
putdown_forks(F1, philosopher(N), F2) terminates available(F1). % 
% later addition, to base Wei syntax: fluent list, easy to implement on interpreter

observe([event1(foo),event2(bar)],3).

maxTime(10).

.... T1>T2 ... ----> tc(T1>T2) 

Prolog facts in general are not transformed.
*/

:- module(psyntax,[ syntax2p/4, lpsp2p_file/2, lpsp2p/3, 
	lps2p_file/2, lps2p/3, syntax2p_file/4, syntax2p/4,
	gol/2, gol/1, golps/2, golps/1]).

%%% XSB specific section:
:- if(current_prolog_flag(dialect, xsb)).

:- use_module(interpreter,[go/3,uassert/1, uretractall/1, collect_guessed_declarations/1,bindAllVars/1]). % assumed preloaded
:- use_module(db,[head_hint/3, '_currenty__defining'/1]).
:- use_module(basics, [member/2, append/3]).
:- use_module(string,[concat_atom/2]).
:- consult:add_this_lib_dir. % is this needed??
:- use_module(xsb_read,[ file_read/3]).

my_file_read(Stream,Term,Vars) :- file_read(Stream,Term,Vars).

% New syntax .lps
:- op(1200,xfx,then).
:- op(1185,fx,if).
:- op(1200,xfx,if).
:- op(1050,xfx,(terminates)).
:- op(1050,xfx,(initiates)).
% Rejected:-( :- op(1050,fx,impossible). 
:- op(1050,fx,observe).
:- op(1050,fx,false).
:- op(1050,fx,initially).
:- op(1050,fx,fluents).
:- op(1050,fx,events).
:- op(1050,fx,actions).
:- op(995,xfx,at).
:- op(995,xfx,during).
% :- op(995,xfx,from). Already defined in XSB with higher priority... so parenthesis needed e.g. (event 1 from 1 to 2), event 2 to 3
:- op(994,xfx,to). % from's priority higher
:- op(1050,xfy,::).

% older syntax lpsp2p:
:- op(1200,xfx,--->). % for reactive rules
:- op(1190,xfx,priority). %... with priority
:- op(900,fy,terminated).
:- op(900,fy,initiated).

:- endif.

%%% end of XSB specific section; now for SWI:

:- if((current_prolog_flag(dialect, swi), current_module(swish))). 
% first, SWISH specific; see comments in interpreter.P

:- use_module(library(pengines),[pengine_self/1]).
:- use_module(library(prolog_clause),[clause_info/5]).
head_hint(X,Y,Z) :- pengine_self(M), catch(M:head_hint(X,Y,Z),_,fail).
'_currenty__defining'(X) :- pengine_self(M), catch(M:'_currenty__defining'(X),_,fail).

:- use_module(library(pengines),[pengine_self/1]).
dumploaded :- 
	pengine_self(M), current_predicate(M:F/N), functor(H,F,N), 
	clause(M:H,Body,Ref), 
	% clause_property(Ref,line_count(LineNumber)), clause_property(Ref,file(File)),
	% clause_info(Ref, _File, _TermPos, _VarOffsets, [variable_names(_Vars)]), % this effectively filters out swish predicates
	interpreter:lps_source_position(H,_,_,Vars), bindAllVars(Vars),
	% term_variables((H:-Body),VarValues),    _Vars: [Name1=VarValue1,...]
	%_TermPos = term_position(Char,CharEnd,_,_,_),
	%print_message(error,error(syntax_error(whatever),file(File,LineNumber,_one,_Char))),
	pretty_write((H:-Body)), writeln('.'),
	%write('  '), writeln(File), % e.g. pengine://fa945952-355c-47a3-bb48-bdf8dfdb4229/src
	%write('  '), writeln(TermPos/Vars), % e.g. term_position(384,446,416,420,[term_position(.... ])/[N=_1022]
	fail.
dumploaded.

:- endif.

:- if((current_prolog_flag(dialect, swi), \+ current_module(swish))).
% Now support for vanilla/barebones SWI Prolog:

:- use_module('../Wei-engine/db.P',[head_hint/3, '_currenty__defining'/1]).

:- endif.

:- if(current_prolog_flag(dialect, swi)).
% ...and finally the generic SWI support:

:- use_module('../engine/interpreter.P',[go/3,uassert/1, uretractall/1, collect_guessed_declarations/1,bindAllVars/1]).
:- use_module(library(dialect/sicstus/system),[file_exists/1]).
my_file_read(Stream,Term,Vars) :- read_term(Stream,Term,[variable_names(Vars)]).

% New syntax .lps
:- op(900,fy,user:(not)). 
:- op(1200,xfx,user:(then)).
:- op(1185,fx,user:(if)).
:- op(1200,xfx,user:(if)).
:- op(1050,xfx,user:(terminates)).
:- op(1050,xfx,user:(initiates)).
% Rejected:-( :- op(1050,fx,impossible). 
:- op(1050,fx,user:(observe)).
:- op(1050,fx,user:(false)).
:- op(1050,fx,user:initially).
:- op(1050,fx,user:fluents).
:- op(1050,fx,user:events).
:- op(1050,fx,user:actions).
:- op(995,xfx,user:(at)).
:- op(995,xfx,user:(during)).
:- op(995,xfx,user:from). 
:- op(994,xfx,user:to). % from's priority higher
:- op(1050,xfy,user:(::)).
% older syntax lpsp2p:
:- op(1200,xfx,--->). % for reactive rules
:- op(1190,xfx,priority). %... with priority
:- op(900,fy,terminated).
:- op(900,fy,initiated).

:- endif.

%%% From here on, generic Prolog code

% grabbed from XSB:
closetail([]) :- !.
closetail([_|L]) :- closetail(L).

comma_to_list((One,Two),[One|Twol]):- Twol \== [], !,
	comma_to_list(Two,Twol).
comma_to_list(One,[One]).

% functor_arityze(TemplatesOrFA,TemplatesList) replaces term functor/arities by their templates; 
% bidirectional (albeit losing information of course)
functor_arityze([F/A|TOFAL],[G|FAL]) :- functor(G,F,A), !, functor_arityze(TOFAL,FAL).
functor_arityze([T|TOFAL],[T|FAL]) :- !, functor_arityze(TOFAL,FAL).
functor_arityze([],[]).

% Convert a file in LPSP into Wei syntax and execute it 
gol(LPSP_file,Options,Results) :-
	concat_atom([LPSP_file,'_.P'],Pfile),
	syntax2p_file(LPSP_file,Pfile,lpsp2p,true),
	go(Pfile,Options,Results).

gol(LPSP_file,Options) :- gol(LPSP_file,Options,[]).

gol(LPSP_file) :- gol(LPSP_file,[]).

% Convert a file in LPS (new syntax) into Wei syntax and execute it 
golps(LPSP_file,Options,Results) :-
	concat_atom([LPSP_file,'_.P'],Pfile),
	syntax2p_file(LPSP_file,Pfile,lps2p,true),
	go(Pfile,Options,Results).

golps(LPSP_file,Options) :- golps(LPSP_file,Options,[]).

golps(LPSP_file) :- golps(LPSP_file,[]).
	
% File converters:

% lpsp2p_file(?LPSPfile,?LPSWfile) "papers syntax"
lpsp2p_file(LPSPfile,LPSWfile) :- atom(LPSPfile), !,
	(atom(LPSWfile)->true;concat_atom([LPSPfile,'_.lpsw'],LPSWfile)),
	syntax2p_file(LPSPfile,LPSWfile,lpsp2p,true).
lpsp2p_file(LPSPfile,LPSWfile) :- 
	atom(LPSWfile), 
	(atom(LPSPfile)->true;concat_atom([LPSWfile,'_.lpsp'],LPSPfile)),
	syntax2p_file(LPSPfile,LPSWfile,lpsp2p,false).

% lps2p_file(?LPSfile,?LPSWfile) "new syntax", Nov-Dec 2016
lps2p_file(LPSfile,LPSWfile) :- atom(LPSfile), !,
	(atom(LPSWfile)->true;concat_atom([LPSfile,'_.lpsw'],LPSWfile)),
	syntax2p_file(LPSfile,LPSWfile,lps2p,true).
lps2p_file(LPSfile,LPSWfile) :- 
	atom(LPSWfile), 
	(atom(LPSfile)->true;concat_atom([LPSWfile,'_.lps'],LPSfile)),
	syntax2p_file(LPSfile,LPSWfile,lps2p,false).


% Main file to file syntax converter
% syntax2p_file(+OtherSyntaxFile,+P_Wei_file,+Translator,+ToWei) Translator is a functor for a predicate Translate(Term,Vars,NewTerm)
% If ToWei==true it generates a .P file from the first file, else vice-versa
syntax2p_file(Lfile,Pfile,Translator,ToWei) :-
	( member(Translator,[lpsp2p,lps2p]) -> true 
		; write('*** Bad syntax translator: '), writeln(Translator), fail),
	init_definition_newliner,
	uretractall(head_hint(_,_,_)),
	( current_prolog_flag(write_depth,Old) -> set_xsb_flag(write_depth,10000) ; true), % XSB specific, ignore otherwise
	(ToWei==true -> 
		file_exists(Lfile), open(Lfile,read,IStr), open(Pfile,write,OStr), 
		Convert =.. [Translator,Term,Vars,NewTerm]
		; 
		file_exists(Pfile), open(Pfile,read,IStr), open(Lfile,write,OStr),
		Convert =.. [Translator,NewTerm,Vars,Term]
		),
	% IStr >= 0, OStr>=0,
	nonvar(IStr), nonvar(OStr),
	repeat,
	catch(my_file_read(IStr,Term,Vars),Ex,writeln(ex-Ex)), closetail(Vars),
	( Term==end_of_file -> true
	;  
		(Convert->true; write('*** failed '), writeln(Convert), fail), 
		% When converting back to our syntax from Wei's, make sure T vars are not misinterpreted:
		% NO! Too strong
		% ((ToWei\==true, member(V,Vars), is_time_var(V)) -> true
		%	; 
		bindAllVars(Vars), 
		may_write_newline(NewTerm,OStr),
		pretty_write(NewTerm,OStr), writeln(OStr,'.'), 
		fail
	),
	!,
	(ToWei==true ->
		% may generate missing declarations
		collect_guessed_declarations(Facts),
		forall( 
			member(Fact,Facts), 
			(may_write_newline(Fact,OStr), pretty_write(Fact,OStr), writeln(OStr,'.'))
			)
	; true),
	close(OStr),close(IStr),
	(nonvar(Old)->set_xsb_flag(write_depth,Old);true).


% head_hint(HeadTemplate,Sort,Declared) Sort maybe l_timeless,event,fluent
%  a fact means that some head was read before and tagged as Sort
%  used only when transforming from some nicer to Wei syntax 
%  Declared is 'true' if a declaration (not just usage) was detected
head_hint(X,Sort) :- head_hint(X,Sort,_).

remember_hint(Type,H) :- 
	nonvar(Type), nonvar(H),
	member(Type,[fluent,event,action,timeless]),
	functor(H,F,N), functor(HH,F,N),
	( head_hint(HH,Type,_) ->  true; uassert(head_hint(HH,Type,false) )).

remember_timeless_hint(TL) :- remember_hint(timeless,TL).

remember_event_hint((E during _Interval)) :- !, remember_event_hint(E).
remember_event_hint(TL) :- remember_hint(event,TL).

% Do we need events and actions??
%remember_action_hint((E during _Interval)) :- !, remember_action_hint(E).
%remember_action_hint(TL) :- remember_hint(action,TL).

remember_fluent_hint((F at _T)) :- !, remember_fluent_hint(F).
remember_fluent_hint(TL) :- remember_hint(fluent,TL).

remember_declaration(Type,H) :- 
	nonvar(Type), nonvar(H),
	member(Type,[fluent,event,action,timeless]),
	functor(H,F,N), functor(HH,F,N),
	( head_hint(HH,Type,true) ->  true; uretractall(head_hint(HH,Type,_)), uassert(head_hint(HH,Type,true) )).
	
% remember_hints(Type,LiteralOrList)
remember_hints(_Type,X) :- var(X), ! . %, !, write('*** Underspecified term of sort '), writeln(Type).
remember_hints(_Type,[]) :- !.
remember_hints(Type,[X1|Xn]) :- !, remember_hint(Type,X1), remember_hints(Type,Xn).
remember_hints(Type,X) :- remember_hint(Type,X).

% remember_declarations(Type,LiteralOrList)
remember_declarations(Type,X) :- var(X), !, write('*** Underspecified declared term of sort '), writeln(Type).
remember_declarations(_Type,[]) :- !.
remember_declarations(Type,[X1|Xn]) :- !, remember_declaration(Type,X1), remember_declarations(Type,Xn).
remember_declarations(Type,X) :- remember_declaration(Type,X).

	
% convenience predicates for environment syntax checkers:
lpsp2p(LPSPterm,Vars,Pterm) :- syntax2p(LPSPterm,Vars,lpsp2p,Pterm).
lps2p(LPSPterm,Vars,Pterm) :- syntax2p(LPSPterm,Vars,lps2p,Pterm).

% Main term syntax converter
%
% syntax2p(?NicerSyntaxTerm,+Vars,+Translator,?WeiPterm) 
% Vars is a (closed tail) list of some_functor(Name,Variable)
% Translator: lpsp2p ("papers syntax") or lps2p ("new syntax"); 
% Either LPSPterm or Pterm must be bound; the other should be unbound
% Probably needs to evolve to return error messages
syntax2p(L,_,_TT,PT) :- var(L), var(PT), !, fail.
% convenience notation for declarations:
syntax2p((initially States),_Vars,lps2p,initial_state(StatesList)) :- !, 
	comma_to_list(States,StatesList).
% single observations, declared as fact declarations; more complex cases handled further below
syntax2p((observe E from _T1 to T2),_Vars,lps2p,observe([E],T2)) :- !.
syntax2p((observe E to T2),_Vars,lps2p,observe([E],T2)) :- !.
syntax2p((actions A),_Vars,lps2p,actions(NL)) :- nonvar(A), !, comma_to_list(A,L), functor_arityze(L,NL), remember_declarations(event,NL).
syntax2p((actions A),_Vars,lps2p,actions(L)) :- !, comma_to_list(A,L).
syntax2p((events A),_Vars,lps2p,events(NL)) :- nonvar(A), !, comma_to_list(A,L), functor_arityze(L,NL), remember_declarations(event,NL).
syntax2p((events A),_Vars,lps2p,events(L)) :- !, comma_to_list(A,L).
syntax2p((fluents A),_Vars,lps2p,fluents(NL)) :- nonvar(A), !, comma_to_list(A,L), functor_arityze(L,NL), remember_declarations(fluent,NL).
syntax2p((fluents A),_Vars,lps2p,fluents(L)) :- !, comma_to_list(A,L).
% reactive rules:
syntax2p((if A then C priority P), Vars,TT, reactive_rule(NA,NC,P)) :- TT=lps2p, !, % TODO: should add T3>=T1?? interpreter enforced?
	syntax2p_sequence(A,Vars,TT,[_T1,_T2],NA), syntax2p_sequence(C,Vars,TT,[_T3,_T4],NC).
syntax2p((A--->C priority P), Vars,TT, reactive_rule(NA,NC,P)) :- TT=lpsp2p, !, 
	syntax2p_sequence(A,Vars,TT,[_T1,_T2],NA), syntax2p_sequence(C,Vars,TT,[_T3,_T4],NC).
syntax2p((if A then C), Vars,TT, reactive_rule(NA,NC)) :- TT=lps2p, !, 
	syntax2p_sequence(A,Vars,TT,[_T1,_T2],NA), syntax2p_sequence(C,Vars,TT,[_T3,_T4],NC).
syntax2p((A--->C),Vars,TT,reactive_rule(NA,NC)) :- TT=lpsp2p, !, 
	syntax2p_sequence(A,Vars,TT,[_T1,_T2],NA), syntax2p_sequence(C,Vars,TT,[_T3,_T4],NC).
% pre-conditions:
syntax2p((false B),Vars,lps2p,d_pre(IC)) :- !, 
	syntax2p_sequence(B,Vars,lps2p,[_T1,_T2],single,_ET,IC).
syntax2p(((false):-B),Vars,lpsp2p,d_pre(IC)) :- !, 
	syntax2p_sequence(B,Vars,lpsp2p,[_T1,_T2],single,_ET,IC).
% now post-conditions:	
syntax2p((IT:-B),Vars,lpsp2p,PT) :- % LPSP -> Wei term
	var(PT),
	IT=..[F,H], ((F==terminated) ; (F==initiated)), 
	!,
	syntax2p_sequence(B,Vars,lpsp2p,[_T1,_T2],single,_ET,[NB1|NBn]), % should be strictier wrt NB1 ?
	PT=..[F,NB1,H,NBn].
syntax2p((H if B),Vars,lps2p,PT) :- % 
	var(PT),
	( H= (Event initiates Fluent), PT=initiated(NB1,Fluent,NBn) ; H= (Event terminates Fluent), PT=terminated(NB1,Fluent,NBn)),
	!,
	remember_fluent_hint(Fluent), remember_event_hint(Event),
	syntax2p_sequence((Event,B),Vars,lps2p,[_T1,_T2],single,_ET,[NB1|NBn]).
syntax2p(H,Vars,lps2p,PT) :- % 
	var(PT),
	( H= (Event initiates Fluent), PT=initiated(NB1,Fluent,NBn) ; H= (Event terminates Fluent), PT=terminated(NB1,Fluent,NBn)),
	!,
	remember_fluent_hint(Fluent),
	syntax2p_sequence(Event,Vars,lps2p,[_T1,_T2],single,_ET,[NB1|NBn]).
syntax2p(L,Vars,lpsp2p,PT) :- % LPSP <- Wei term
	var(L), PT=..[F,NB1,H,NBn], 
	((F==terminated) ; (F==initiated)), 
	!,
	LH=..[F,H], L = (LH:-B),
	syntax2p_sequence(B,Vars,lpsp2p,[_T1,_T2],single,_ET,[NB1|NBn]). % should be strictier wrt NB1 ?
syntax2p(L,Vars,lps2p,PT) :-
	var(L), PT=..[F,NB1,Fluent,NBn], 
	((F==terminated), L_ = (Event terminates Fluent) ; (F==initiated), L_ = (Event initiates Fluent)), 
	!,
	syntax2p_sequence(Conditions,Vars,lps2p,[_T1,_T2],single,_ET,[NB1|NBn]),
	(Conditions = (Event,Body) -> L = (L_ :- Body) ; L = L_, Conditions=Event).
% intentional fluents and composite events, and more
syntax2p((Head if Body),Vars,lps2p,PT) :-
	(var(PT) -> ToWei=true; ToWei=false),
	(ToWei==true -> syntax2p_literal(Head,Vars,lps2p,[T1,T2],_,NH); true),
	( 
		PT = l_events(NH,NB), NH=happens(_,_,_) ;
		PT = l_int(NH,NB), NH = holds(_,_)
	),
	!,
	((ToWei==false) -> syntax2p_literal(Head,Vars,lps2p,[T1,T2],_,NH) ; true),
	syntax2p_sequence(Body,Vars,lps2p,[T1,T2],NB).
syntax2p((H:-B),_,_TT,PT) :- var(PT), (var(H);var(B)), !, fail.
syntax2p(NT,_,TT,(H:-B)) :- 
	(nonvar(NT)->ToWei=true;ToWei=false),
	NT = (H:-B),
	do_not_transform_may_hint(H,TT,ToWei,B), !.
syntax2p(NT,_,TT,Fact) :- 
	(nonvar(NT)->ToWei=true;ToWei=false),
	NT=Fact,
	do_not_transform_may_hint(NT,TT,ToWei,true), !.
syntax2p(L,Vars,lpsp2p,PT) :- 
	(var(PT) -> ToWei=true; ToWei=false),
	(L = (LH:-LB)->true;LH=L,LB=true), 
	(ToWei==true -> syntax2p_literal(LH,Vars,Translator,[T1,T2],_,NH); true),
	( 
		PT = l_events(NH,NB), NH=happens(_,_,_) ;
		PT = l_int(NH,NB), NH = holds(_,_) ;
		% if a timeless head, remember that to override "time looks" in body if need be:
		PT = l_timeless(NH,NB), \+ (nonvar(NH), (NH = holds(_,_);NH = happens(_,_,_)) ), remember_timeless_hint(NH)
	),
	!,
	((ToWei==false) -> syntax2p_literal(LH,Vars,Translator,[T1,T2],_,NH) ; true),
	syntax2p_sequence(LB,Vars,Translator,[T1,T2],NB).
syntax2p(Term, _, _Translator, Term). % pass through for Wei terms or other Prolog facts

% syntax2p_sequence(NicerSequence,Vars,Translator,[Start,End],WeiPsequence)  [Start,End] may constrain time arguments
syntax2p_sequence(NS,Vars,Translator,Interval,W) :-
	syntax2p_sequence(NS,Vars,Translator,Interval,_IT,_ET,W).

% syntax2p_sequence(NS,Vars,Translator,[T1,T6],IntervalType,ExplicitTime,W)  if  IntervalType==single, T6 must be T1+1
syntax2p_sequence((L1,L2),Vars,Translator,[T1,T6],IT, ET, [PT1|PT2]) :- PT2 \== [], !,
	syntax2p_literal(L1,Vars,Translator,[T2,T3], ETL, PT1), 
	syntax2p_sequence(L2,Vars,Translator,[T4,T5],IT,ETS,PT2),
	% if no explicit time arguments, the literals are assumed in timely sequence with neighbors
	 % 'single' too strict, should probably reflect into a tc(...) ???
	( (ETL == (false), ETS == (false)) -> ET= (false) ; ET = true),
	(IT==single -> T1=T4,T3=T6; ( (ETL == (false), ETS == (false)) -> T4=T3 ; true)),
	T1=T2, T6=T5.
syntax2p_sequence(true,_,_TT,[_T1,_T2],_,false,[]) :- !.
syntax2p_sequence(L,Vars,Translator,Interval,_,ET,[PT]) :- syntax2p_literal(L,Vars,Translator,Interval,ET,PT).

% syntax2p_literal(NicerLiteral,+Vars,+Translator,[T1,T2],-ExplicitTime,WeiLiteral)
%  for events, [T1,T2] is their interval; for fluents, T1 is the time
% ExplicitTime == true if the given literal has explicit time arguments, false otherwise

syntax2p_literal(tc(TC),_Vars,lpsp2p,[_T1,_T2],true,tc(TC)) :- !. % no tc(_) allowed in new syntax... lpsp2p TODO: check Vars for (some) Ts

% event cases first...
syntax2p_literal(L,Vars,lpsp2p,[T1,T2],true,happens(NL,T1,T2)) :- 
	nonvar(L),
	L=..LL, append(Tless,[T1,T2],LL),  Tless=[_|_], % last 2 args of term 
	is_time_var(Vars,T1), is_time_var(Vars,T2),	
	\+ head_hint(L,l_timeless),
	!,
	NL=..Tless.
syntax2p_literal(LT,_Vars,lps2p,[T1,T2],true,happens(NL,T1,T2)) :- 
	nonvar(LT), 
	( LT = (L from T1 to T2) ; LT = (L from T1); LT = (L to T2); LT = (L during [T1,T2])),
	!,
	remember_event_hint(L),
	NL=L.
syntax2p_literal(LT,_Vars,lps2p,[T1,T2],false,happens(NL,T1,T2)) :- 
	nonvar(LT), head_hint(LT,event),
	!,
	NL=LT.
syntax2p_literal(L,Vars,lpsp2p,[T1,T2],true,happens(NL,T1,T2)) :- 
	var(L),
	!,
	NL=..NLL, append(NLL,[T1,T2],Tplus),  
	!,
	check_time_var(T1,Vars), check_time_var(T2,Vars),
	L=..Tplus.
syntax2p_literal(L,_Vars,lps2p,[T1,T2],true,happens(NL,T1,T2)) :- 
	var(L),
	!,
	% L = (NL during [T1,T2]). % ...thus ommitting "..during..." in events is not fully supported when reversing the transform
	L = (NL from T1 to T2). % ...thus ommitting "..during..." in events is not fully supported when reversing the transform

% ... now on to fluents...
syntax2p_literal(not(L),Vars,lpsp2p,[T1,T2],ET,holds(not(NL),T)) :- 
	% Wei syntax seems to preclude 'not' elsewhere!
	!,
	syntax2p_literal(L,Vars,lpsp2p,[T1,T2],ET,holds(NL,T)),
	check_time_var(T,Vars).
	% Should probably ...? \+ head_hint(L,l_timeless),
syntax2p_literal(LT,_Vars,lps2p,[T1,_T2],ET,holds(not(NL),T)) :- % not(fluent) at T is the preferred form, but 2 others avaialable
	( LT= (not(F) at T), ET=true ; LT= not(F at T), ET=true ; LT= not(F), head_hint(F,fluent), ET=false),
	!,
	NL=F,
	remember_fluent_hint(F),
	T1=T.	
syntax2p_literal(L,Vars,lpsp2p,[T1,_T2],true,holds(NL,T)) :- 
	nonvar(L),
	L=..LL, LL=[_,_|_], append(Tless,[T],LL), 
	is_time_var(Vars,T),
	\+ head_hint(L,l_timeless),
	!,
	NL=..Tless, T=T1.
syntax2p_literal(LT,_Vars,lps2p,[T1,_T2],true,holds(NL,T)) :- 
	nonvar(LT), LT = (F at T),
	!,
	NL=F, T=T1,
	remember_fluent_hint(F).
syntax2p_literal(F,_Vars,lps2p,[T1,_T2],false,holds(NL,T)) :- 
	nonvar(F), head_hint(F,fluent),
	!,
	NL=F, T=T1.
syntax2p_literal(L,Vars,lpsp2p,[T1,_T2],true,holds(NL,T)) :- 
	var(L),
	!,
	is_time_var(Vars,T), T=T1,
	NL=..NLL, append(NLL,[T],Tplus),
	L=..Tplus.
syntax2p_literal(L,_Vars,lps2p,[T1,_T2],true,holds(NL,T)) :- 
	var(L),
	!,
	L = (NL at T), T1=T. % ...thus ommitting "..at..." in fluents is not fully supported when reversing the transform
syntax2p_literal(L,_,_Translator,[_T1,_T2],false,L). % some timeless literal

check_time_var(V,Vars) :- is_time_var(Vars,V), !.
check_time_var(V,Vars) :-
	write('*** Warning: time variable in a time predicate should start with T:'), 
	\+ \+ (bindAllVars(Vars), writeln(V)).
	
% is_time_var(AllVars,Var)
% Accepting any Txxx variable as time variable
is_time_var([],_T) :-!, fail.
is_time_var([VV|_Vars], T) :- arg(2,VV,V), V==T, !,
	is_time_var(VV).
is_time_var([_VV|Vars], T) :- is_time_var(Vars, T).

is_time_var(VV) :- 
	arg(1,VV,Name), atom_codes(Name,Codes), 
	(append("T",Rest,Codes);append("_T",Rest,Codes)),
	!,
	(Rest=[] -> true ; 
		Rest=[C|_], 
		% T_... or T0/9...
		(C==95->true;C>=48,C=<57)
	).
	

% Declare here predicates you wish to keep unchanged accross the transform
% For some specific cases, predicate sort hints are remembered
% Most bodies left var, as we may want to use Prolog there, for some kind of "meta-level"
% Finally, we leave Wei syntax terms untouched when translating TO that syntax, so we can mixing them in
% do_not_transform_may_hint(Head,SyntaxName,ToWei,Body)
do_not_transform_may_hint(observe(Events,_),_,_,_) :-!, remember_hints(event,Events). 
do_not_transform_may_hint(fluent(F),_,_,_) :- !, remember_declarations(fluent,F).
do_not_transform_may_hint(event(E),_,_,_) :- !, remember_declarations(event,E).
do_not_transform_may_hint(action(A),_,_,_) :- !, remember_declarations(event,A).
do_not_transform_may_hint(initial_state(S),_,true,_) :- !, remember_hints(fluent,S).
do_not_transform_may_hint(l_int(_,_),_,true,_).
do_not_transform_may_hint(l_events(_,_),_,true,_).
do_not_transform_may_hint(l_timeless(_,_),_,true,_).
do_not_transform_may_hint(initiated(_,_,_),_,_,_).
do_not_transform_may_hint(terminated(_,_,_),_,_,_).
do_not_transform_may_hint(reactive_rule(_,_,_),_,true,_).
do_not_transform_may_hint(reactive_rule(_,_),_,true,_).
do_not_transform_may_hint(d_pre(_),_,true,_).
do_not_transform_may_hint(maxTime(_),lps2p,_,__).

% pretty printing for all syntaxes; although not doing anything specific to the new (lps2p translator) syntax
pretty_write(Term) :- pretty_write(Term,0,user_output).

pretty_write(Term,Stream) :- pretty_write(Term,0,Stream).

% pretty_write(Term,Indent,Stream)
pretty_write((if A then C priority P),I,S) :- !, 
	my_tab(S,I), write(S,'if '), writeln(S,A), 
	my_tab(S,I), write(S,'then '), writeln(S,''), 
	NI is I+4, pretty_write(C,NI,S), 
	write(S,'  priority '), write(S,P).
pretty_write((if A then C),I,S) :- !, 
	my_tab(S,I), write(S,'if '), writeln(S,A), 
	my_tab(S,I), write(S,'then '), writeln(S,''), 
	NI is I+4, pretty_write(C,NI,S).
pretty_write((H if B),I,S) :- !, 
	my_tab(S,I), write(S,H), writeln(S,' if'), 
	my_tab(S,I), NI is I+4, pretty_write(B,NI,S).
pretty_write((A--->C priority P),I,S) :- !, 
	my_tab(S,I), write(S,A), writeln(S,' --->'), 
	NI is I+4, pretty_write(C,NI,S),
	write(S,'  priority '), write(S,P).
pretty_write((A--->C),I,S) :- !, 
	my_tab(S,I), write(S,A), writeln(S,' --->'), NI is I+4, pretty_write(C,NI,S).
pretty_write(Declaration,I,S) :- Declaration=..[Op,C], member(Op,[false,initially,fluents,events,actions]), !,
	my_tab(S,I), write(S,Op), writeln(S,''), NI is I+4,
	pretty_write(C,NI,S).
pretty_write(PostCondition,I,S) :- 
	(
		PostCondition = (E terminates F :- C), Op=(terminates) ; 
		PostCondition = (E initiates F :- C), Op=(initiates) ;
		PostCondition = (E terminates F), C=true, Op=(terminates) ;
		PostCondition = (E initiates F), C=true, Op=(initiates)
	), !,
	my_tab(S,I), write(S,E), write(S,' '), 
	write(S,Op), write(S,' '), pretty_write((F:-C),I,S).
	

pretty_write((H:-true),I,S) :- !, pretty_write(H,I,S).
pretty_write((H:-B),I,S) :- !, 
	my_tab(S,I), write(S,H), writeln(S,' :-'), NI is I+4, pretty_write(B,NI,S).
pretty_write((G1,G2),I,S) :- !, 
	my_tab(S,I), write(S,G1), writeln(S,','), pretty_write(G2,I,S).
pretty_write(G,I,S) :- my_tab(S,I), write(S,G).

my_tab(_S,0) :- !.
my_tab(S,I) :- I>0, write(S,' '), NI is I-1, my_tab(S,NI).

% predicate_for(Term,Spec)
predicate_for(V,none) :- var(V), !.
predicate_for((H:-_),F/A) :- !, functor(H,F,A).
predicate_for(H,F/A) :- functor(H,F,A).

init_definition_newliner :- set_currently_defining(none).

set_currently_defining(P) :- 
	uretractall('_currenty__defining'(_)), uassert('_currenty__defining'(P)).
	
may_write_newline(Term,S) :- 
	predicate_for(Term,P), 
	( '_currenty__defining'(P) -> true ; set_currently_defining(P), writeln(S,'')).
