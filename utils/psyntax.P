/* 
** Author(s): Miguel Calejo
** Contact:   info@interprolog.com, http://interprolog.com
** Copyright (C) InterProlog Consulting / Renting Point - Serviços de Informática Lda., Portugal 2016
** Use and distribution, without any warranties, under the terms of the 
** Apache 2.0 License, readable in http://www.apache.org/licenses/LICENSE-2.0.html
*/

/* Implement a surface syntax closer to that used on papers (.LPSP extension), 
mapping both to/from "Wei syntax" (.P or .pl extension) as assumed in the engine .
The syntax is as follows:

Antecedent ---> Consequent.
Antecedent ---> Consequent priority P.
myEvent(X,T1,T2) :- 
   whatever(T1), blah(X), ev(T1,Tx),  tc(Tx>T1), anotherEvent(Tx,T2).
intensional(A,T) :- some_fluent(B,T), timelessP(A,B).
false :- pickup_forks(F1, philosopher(N), F2,T1,T2),   not available(F1,T1).
initiated available(F2) :- 
  putdown_forks(F1, philosopher(N), F2,T1,T2).
terminated available(F2) :- 
  putdown_forks(F1, philosopher(N), F2,T1,T2).

Time variables must start with T or _T, followed by _ or a digit.
Prolog facts in general are not transformed.
In particular, initial_state(FluentsList) and observe(EventsList,Time) should be present.

LIMITATION wrt time variable convention: 
If a l_timeless predicate has T variables, it's (reverse) conversion to our syntax will be wrong...
... because on a subsequent conversion (from ours to Wei's) that predicate will become a timefull predicate
Ditto for "timeful" predicates with non-T variables
--------------
ALSO...implements another, nicer syntax  (.LPS extension), 
mapping both to/from "Wei syntax" (.P or .pl extension) as assumed in the engine .
This syntax is as follows:

if Antecedent then Consequent.
if Antecedent then Consequent priority P.
myEvent(X) during [T1,T2] if 
   someFluent at T1, prolog_goal(X), ev during [T1,Tx],  tc(Tx>T1), anotherEvent during [Tx,T2].
intensional(A) at T :- some_fluent(B) at T, timelessP(A,B).
...myEvent1(X) : myFluent(X) : myEvent2(X)...  % implicit time arguments, all contiguous, same as:
%  ...myEvent1(X) during [T1,T2], myFluent(X) at T2, myEvent2(X) during [T2,T3]...
%  assuming these predicates to be time-dependent predicates already declared
initial_state1(foo) at 0.
initial_state2(bar) at 0.

false pickup_forks(F1, philosopher(N), F2), not available(F1). % same instant/interval

putdown_forks(F1, philosopher(N), F2) initiates available(F1). % if true.
putdown_forks(F1, philosopher(N), F2) terminates available(F1). % 
% later addition, to base Wei syntax: fluent list, easy to implement on interpreter

observations([event1(foo),event2(bar)],3).

end_of_time(10).

.... T1>T2 ... ----> tc(T1>T2) 

Time variables must appear in ...at T or during [T1,T2].
Prolog facts in general are not transformed.
*/

:- op(1200,xfx,--->). % for reactive rules
:- op(1190,xfx,priority). %... with priority
:- op(900,fy,terminated).
:- op(900,fy,initiated).

% New syntax .lps
:- op(1200,xfx,then).
:- op(1185,fx,if).
:- op(1200,xfx,if).
:- op(1050,fx,terminates).
:- op(1050,fx,initiates).
% Rejected:-( :- op(1050,fx,impossible). 
:- op(1050,fx,false).
:- op(995,xfx,at).
:- op(995,xfx,during).
:- op(1050,xfy,::).

:- export lpsp2p_file/2, lpsp2p/3, 
	lps2p_file/2, lps2p/3, syntax2p_file/4,
	gol/2, gol/1, golv/3, golv/2, golv/1.

:- import append/3, member/2 from basics.
:- import concat_atom/2 from string.
:- import file_read/3 from xsb_read.
:- import closetail/1 from listutil.

:- import go/3 from interpreter.
:- import gov/3 from visualizer.

:- consult:add_this_lib_dir.

% Convert a file in LPSP into Wei syntax and execute it 
gol(LPSP_file,Options,Results) :-
	concat_atom([LPSP_file,'_.P'],Pfile),
	syntax2p_file(LPSP_file,Pfile,lpsp2p,true),
	go(Pfile,Options,Results).

gol(LPSP_file,Options) :- gol(LPSP_file,Options,[]).

gol(LPSP_file) :- gol(LPSP_file,[]).

golv(LPSP_file) :- golv(LPSP_file,[]).

golv(LPSP_file,Options) :- golv(LPSP_file,Options,[]).

golv(LPSP_file,Options,Results) :-
	concat_atom([LPSP_file,'_.P'],Pfile),
	syntax2p_file(LPSP_file,Pfile,lpsp2p,true),
	gov(Pfile,Options,Results).

% lpsp2p_file(?LPSPfile,?LPSWfile) "papers syntax"
lpsp2p_file(LPSPfile,LPSWfile) :- atom(LPSPfile), !,
	(atom(LPSWfile)->true;concat_atom([LPSPfile,'_.lpsw'],LPSWfile)),
	syntax2p_file(LPSPfile,LPSWfile,lpsp2p,true).
lpsp2p_file(LPSPfile,LPSWfile) :- 
	atom(LPSWfile), 
	(atom(LPSPfile)->true;concat_atom([LPSWfile,'_.lpsp'],LPSPfile)),
	syntax2p_file(LPSPfile,LPSWfile,lpsp2p,false).

% lpsp2p_file(?LPSPfile,?LPSWfile) "new syntax", Nov 2016
lps2p_file(LPSPfile,LPSWfile) :- atom(LPSPfile), !,
	(atom(LPSWfile)->true;concat_atom([LPSPfile,'_.lpsw'],LPSWfile)),
	syntax2p_file(LPSPfile,LPSWfile,lps2p,true).
lps2p_file(LPSPfile,LPSWfile) :- 
	atom(LPSWfile), 
	(atom(LPSPfile)->true;concat_atom([LPSWfile,'_.lpsp'],LPSPfile)),
	syntax2p_file(LPSPfile,LPSWfile,lps2p,false).

		
% syntax2p_file(+LPSPfile,+Pfile,+Translator,+ToWei) Translator is a functor for a predicate Translate(Term,Vars,NewTerm)
% If ToWei==true it generates a .P file from the first file, else vice-versa
syntax2p_file(Lfile,Pfile,Translator,ToWei) :-
	( member(Translator,[lpsp2p,lps2p]) -> true 
		; write('*** Bad syntax translator: '), writeln(Translator), fail),
	init_definition_newliner,
	retractall(head_hint(_,_)),
	current_prolog_flag(write_depth,Old), set_xsb_flag(write_depth,10000),
	(ToWei==true -> 
		file_exists(Lfile), open(Lfile,read,IStr), open(Pfile,write,OStr), 
		Convert =.. [Translator,Term,Vars,NewTerm]
		; 
		file_exists(Pfile), open(Pfile,read,IStr), open(Lfile,write,OStr),
		Convert =.. [Translator,NewTerm,Vars,Term]
		),
	IStr >= 0, OStr>=0,
	repeat,
	catch(file_read(IStr,Term,Vars),_,true), closetail(Vars),
	( Term==end_of_file -> true
	;  
		Convert, 
		% When converting back to our syntax from Wei's, make sure T vars are not misinterpreted:
		% NO! Too strong
		% ((ToWei\==true, member(V,Vars), is_time_var(V)) -> true
		%	; 
		bindAllVars(Vars), 
		may_write_newline(NewTerm,OStr),
		pretty_write(NewTerm,OStr), writeln(OStr,'.'), 
		fail
	),
	!,
	close(OStr),close(IStr),
	set_xsb_flag(write_depth,Old).

% head_hint(HeadTemplate,Sort) Sort is currently l_timeless
%  a fact means that some head was read before tagged as Sort 
:- dynamic head_hint/2.
remember_hint(H) :- 
	functor(H,F,N), functor(HH,F,N),
	( head_hint(HH,l_timeless) ->  true; assert(head_hint(HH,l_timeless) )).

lpsp2p(LPSPterm,Vars,Pterm) :- syntax2p(LPSPterm,Vars,lpsp2p,Pterm).

lps2p(LPSPterm,Vars,Pterm) :- syntax2p(LPSPterm,Vars,lps2p,Pterm).

% syntax2p(?LPSPterm,+Vars,+Translator,?Pterm) 
% Vars is a (closed tail) list of some_functor(Name,Variable)
% Translator: see syntax2p_file/4
% Either LPSPterm or Pterm must be bound; the other should be unbound
% Probably needs to evolve to return error messages
syntax2p(L,_,TT,PT) :- var(L), var(PT), !, fail.
syntax2p((A--->C priority P),Vars,TT,reactive_rule(NA,NC,P)) :- !, 
	syntax2p_sequence(A,Vars,TTT,NA), syntax2p_sequence(C,Vars,TTTT,NC).
syntax2p((A--->C),Vars,TT,reactive_rule(NA,NC)) :- !, 
	syntax2p_sequence(A,Vars,TTT,NA), syntax2p_sequence(C,Vars,TTTT,NC).
syntax2p((H:-B),_,TT,PT) :- var(PT), (var(H);var(B)), !, fail.
syntax2p((H:-B),_,TT,(H:-B)) :- do_not_transform(H,TTT,B), !.
syntax2p(Fact,_,TT,Fact) :- do_not_transform(Fact,TTT,true), !.
syntax2p((false:-B),Vars,TT,d_pre(IC)) :- !, 
	syntax2p_sequence(B,Vars,TTT,IC).
syntax2p((IT:-B),Vars,TT,PT) :- % LPSP -> Wei term
	var(PT),
	IT=..[F,H], ((F==terminated) ; (F==initiated)), 
	!,
	syntax2p_sequence(B,Vars,TTT,[NB1|NBn]), % should be strictier wrt NB1 ?
	PT=..[F,NB1,H,NBn].
syntax2p(L,Vars,TT,PT) :- % LPSP <- Wei term
	var(L), PT=..[F,NB1,H,NBn], 
	((F==terminated) ; (F==initiated)), 
	!,
	LH=..[F,H], L = (LH:-B),
	syntax2p_sequence(B,Vars,TTT,[NB1|NBn]). % should be strictier wrt NB1 ?
syntax2p(L,Vars,TT,PT) :- 
	(var(PT) -> ToWei=true; ToWei=false),
	(L = (LH:-LB)->true;LH=L,LB=true), 
	(ToWei==true -> syntax2p_literal(LH,Vars,TTT,NH); true),
	( 
	PT = l_events(NH,NB), NH=happens(H,_,_) ;
	PT = l_int(NH,NB), NH = holds(H,_) ;
	% if a timeless head, remember that to override "time looks" in body if need be:
	PT = l_timeless(NH,NB), \+ (nonvar(NH), (NH = holds(_,_);NH = happens(_,_,_)) ), remember_hint(NH)
	),
	!,
	((ToWei==false) -> syntax2p_literal(LH,Vars,TTTT,NH) ; true),
	syntax2p_sequence(LB,Vars,TTTTT,NB).

syntax2p(Fact, _, TT, Fact). % pass through for Wei terms or other Prolog facts

syntax2p_sequence((L1,L2),Vars,Translator,[PT1|PT2]) :- PT2 \== [], !,
	syntax2p_literal(L1,Vars,Translator,PT1), syntax2p_sequence(L2,Vars,Translator,PT2).
syntax2p_sequence(true,_,TT,[]) :- !.
syntax2p_sequence(L,Vars,TT,[PT]) :- syntax2p_literal(L,Vars,TTT,PT).

syntax2p_literal(tc(TC),_Vars,TT,tc(TC)) :- !. %TODO: check Vars for (some) Ts!!!
syntax2p_literal(L,Vars,TT,happens(NL,T1,T2)) :- 
	nonvar(L),
	L=..LL, append(Tless,[T1,T2],LL),  Tless=[_|_], % last 2 args of term 
	is_time_var(Vars,T1), is_time_var(Vars,T2),	
	\+ head_hint(L,l_timeless),
	!,
	NL=..Tless.
syntax2p_literal(L,Vars,TT,happens(NL,T1,T2)) :- 
	var(L),
	!,
	NL=..NLL, append(NLL,[T1,T2],Tplus),  
	!,
	check_time_var(T1,Vars), check_time_var(T2,Vars),
	L=..Tplus.
syntax2p_literal(not(L),Vars,TT,holds(not(NL),T)) :- 
	% Wei syntax seems to preclude 'not' elsewhere!
	!,
	syntax2p_literal(L,Vars,TT,holds(NL,T)),
	check_time_var(T,Vars).
	% Should probably ...? \+ head_hint(L,l_timeless),
syntax2p_literal(L,Vars,TT,holds(NL,T)) :- 
	nonvar(L),
	L=..LL, LL=[_,_|_], append(Tless,[T],LL), 
	is_time_var(Vars,T),
	\+ head_hint(L,l_timeless),
	!,
	NL=..Tless.
syntax2p_literal(L,Vars,TT,holds(NL,T)) :- 
	var(L),
	!,
	is_time_var(Vars,T),
	NL=..NLL, append(NLL,[T],Tplus),
	L=..Tplus.
syntax2p_literal(L,_,TT,L). % some timeless literal

check_time_var(V,Vars) :- is_time_var(Vars,V), !.
check_time_var(V,Vars) :-
	write('*** Warning: time variable in a time predicate should start with T:'), 
	\+ \+ (bindAllVars(Vars), writeln(V)).
	
% is_time_var(AllVars,Var)
% Accepting any Txxx variable as time variable
is_time_var([],_T) :-!, fail.
is_time_var([VV|_Vars], T) :- arg(2,VV,V), V==T, !,
	is_time_var(VV).
is_time_var([_VV|Vars], T) :- is_time_var(Vars, T).

is_time_var(VV) :- 
	arg(1,VV,Name), atom_codes(Name,Codes), 
	(append("T",Rest,Codes);append("_T",Rest,Codes)),
	!,
	(Rest=[] -> true ; 
		Rest=[C|_], 
		% T_... or T0/9...
		(C==95->true;C>=48,C=<57)
	).
	
% also closes var tailed lists
bindAllVars([]) :- !.
bindAllVars([VV|Vars]) :- 
	arg(1,VV,Name), arg(2,VV,Value), 
	(var(Value) -> Value=Name ; true), bindAllVars(Vars).

% Declare here predicates you wish to keep unchanged accross the transform
do_not_transform(observe(_,_),TT,_). % to cater for observe/2 rules (in addition to facts)
do_not_transform(fluent(_),TT,_).
do_not_transform(event(_),TT,_).
do_not_transform(action(_),TT,_).
do_not_transform(initial_state(_),TT,_).
do_not_transform(l_int(_,_),TT,_).
do_not_transform(l_timeless(_,_),TT,_).

% pretty printing
pretty_write(Term,Stream) :- pretty_write(Term,0,Stream).

% pretty_write(Term,Indent,Stream)
pretty_write((A--->C priority P),I,S) :- !, 
	my_tab(S,I), write(S,A), writeln(S,' --->'), 
	NI is I+4, pretty_write(C,NI,S),
	write(S,'    priority '), write(S,P).
pretty_write((A--->C),I,S) :- !, 
	my_tab(S,I), write(S,A), writeln(S,' --->'), NI is I+4, pretty_write(C,NI,S).
pretty_write((H:-true),I,S) :- !, pretty_write(H,I,S).
pretty_write((H:-B),I,S) :- !, 
	my_tab(S,I), write(S,H), writeln(S,' :-'), NI is I+4, pretty_write(B,NI,S).
pretty_write((G1,G2),I,S) :- !, 
	my_tab(S,I), write(S,G1), writeln(S,','), pretty_write(G2,I,S).
pretty_write(G,I,S) :- my_tab(S,I), write(S,G).

my_tab(_S,0) :- !.
my_tab(S,I) :- I>0, write(S,' '), NI is I-1, my_tab(S,NI).

% predicate_for(Term,Spec)
predicate_for(V,none) :- var(V), !.
predicate_for((H:-_),F/A) :- !, functor(H,F,A).
predicate_for(H,F/A) :- functor(H,F,A).

:- dynamic '_currenty__defining'/1.

init_definition_newliner :- set_currently_defining(none).

set_currently_defining(P) :- 
	retractall('_currenty__defining'(_)), assert('_currenty__defining'(P)).
	
may_write_newline(Term,S) :- 
	predicate_for(Term,P), 
	( '_currenty__defining'(P) -> true ; set_currently_defining(P), writeln(S,'')).
