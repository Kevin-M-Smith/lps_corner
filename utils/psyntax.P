/* 
** Author(s): Miguel Calejo
** Contact:   info@interprolog.com, http://interprolog.com
** Copyright (C) InterProlog Consulting / Renting Point - Serviços de Informática Lda., Portugal 2016
** Use and distribution, without any warranties, under the terms of the 
** Apache 2.0 License, readable in http://www.apache.org/licenses/LICENSE-2.0.html
*/

/* Implement a surface syntax closer to that used on papers (.LPSP extension), 
mapping both to/from "Wei syntax" (.P or .pl extension) as assumed in the engine .
The syntax is as follows:

Antecedent ---> Consequent.
Antecedent ---> Consequent priority P.
myEvent(X,T1,T2) :- 
   whatever(T1), blah(X), ev(T1,Tx),  tc(Tx>T1), anotherEvent(Tx,T2).
intensional(A,T) :- some_fluent(B,T), timelessP(A,B).
false :- pickup_forks(F1, philosopher(N), F2,T1,T2),   not available(F1,T1).
initiated available(F2) :- 
  putdown_forks(F1, philosopher(N), F2,T1,T2).
terminated available(F2) :- 
  putdown_forks(F1, philosopher(N), F2,T1,T2).

Time variables must start with T or _T, followed by _ or a digit.
Prolog facts in general are not transformed.
In particular, initial_state(FluentsList) and observe(EventsList,Time) should be present.

IMPORTSNT LIMITATION wrt time variable convention: 
If a l_timeless predicate has T variables, it's (reverse) conversion to our syntax will be wrong...
... because on a subsequent conversion (from ours to Wei's) that predicate will become a timefull predicate
Ditto for "timeful" predicates with non-T variables
--------------
ALSO...implements another, nicer syntax  (.LPS extension), 
mapping both to/from "Wei syntax" (.P or .pl extension) as assumed in the engine .
This syntax is as follows:

if Antecedent then Consequent.
if Antecedent then Consequent priority P.
myEvent(X) during [T1,T2] if 
   someFluent at T1, prolog_goal(X), ev during [T1,Tx],  tc(Tx>T1), anotherEvent during [Tx,T2].
intensional(A) at T :- some_fluent(B) at T, timelessP(A,B).
...myEvent1(X) : myFluent(X) : myEvent2(X)...  % implicit time arguments, all contiguous, same as:
%  ...myEvent1(X) during [T1,T2], myFluent(X) at T2, myEvent2(X) during [T2,T3]...
%  assuming these predicates to be time-dependent predicates already declared
initial_state1(foo) at 0.
initial_state2(bar) at 0.

false pickup_forks(F1, philosopher(N), F2), not available(F1). % same instant/interval

putdown_forks(F1, philosopher(N), F2) initiates available(F1). % if true.
putdown_forks(F1, philosopher(N), F2) terminates available(F1). % 
% later addition, to base Wei syntax: fluent list, easy to implement on interpreter

observe([event1(foo),event2(bar)],3).

maxTime(10).

.... T1>T2 ... ----> tc(T1>T2) 

Prolog facts in general are not transformed.
*/

:- module(psyntax,[ syntax2p/4, lpsp2p_file/2, lpsp2p/3, 
	lps2p_file/2, lps2p/3, syntax2p_file/4, syntax2p/4,
	gol/2, gol/1, golps/2, golps/1,
	may_clear_hints/0,term_colours/2,timeless_ref/1, set_top_term/1]).

%%% XSB specific section:
:- if(current_prolog_flag(dialect, xsb)).

:- use_module(interpreter,[go/3,uassert/1, uretractall/1, collect_guessed_declarations/1,bindAllVars/1,intensional/1,macroaction/1]). % assumed preloaded
:- use_module(db,[head_hint/3, '_currenty__defining'/1]).
:- use_module(basics, [member/2, append/3]).
:- use_module(string,[concat_atom/2]).
:- consult:add_this_lib_dir. % is this needed??
:- use_module(xsb_read,[ file_read/3]).
:- use_module(subsumes,[variant/2]).

my_file_read(Stream,Term,Vars) :- file_read(Stream,Term,Vars).

% New syntax .lps
:- op(1200,xfx,then).
:- op(1185,fx,if).
:- op(1200,xfx,if).
:- op(1050,xfx,(terminates)).
:- op(1050,xfx,(initiates)).
% Rejected:-( :- op(1050,fx,impossible). 
:- op(1050,fx,observe).
:- op(1050,fx,false).
:- op(1050,fx,initially).
:- op(1050,fx,fluents).
:- op(1050,fx,events).
:- op(1050,fx,actions).
:- op(995,xfx,at).
:- op(995,xfx,during).
:- op(995,xfx,from). % Already defined in XSB with higher priority... so parenthesis needed e.g. (event 1 from 1 to 2), event 2 to 3
:- op(994,xfx,to). % from's priority higher
:- op(1050,xfy,::).

% older syntax lpsp2p:
:- op(1200,xfx,--->). % for reactive rules
:- op(1190,xfx,priority). %... with priority
:- op(900,fy,terminated).
:- op(900,fy,initiated).

may_clear_hints :- throw(only_for_swi).

% hook into test suite runner:
:- multifile interpreter:regenerate_file/1.
% regenerate_file(F) F is an existing Wei syntax file that needs to be regenerated...if a source file for it can be found
regenerate_file(F) :- generate_file(F), !.

clear_head_hint(HH,Type,X) :- uretractall(head_hint(HH,Type,X)).
add_head_hint(HH,Type,X) :- uassert(head_hint(HH,Type,X)).

% SWI only:
clear_timeless_refs. 
may_add_timeless_ref(_).
set_top_term(_).
:- dynamic timeless_ref/1, current_top_term/1. % dummy declaration to please XSB's compiler

:- endif.

%%% end of XSB specific section; now for SWI:

:- if((current_prolog_flag(dialect, swi), current_module(swish))). 
% first, SWISH specific; see comments in interpreter.P

:- use_module(library(pengines),[pengine_self/1]).
:- use_module(library(prolog_clause),[clause_info/5]).

:- use_module(library(pengines),[pengine_self/1]).
dumploaded :- 
	pengine_self(M), current_predicate(M:F/N), functor(H,F,N), 
	clause(M:H,Body,_Ref), 
	% clause_property(Ref,line_count(LineNumber)), clause_property(Ref,file(File)),
	% clause_info(Ref, _File, _TermPos, _VarOffsets, [variable_names(_Vars)]), % this effectively filters out swish predicates
	interpreter:lps_source_position(H,_,_,Vars), bindAllVars(Vars),
	% term_variables((H:-Body),VarValues),    _Vars: [Name1=VarValue1,...]
	%_TermPos = term_position(Char,CharEnd,_,_,_),
	%print_message(error,error(syntax_error(whatever),file(File,LineNumber,_one,_Char))),
	pretty_write((H:-Body)), writeln('.'),
	%write('  '), writeln(File), % e.g. pengine://fa945952-355c-47a3-bb48-bdf8dfdb4229/src
	%write('  '), writeln(TermPos/Vars), % e.g. term_position(384,446,416,420,[term_position(.... ])/[N=_1022]
	fail.
dumploaded.

:- endif.

:- if((current_prolog_flag(dialect, swi), \+ current_module(swish))).
% Now support for vanilla/barebones SWI Prolog:

:- endif.

:- if(current_prolog_flag(dialect, swi)).
% ...and finally the generic SWI support:

:- thread_local((head_hint/3, '_currenty__defining'/1)).
clear_head_hint(HH,Type,X) :- retractall(head_hint(HH,Type,X)).
add_head_hint(HH,Type,X) :- assert(head_hint(HH,Type,X)).

:- thread_local((timeless_ref/1, current_top_term/1)).
clear_timeless_refs :- retractall(timeless_ref(_)).

may_add_timeless_ref(G) :- 
	functor(G,F,N), ( current_top_term(F/N); timeless_ref(F/N) ; assert(timeless_ref(F/N))), !.

set_top_term(T) :- retractall(current_top_term(_)), (var(T)->F=var, N = -1 ; functor(T,F,N)), assert(current_top_term(F/N)).


:- use_module('../engine/interpreter.P',[go/3,uassert/1, uretractall/1, collect_guessed_declarations/1,bindAllVars/1,intensional/1,macroaction/1]).
:- use_module(library(dialect/sicstus/system),[file_exists/1]).
my_file_read(Stream,Term,Vars) :- read_term(Stream,Term,[variable_names(Vars)]).

% New syntax .lps
:- op(900,fy,user:(not)). 
:- op(1200,xfx,user:(then)).
:- op(1185,fx,user:(if)).
:- op(1200,xfx,user:(if)).
:- op(1050,xfx,user:(terminates)).
:- op(1050,xfx,user:(initiates)).
% Rejected:-( :- op(1050,fx,impossible). 
:- op(1050,fx,user:(observe)).
:- op(1050,fx,user:(false)).
:- op(1050,fx,user:initially).
:- op(1050,fx,user:fluents).
:- op(1050,fx,user:events).
:- op(1050,fx,user:actions).
:- op(995,xfx,user:(at)).
:- op(995,xfx,user:(during)).
:- op(995,xfx,user:from). 
:- op(994,xfx,user:to). % from's priority higher
:- op(1050,xfy,user:(::)).
% older syntax lpsp2p:
:- op(1200,xfx,--->). % for reactive rules
:- op(1190,xfx,priority). %... with priority
:- op(900,fy,terminated).
:- op(900,fy,initiated).


% This colours lps2p terms, articulated with SWI's prolog_colour.pl
term_colours(T,C) :- 
	may_clear_hints,  
	syntax2p(T,[],lps2p,NiceC,_Pterm), NiceC \== null, 
	!, 
	NiceC=C.
	

% Resets the psyntax context when using a different thread, e.g. a different file tokenization
% Controlling this elsewhere (e.g. hooking into either xref_open_source/close_source, swish_highlight:server_tokens) does not work
may_clear_hints :- thread_self(T), expanding_in_thread(T,_), !.
may_clear_hints :- % garbage collect after 5 minutes:
	get_time(Now), expanding_in_thread(_,Then), Now>Then+300, retract(expanding_in_thread(_,Then)), fail.
may_clear_hints :- thread_self(T), get_time(Now), assert(expanding_in_thread(T,Now)), clear_hints.
% ASSUMES that thread ids are unique!!
:- dynamic expanding_in_thread/2. % thread, timestamp

% hook into test suite runner:
:- multifile interpreter:regenerate_file/1.
% regenerate_file(F) F is an existing Wei syntax file that needs to be regenerated...if a source file for it can be found
interpreter:regenerate_file(F) :- generate_file(F), !.

:- endif.

%%% From here on, generic Prolog code

closetail([]) :- !.
closetail([_|L]) :- closetail(L).

% comma_to_list(?NiceSyntax,+Syntaxclass,-Spec,?List). SyntaxClass and Spec as per SWI's Prolog_colour.pl
comma_to_list(NS,_,_,L) :- var(NS), var(L), !, writeln('*** Bad var item'), fail.
comma_to_list((One,Two),SC,delimiter-[SpecOne,SpecTwo],[One|Twol]):- Twol \== [], !,
	spec_for_one(One,SC,SpecOne),
	comma_to_list(Two,SC,SpecTwo,Twol).
comma_to_list(One,SC,SpecOne,[One]) :- spec_for_one(One,SC,SpecOne).

% spec_for_one(+NiceItem,+SyntaxClass,-ItemColourSpec)
spec_for_one(_/_,SC,delimiter-[SC,classify]) :- !.
spec_for_one(One,SC,SC) :- atom(One), !.
spec_for_one(_One,SC,SC-classify).

% functor_arityze(TemplatesOrFA,TemplatesList) replaces term functor/arities by their templates; 
% bidirectional (albeit losing information of course)
functor_arityze([F/A|TOFAL],[G|FAL]) :- functor(G,F,A), !, functor_arityze(TOFAL,FAL).
functor_arityze([T|TOFAL],[T|FAL]) :- !, functor_arityze(TOFAL,FAL).
functor_arityze([],[]).

% Convert a file in LPSP into Wei syntax and execute it 
gol(LPSP_file,Options,Results) :-
	concat_atom([LPSP_file,'_.P'],Pfile),
	syntax2p_file(LPSP_file,Pfile,lpsp2p,true),
	go(Pfile,Options,Results).

gol(LPSP_file,Options) :- gol(LPSP_file,Options,[]).

gol(LPSP_file) :- gol(LPSP_file,[]).

% Convert a file in LPS (new syntax) into Wei syntax and execute it 
golps(LPSP_file,Options,Results) :-
	concat_atom([LPSP_file,'_.P'],Pfile),
	syntax2p_file(LPSP_file,Pfile,lps2p,true),
	go(Pfile,Options,Results).

golps(LPSP_file,Options) :- golps(LPSP_file,Options,[]).

golps(LPSP_file) :- golps(LPSP_file,[]).
	
% File converters:

% Fails if no source file exists
% [46,108,112,115,119] .lpsw
% [95,46,80] _.P
% [46,108,112,115] .lps
% generate_file(FilenameCodes)
generate_file(Fcodes) :- 
	% _.P or .lpsw?
	(append(SourceCodes,[95,46,80],Fcodes) ; append(SourceCodes,[46,108,112,115,119],Fcodes)),
	!,
	(append(_,[46,108,112,115],SourceCodes) ; append(_,[46,112,108],SourceCodes)), % a LPS or pl file
	atom_codes(Source,SourceCodes),
	file_exists(Source),
	atom_codes(F,Fcodes),
	syntax2p_file(Source,F,lps2p,true).


% lpsp2p_file(?LPSPfile,?LPSWfile) "papers syntax"
lpsp2p_file(LPSPfile,LPSWfile) :- atom(LPSPfile), !,
	(atom(LPSWfile)->true;concat_atom([LPSPfile,'_.lpsw'],LPSWfile)),
	syntax2p_file(LPSPfile,LPSWfile,lpsp2p,true).
lpsp2p_file(LPSPfile,LPSWfile) :- 
	atom(LPSWfile), 
	(atom(LPSPfile)->true;concat_atom([LPSWfile,'_.lpsp'],LPSPfile)),
	syntax2p_file(LPSPfile,LPSWfile,lpsp2p,false).

% lps2p_file(?LPSfile,?LPSWfile) "new syntax", Nov-Dec 2016
lps2p_file(LPSfile,LPSWfile) :- atom(LPSfile), !,
	(atom(LPSWfile)->true;concat_atom([LPSfile,'_.lpsw'],LPSWfile)),
	syntax2p_file(LPSfile,LPSWfile,lps2p,true).
lps2p_file(LPSfile,LPSWfile) :- 
	atom(LPSWfile), 
	(atom(LPSfile)->true;concat_atom([LPSWfile,'_.lps'],LPSfile)),
	syntax2p_file(LPSfile,LPSWfile,lps2p,false).


% Main file to file syntax converter
% syntax2p_file(+OtherSyntaxFile,+P_Wei_file,+Translator,+ToWei) Translator is a functor for a predicate Translate(Term,Vars,NewTerm)
% If ToWei==true it generates a .P file from the first file, else vice-versa
syntax2p_file(Lfile,Pfile,Translator,ToWei) :-
	( member(Translator,[lpsp2p,lps2p]) -> true 
		; write('*** Bad syntax translator: '), writeln(Translator), fail),
	init_definition_newliner,
	clear_hints, clear_timeless_refs,
	( current_prolog_flag(write_depth,Old) -> set_xsb_flag(write_depth,10000) ; true), % XSB specific, ignore otherwise
	(ToWei==true -> 
		file_exists(Lfile), open(Lfile,read,IStr), open(Pfile,write,OStr), 
		Convert =.. [Translator,Term,Vars,NewTerm]
		; 
		file_exists(Pfile), open(Pfile,read,IStr), open(Lfile,write,OStr),
		Convert =.. [Translator,NewTerm,Vars,Term]
		),
	% IStr >= 0, OStr>=0,
	nonvar(IStr), nonvar(OStr),
	repeat,
	catch(my_file_read(IStr,Term,Vars),Ex,writeln(ex-Ex)), closetail(Vars),
	( Term==end_of_file -> true
	;  
		set_top_term(Term),
		(Convert->true; write('*** failed '), writeln(Convert), fail), 
		% When converting back to our syntax from Wei's, make sure T vars are not misinterpreted:
		% NO! Too strong
		% ((ToWei\==true, member(V,Vars), is_time_var(V)) -> true
		%	; 
		bindAllVars(Vars), 
		may_write_newline(NewTerm,OStr),
		pretty_write(NewTerm,OStr), writeln(OStr,'.'), 
		fail
	),
	!,
	(ToWei==true ->
		% may generate missing declarations
		collect_guessed_declarations(Facts),
		forall( 
			member(Fact,Facts), 
			(may_write_newline(Fact,OStr), pretty_write(Fact,OStr), writeln(OStr,'.'))
			)
	; true),
	close(OStr),close(IStr),
	(nonvar(Old)->set_xsb_flag(write_depth,Old);true).


% head_hint(HeadTemplate,Sort,Declared) Sort maybe l_timeless,event,fluent
%  a fact means that some head was read before and tagged as Sort
%  used only when transforming from some nicer to Wei syntax 
%  Declared is 'true' if a declaration (not just usage) was detected
head_hint(X,Sort) :- head_hint(X,Sort,_), !.
head_hint(X,fluent) :- intensional(X).
head_hint(X,event) :- macroaction(X).
	
remember_hint(Type,H) :- 
	nonvar(Type), nonvar(H),
	member(Type,[fluent,event,action,timeless]),
	functor(H,F,N), functor(HH,F,N),
	( head_hint(HH,Type,_) ->  true; add_head_hint(HH,Type,false) ).

remember_timeless_hint(TL) :- remember_hint(timeless,TL).

remember_event_hint((E from _T1 to _T2)) :- !, remember_event_hint(E).
remember_event_hint((E during _Interval)) :- !, remember_event_hint(E).
remember_event_hint(TL) :- remember_hint(event,TL).

% Do we need events and actions??
%remember_action_hint((E during _Interval)) :- !, remember_action_hint(E).
%remember_action_hint(TL) :- remember_hint(action,TL).

remember_fluent_hint((F at _T)) :- !, remember_fluent_hint(F).
remember_fluent_hint(TL) :- remember_hint(fluent,TL).

remember_declaration(Type,H) :- 
	nonvar(Type), nonvar(H),
	member(Type,[fluent,event,action,timeless]),
	functor(H,F,N), functor(HH,F,N),
	( head_hint(HH,Type,true) ->  true; clear_head_hint(HH,Type,_), add_head_hint(HH,Type,true) ).
	
% remember_hints(Type,LiteralOrList)
remember_hints(_Type,X) :- var(X), ! . %, !, write('*** Underspecified term of sort '), writeln(Type).
remember_hints(_Type,[]) :- !.
remember_hints(Type,[X1|Xn]) :- !, remember_hint(Type,X1), remember_hints(Type,Xn).
remember_hints(Type,X) :- remember_hint(Type,X).

% remember_declarations(Type,LiteralOrList)
remember_declarations(Type,X) :- var(X), !, write('*** Underspecified declared term of sort '), writeln(Type).
remember_declarations(_Type,[]) :- !.
remember_declarations(Type,[X1|Xn]) :- !, remember_declaration(Type,X1), remember_declarations(Type,Xn).
remember_declarations(Type,X) :- remember_declaration(Type,X).

clear_hints :- clear_head_hint(_,_,_).
	
% convenience predicates for environment syntax checkers:
lpsp2p(LPSPterm,Vars,Pterm) :- syntax2p(LPSPterm,Vars,lpsp2p,Pterm).
lps2p(LPSPterm,Vars,Pterm) :- syntax2p(LPSPterm,Vars,lps2p,Pterm).

% Main term syntax converter
syntax2p(NicerSyntaxTerm,Vars,Translator,Pterm) :- 
	syntax2p(NicerSyntaxTerm,Vars,Translator,_NiceColouring,Pterm).

% syntax2p(?NicerSyntaxTerm,+Vars,+Translator,NiceColouring,?Pterm) 
% Vars is a (closed tail) list of some_functor(Name,Variable)
% Translator: lpsp2p ("papers syntax") or lps2p ("new syntax"); 
% Either NicerSyntaxTerm or Pterm must be bound; the other should be unbound
% NiceColouring is a colouring specificatin term as per SWI's prolog_colouring.pl, for the NicerSyntaxTerm
%   null if undefined colouring, e.g. for timeless/Prolog literals (they'll be coloured elsewhere in SWI)
%   needs to be defined only for nonvar(NicerSyntaxTerm)
% Probably needs to evolve to return error messages
syntax2p(L,_,_TT,_,PT) :- var(L), var(PT), !, fail.
% convenience notation for declarations:
syntax2p((initially States),_Vars,lps2p, lps_delimiter - [Specs] , initial_state(StatesList)) :- !, 
% syntax2p((initially States),_Vars,lps2p, null , initial_state(StatesList)) :- !, 
	comma_to_list(States,fluent,Specs,StatesList).
% observe o1, o2, o3 from ... to ...:
syntax2p((observe Obs),_Vars,lps2p,lps_delimiter - [Specs],observe([O1,O2|On],T2)) :- (nonvar(Obs)-> functor(Obs,',',2) ; true), !,
	((syntax2p_observations(Obs,CT2,[O1,O2|On],T2,Specs), T2=CT2, nonvar(T2)) -> true
		% cannot use comma_to_list, which assumes DECLARATIONS, e.g. NOT usage with time variables and their auxiliary functors
	; writeln('*** Bad observations'), writeln((observe Obs)/observe([O1,O2|On],T2)), fail). 
	% TODO: use print_message, etc.
	
% single observations, declared as fact declarations; observations list case handled further below
syntax2p((observe E from T1 to T2),_Vars,lps2p, lps_delimiter - [SpecHead], observe([E],T2)) :- !, 
	syntax2p_literal((E from T1 to T2),[],lps2p,_,_,SpecHead,_).
syntax2p((observe E to T2),_Vars,lps2p, lps_delimiter - [SpecHead],observe([E],T2)) :- !,
	syntax2p_literal((E to T2),[],lps2p,_,_,SpecHead,_).
syntax2p((actions A),_Vars,lps2p,lps_delimiter - [Specs],actions(NL)) :- nonvar(A), !, comma_to_list(A,event,Specs,L), functor_arityze(L,NL), remember_declarations(event,NL).
syntax2p((actions A),_Vars,lps2p,lps_delimiter - [Specs],actions(L)) :- !, comma_to_list(A,event,Specs,L).
syntax2p((events A),_Vars,lps2p,lps_delimiter - [Specs],events(NL)) :- nonvar(A), !, comma_to_list(A,event,Specs,L), functor_arityze(L,NL), remember_declarations(event,NL).
syntax2p((events A),_Vars,lps2p,lps_delimiter - [Specs],events(L)) :- !, comma_to_list(A,event,Specs,L).
syntax2p((fluents A),_Vars,lps2p,lps_delimiter - [Specs],fluents(NL)) :- nonvar(A), !, comma_to_list(A,fluent,Specs,L), functor_arityze(L,NL), remember_declarations(fluent,NL).
syntax2p((fluents A),_Vars,lps2p,lps_delimiter - [Specs],fluents(L)) :- !, comma_to_list(A,fluent,Specs,L).
% reactive rules:
syntax2p((if A then C priority P), Vars,TT, null,reactive_rule(NA,NC,P)) :- TT=lps2p, !, % TODO: should add T3>=T1?? interpreter enforced?
	syntax2p_sequence(A,Vars,TT,[_T1,_T2],_,NA), syntax2p_sequence(C,Vars,TT,[_T3,_T4],_,NC).
syntax2p((A--->C priority P), Vars,TT, null,reactive_rule(NA,NC,P)) :- TT=lpsp2p, !, 
	syntax2p_sequence(A,Vars,TT,[_T1,_T2],_,NA), syntax2p_sequence(C,Vars,TT,[_T3,_T4],_,NC).
syntax2p((if A then C), Vars,TT, lps_delimiter-[lps_delimiter-SpecA,SpecC],reactive_rule(NA,NC)) :- TT=lps2p, !, 
	syntax2p_sequence(A,Vars,TT,[_T1,_T2],SpecA,NA), syntax2p_sequence(C,Vars,TT,[_T3,_T4],SpecC,NC).
syntax2p((A--->C),Vars,TT,null,reactive_rule(NA,NC)) :- TT=lpsp2p, !, 
	syntax2p_sequence(A,Vars,TT,[_T1,_T2],_,NA), syntax2p_sequence(C,Vars,TT,[_T3,_T4],_,NC).
% pre-conditions:
syntax2p((false B),Vars,lps2p,lps_delimiter-[SpecB],d_pre(IC)) :- !, 
	syntax2p_sequence(B,Vars,lps2p,[_T1,_T2],single,_ET,SpecB,IC).
syntax2p(((false):-B),Vars,lpsp2p,null,d_pre(IC)) :- !, 
	syntax2p_sequence(B,Vars,lpsp2p,[_T1,_T2],single,_ET,_,IC).
% now post-conditions:	
syntax2p((IT:-B),Vars,lpsp2p,null,PT) :- % LPSP -> Wei term
	var(PT),
	IT=..[F,H], ((F==terminated) ; (F==initiated)), 
	!,
	syntax2p_sequence(B,Vars,lpsp2p,[_T1,_T2],single,_ET,_,[NB1|NBn]), % should be strictier wrt NB1 ?
	PT=..[F,NB1,H,NBn].
syntax2p((H if B),Vars,lps2p,lps_delimiter-[lps_delimiter-[EC,FC],SpecB],PT) :- % 
	var(PT),
	( H= (Event initiates Fluent), PT=initiated(NB1,Fluent,NBn) ; H= (Event terminates Fluent), PT=terminated(NB1,Fluent,NBn)),
	!,
	remember_fluent_hint(Fluent), remember_event_hint(Event),
	simple_event_colour(Event,EC), simple_fluent_colour(Fluent,FC),
	syntax2p_sequence((Event,B),Vars,lps2p,[_T1,_T2],single,_ET,Spec,[NB1|NBn]),
	Spec = delimiter - [_,SpecB]. % hack to avoid recalling the previous
syntax2p(H,Vars,lps2p,lps_delimiter-[SpecE,FC],PT) :- % 
	var(PT),
	( H= (Event initiates Fluent), PT=initiated(NB1,Fluent,NBn) ; H= (Event terminates Fluent), PT=terminated(NB1,Fluent,NBn)),
	!,
	remember_fluent_hint(Fluent),
	simple_fluent_colour(Fluent,FC),
	syntax2p_sequence(Event,Vars,lps2p,[_T1,_T2],single,_ET,SpecE,[NB1|NBn]).
syntax2p(L,Vars,lpsp2p,null,PT) :- % LPSP <- Wei term
	var(L), PT=..[F,NB1,H,NBn], 
	((F==terminated) ; (F==initiated)), 
	!,
	LH=..[F,H], L = (LH:-B),
	syntax2p_sequence(B,Vars,lpsp2p,[_T1,_T2],single,_ET,_,[NB1|NBn]). % should be strictier wrt NB1 ?
syntax2p(L,Vars,lps2p,null,PT) :-
	var(L), PT=..[F,NB1,Fluent,NBn], 
	((F==terminated), L_ = (Event terminates Fluent) ; (F==initiated), L_ = (Event initiates Fluent)), 
	!,
	syntax2p_sequence(Conditions,Vars,lps2p,[_T1,_T2],single,_ET,_,[NB1|NBn]),
	(Conditions = (Event,Body) -> L = (L_ if Body) ; L = L_, Conditions=Event).
% intentional fluents and composite events, and more
syntax2p((Head if Body),Vars,lps2p,lps_delimiter-[SpecHead,SpecBody],PT) :-
	(var(PT) -> ToWei=true; ToWei=false),
	(ToWei==true -> syntax2p_literal(Head,Vars,lps2p,[T1,T2],_,SpecHead,NH); true),
	( 
		PT = l_events(NH,NB), NH=happens(_,_,_);
		PT = l_int(NH,NB), NH = holds(_,_)
	),
	!,
	(PT=l_int(_,_) -> IntervalType=single ; IntervalType = _),
	((ToWei==false) -> syntax2p_literal(Head,Vars,lps2p,[T1,T2],_,_,NH) ; true),
	syntax2p_sequence(Body,Vars,lps2p,[T1,T2],IntervalType,_ET,SpecBody,NB).
syntax2p((H:-B),_,_TT,null,PT) :- var(PT), (var(H);var(B)), !, fail.
syntax2p(NT,_,TT,Spec,(H:-B)) :- 
	(nonvar(NT)->ToWei=true;ToWei=false),
	NT = (H:-B),
	do_not_transform_may_hint(H,TT,ToWei,B,Spec), !.
syntax2p(NT,_,TT,Spec,Fact) :- 
	(nonvar(NT)->ToWei=true;ToWei=false),
	NT=Fact,
	do_not_transform_may_hint(NT,TT,ToWei,true,Spec), !.
% time-dependent facts:
syntax2p(Head,Vars,lps2p,Spec,l_int(WHead,[])) :-
	syntax2p_literal(Head,Vars,lps2p,[_T1,_T2],_,Spec,WHead), WHead = holds(_,_),
	!.
syntax2p(Head,Vars,lps2p,Spec,l_events(WHead,[])) :-
	syntax2p_literal(Head,Vars,lps2p,[_T1,_T2],_,Spec,WHead), WHead = happens(_,_,_),
	!.
syntax2p(L,Vars,lpsp2p,null,PT) :- 
	(var(PT) -> ToWei=true; ToWei=false),
	(L = (LH:-LB)->true;LH=L,LB=true), 
	(ToWei==true -> syntax2p_literal(LH,Vars,Translator,[T1,T2],_,_,NH); true),
	( 
		PT = l_events(NH,NB), NH=happens(_,_,_) ;
		PT = l_int(NH,NB), NH = holds(_,_) ;
		% if a timeless head, remember that to override "time looks" in body if need be:
		PT = l_timeless(NH,NB), \+ (nonvar(NH), (NH = holds(_,_);NH = happens(_,_,_)) ), remember_timeless_hint(NH)
	),
	!,
	((ToWei==false) -> syntax2p_literal(LH,Vars,Translator,[T1,T2],_,_,NH) ; true),
	syntax2p_sequence(LB,Vars,Translator,[T1,T2],_,NB).
syntax2p(Term, _, _Translator, classify,Term).  % pass through for Wei terms or other Prolog facts

% syntax2p_observations(ObsCommaList,CommaT2,ObsList,ListT2,-ColourSpec) CommaT2 must be unique
syntax2p_observations(CL,CommaT2,[E],CommonT2,Spec) :- (nonvar(CL)-> \+ functor(CL,',',2) ; true), !, 
	syntax2p_one_obsservation(CL,CommaT2,E,CommonT2,Spec).
syntax2p_observations((Ob,CL),CommaT2,[E|L],CommonT2,delimiter-[Spec1,Specs]) :- (nonvar(CL)-> \+ functor(CL,',',2) ; true), !, 
	syntax2p_one_obsservation(Ob,CommaT2,E,CommonT2,Spec1),
	syntax2p_observations(CL,CommaT2,L,CommonT2,Specs).

syntax2p_one_obsservation((E from _ to CT2),T2,E,LT2,delimiter-[EC,classify]) :- !, CT2=T2,CT2=LT2, simple_event_colour(E,EC).
syntax2p_one_obsservation((E to CT2),T2,E,LT2,delimiter-[EC,classify]) :- !, T2=CT2,CT2=LT2, simple_event_colour(E,EC).
syntax2p_one_obsservation(E,T2,E,T2,EC) :- simple_event_colour(E,EC). 
	% assume T2 defined by another observation

simple_event_colour(E,EC) :- atom(E) -> EC = event ; EC = event-classify.
simple_fluent_colour(E,EC) :- atom(E) -> EC = fluent ; EC = fluent-classify.

% syntax2p_sequence(NicerSequence,Vars,Translator,[Start,End],NiceColouring,WeiPsequence)  [Start,End] may constrain time arguments
syntax2p_sequence(NS,Vars,Translator,Interval,NC,W) :-
	syntax2p_sequence(NS,Vars,Translator,Interval,_IT,_ET,NC,W).

% syntax2p_sequence(NS,Vars,Translator,[T1,T6],IntervalType,ExplicitTime,NiceColouring,W)  if  IntervalType==single, T6 must be T1+1
syntax2p_sequence((L1,L2),Vars,Translator,[T1,T6],IT, ET, delimiter-[Spec1,Spec2],[PT1|PT2]) :- PT2 \== [], !,
	syntax2p_literal(L1,Vars,Translator,[T2,T3], ETL, Spec1, PT1), 
	syntax2p_sequence(L2,Vars,Translator,[T4,T5],IT,ETS,Spec2, PT2),
	% if no explicit time arguments, the literals are assumed in timely sequence with neighbors
	 % 'single' too strict, should probably reflect into a tc(...) ???
	( (ETL == (false), ETS == (false)) -> ET= (false) ; ET = true),
	(IT==single -> T1=T4,T3=T6; ( (ETL == (false), ETS == (false)) -> T4=T3 ; true)),
	T1=T2, T6=T5.
syntax2p_sequence(true,_,_TT,[_T1,_T2],_,false,classify,[]) :- !.
syntax2p_sequence(L,Vars,Translator,Interval,_,ET,Spec,[PT]) :- syntax2p_literal(L,Vars,Translator,Interval,ET,Spec,PT).

% syntax2p_literal(NicerLiteral,+Vars,+Translator,[T1,T2],-ExplicitTime,-NiceColouring,WeiLiteral)
%  for events, [T1,T2] is their interval; for fluents, T1 is the time
% ExplicitTime == true if the given literal has explicit time arguments, false otherwise
syntax2p_literal(tc(TC),_Vars,lpsp2p,[_T1,_T2],true,null,tc(TC)) :- !. % no tc(_) allowed in new syntax... lpsp2p TODO: check Vars for (some) Ts

% event cases first...
syntax2p_literal(L,Vars,lpsp2p,[T1,T2],true,null,happens(NL,T1,T2)) :- 
	nonvar(L),
	L=..LL, append(Tless,[T1,T2],LL),  Tless=[_|_], % last 2 args of term 
	is_time_var(Vars,T1), is_time_var(Vars,T2),	
	\+ head_hint(L,l_timeless),
	!,
	NL=..Tless.
syntax2p_literal(LT,_Vars,lps2p,[T1,T2],true,delimiter-[EC,classify],happens(NL,T1,T2)) :- 
	nonvar(LT), 
	% tricky handling to avoid infinite terms in the first branch:
	( LT = (L from T1_), (var(T1_);number(T1_)); LT = (L to T2); LT = (L from T1 to T2) ; LT = (L during [T1,T2])),
	!,
	simple_event_colour(L,EC),
	remember_event_hint(L),
	NL=L.
syntax2p_literal(LT,_Vars,lps2p,[T1,T2],false,EC,happens(NL,T1,T2)) :- 
	nonvar(LT), head_hint(LT,event),
	!,
	simple_event_colour(LT,EC),
	NL=LT.
syntax2p_literal(L,Vars,lpsp2p,[T1,T2],true,null,happens(NL,T1,T2)) :- 
	var(L),
	!,
	NL=..NLL, append(NLL,[T1,T2],Tplus),  
	!,
	check_time_var(T1,Vars), check_time_var(T2,Vars),
	L=..Tplus.
syntax2p_literal(L,_Vars,lps2p,[T1,T2],true,null,happens(NL,T1,T2)) :- 
	var(L),
	!,
	% L = (NL during [T1,T2]). % ...thus ommitting "..during..." in events is not fully supported when reversing the transform
	L = (NL from T1 to T2). % ...thus ommitting "..during..." in events is not fully supported when reversing the transform

% ... now on to fluents...
syntax2p_literal(not(L),Vars,lpsp2p,[T1,T2],ET,null,holds(not(NL),T)) :- 
	% Wei syntax seems to preclude 'not' elsewhere!
	!,
	syntax2p_literal(L,Vars,lpsp2p,[T1,T2],ET,_,holds(NL,T)),
	check_time_var(T,Vars).
	% Should probably ...? \+ head_hint(L,l_timeless),
syntax2p_literal(LT,_Vars,lps2p,[T1,_T2],ET,Spec,holds(not(NL),T)) :- % not(fluent) at T is the preferred form, but 2 others avaialable
	( 
		LT= (not(F) at T), Spec = delimiter - [delimiter-[EF],classify], ET=true ; 
		LT= not(F at T), Spec = delimiter - [delimiter - [EF,classify]], ET=true ; 
		LT= not(F), head_hint(F,fluent), Spec = delimiter - [EF], ET=false),
	!,
	simple_fluent_colour(F,EF),
	NL=F,
	remember_fluent_hint(F),
	T1=T.	
syntax2p_literal(L,Vars,lpsp2p,[T1,_T2],true,null,holds(NL,T)) :- 
	nonvar(L),
	L=..LL, LL=[_,_|_], append(Tless,[T],LL), 
	is_time_var(Vars,T),
	\+ head_hint(L,l_timeless),
	!,
	NL=..Tless, T=T1.
syntax2p_literal(LT,_Vars,lps2p,[T1,_T2],true,delimiter-[FC,classify],holds(NL,T)) :- 
	nonvar(LT), LT = (F at T),
	!,
	NL=F, T=T1,
	simple_fluent_colour(F,FC),
	remember_fluent_hint(F).
syntax2p_literal(F,_Vars,lps2p,[T1,_T2],false,EF,holds(NL,T)) :- 
	nonvar(F), head_hint(F,fluent),
	!,
	simple_fluent_colour(F,EF),
	NL=F, T=T1.
syntax2p_literal(L,Vars,lpsp2p,[T1,_T2],true,null,holds(NL,T)) :- 
	var(L),
	!,
	is_time_var(Vars,T), T=T1,
	NL=..NLL, append(NLL,[T],Tplus),
	L=..Tplus.
syntax2p_literal(L,_Vars,lps2p,[T1,_T2],true,null,holds(NL,T)) :- 
	var(L),
	!,
	L = (NL at T), T1=T. % ...thus ommitting "..at..." in fluents is not fully supported when reversing the transform
syntax2p_literal(L,_,_Translator,[_T1,_T2],false,body(L),L) :- may_add_timeless_ref(L). % some timeless literal

check_time_var(V,Vars) :- is_time_var(Vars,V), !.
check_time_var(V,Vars) :-
	write('*** Warning: time variable in a time predicate should start with T:'), 
	\+ \+ (bindAllVars(Vars), writeln(V)).
	
% is_time_var(AllVars,Var)
% Accepting any Txxx variable as time variable
is_time_var([],_T) :-!, fail.
is_time_var([VV|_Vars], T) :- arg(2,VV,V), V==T, !,
	is_time_var(VV).
is_time_var([_VV|Vars], T) :- is_time_var(Vars, T).

is_time_var(VV) :- 
	arg(1,VV,Name), atom_codes(Name,Codes), 
	(append("T",Rest,Codes);append("_T",Rest,Codes)),
	!,
	(Rest=[] -> true ; 
		Rest=[C|_], 
		% T_... or T0/9...
		(C==95->true;C>=48,C=<57)
	).
	

% Declare here predicates you wish to keep unchanged accross the transform
% For some specific cases, predicate sort hints are remembered
% Most bodies left var, as we may want to use Prolog there, for some kind of "meta-level"
% Finally, we leave Wei syntax terms untouched when translating TO that syntax, so we can mixing them in
% do_not_transform_may_hint(Head,SyntaxName,ToWei,Body,-ColourSpec)
do_not_transform_may_hint(observe(Events,_),_,_,_,lps_delimiter-classify) :-!, remember_hints(event,Events). 
do_not_transform_may_hint(fluent(F),_,_,_,lps_delimiter-[fluent-classify]) :- !, remember_declarations(fluent,F).
do_not_transform_may_hint(event(E),_,_,_,lps_delimiter-[event-classify]) :- !, remember_declarations(event,E).
do_not_transform_may_hint(action(A),_,_,_,lps_delimiter-[event-classify]) :- !, remember_declarations(event,A).
do_not_transform_may_hint(initial_state(S),_,true,_,lps_delimiter-[Specs]) :- !, remember_hints(fluent,S), comma_to_list(_,fluent,Specs,S).
do_not_transform_may_hint(l_int(_,_),_,true,_,null).
do_not_transform_may_hint(l_events(_,_),_,true,_,null).
do_not_transform_may_hint(l_timeless(_,_),_,true,_,null).
do_not_transform_may_hint(initiated(_,_,_),_,_,_,null).
do_not_transform_may_hint(terminated(_,_,_),_,_,_,null).
do_not_transform_may_hint(reactive_rule(_,_,_),_,true,_,null).
do_not_transform_may_hint(reactive_rule(_,_),_,true,_,null).
do_not_transform_may_hint(d_pre(_),_,true,_,null).
do_not_transform_may_hint(maxTime(_),lps2p,_,_,lps_delimiter-classify).

% pretty printing for all syntaxes; although not doing anything specific to the new (lps2p translator) syntax
pretty_write(Term) :- pretty_write(Term,0,user_output).

pretty_write(Term,Stream) :- pretty_write(Term,0,Stream).

% pretty_write(Term,Indent,Stream)
pretty_write((if A then C priority P),I,S) :- !, 
	my_tab(S,I), write(S,'if '), writeln(S,A), 
	my_tab(S,I), write(S,'then '), writeln(S,''), 
	NI is I+4, pretty_write(C,NI,S), 
	write(S,'  priority '), write(S,P).
pretty_write((if A then C),I,S) :- !, 
	my_tab(S,I), write(S,'if '), writeln(S,A), 
	my_tab(S,I), write(S,'then '), writeln(S,''), 
	NI is I+4, pretty_write(C,NI,S).
pretty_write((H if B),I,S) :- !, 
	my_tab(S,I), write(S,H), writeln(S,' if'), 
	my_tab(S,I), NI is I+4, pretty_write(B,NI,S).
pretty_write((A--->C priority P),I,S) :- !, 
	my_tab(S,I), write(S,A), writeln(S,' --->'), 
	NI is I+4, pretty_write(C,NI,S),
	write(S,'  priority '), write(S,P).
pretty_write((A--->C),I,S) :- !, 
	my_tab(S,I), write(S,A), writeln(S,' --->'), NI is I+4, pretty_write(C,NI,S).
pretty_write(Declaration,I,S) :- Declaration=..[Op,C], member(Op,[false,initially,fluents,events,actions]), !,
	my_tab(S,I), write(S,Op), writeln(S,''), NI is I+4,
	pretty_write(C,NI,S).
pretty_write(PostCondition,I,S) :- 
	(
		PostCondition = (E terminates F :- C), Op=(terminates) ; 
		PostCondition = (E initiates F :- C), Op=(initiates) ;
		PostCondition = (E terminates F), C=true, Op=(terminates) ;
		PostCondition = (E initiates F), C=true, Op=(initiates)
	), !,
	my_tab(S,I), write(S,E), write(S,' '), 
	write(S,Op), write(S,' '), pretty_write((F:-C),I,S).
	

pretty_write((H:-true),I,S) :- !, pretty_write(H,I,S).
pretty_write((H:-B),I,S) :- !, 
	my_tab(S,I), write(S,H), writeln(S,' :-'), NI is I+4, pretty_write(B,NI,S).
pretty_write((G1,G2),I,S) :- !, 
	my_tab(S,I), write(S,G1), writeln(S,','), pretty_write(G2,I,S).
pretty_write(G,I,S) :- my_tab(S,I), write(S,G).

my_tab(_S,0) :- !.
my_tab(S,I) :- I>0, write(S,' '), NI is I-1, my_tab(S,NI).

% predicate_for(Term,Spec)
predicate_for(V,none) :- var(V), !.
predicate_for((H:-_),F/A) :- !, functor(H,F,A).
predicate_for(H,F/A) :- functor(H,F,A).

init_definition_newliner :- set_currently_defining(none).

set_currently_defining(P) :- 
	uretractall('_currenty__defining'(_)), uassert('_currenty__defining'(P)).
	
may_write_newline(Term,S) :- 
	predicate_for(Term,P), 
	( '_currenty__defining'(P) -> true ; set_currently_defining(P), writeln(S,'')).
