/* 
** Author(s): Miguel Calejo
** Contact:   info@interprolog.com, http://interprolog.com
** Copyright (C) InterProlog Consulting / Renting Point - Serviços de Informática Lda., Portugal 2016
** Use and distribution, without any warranties, under the terms of the 
** Affero GPL License, readable in http://www.gnu.org/licenses/why-affero-gpl.en.html
*/

/* Implement a surface syntax closer to that used on papers (.LPSP extension), 
mapping both to/from "Wei syntax" (.P or .pl extension) as assumed in the engine .
The syntax is as follows:

Antecedent ---> Consequent.
Antecedent ---> Consequent priority P.
myEvent(X,T1,T2) :- 
   whatever(T1), blah(X), ev(T1,Tx),  tc(Tx>T1), anotherEvent(Tx,T2).
intensional(A,T) :- some_fluent(B,T), timelessP(A,B).
false :- pickup_forks(F1, philosopher(N), F2,T1,T2),   not available(F1,T1).
initiated available(F2) :- 
  putdown_forks(F1, philosopher(N), F2,T1,T2).
terminated available(F2) :- 
  putdown_forks(F1, philosopher(N), F2,T1,T2).

Time variables must start with T or _T, followed by _ or a digit.
Prolog facts in general are not transformed.

LIMITATION wrt time variable convention: 
If a l_timeless predicate has T variables, it's (reverse) conversion to our syntax will be wrong...
... because on a subsequent conversion (from ours to Wei's) that predicate will become a timefull predicate
Ditto for "timeful" predicates with non-T variables
*/

:- op(1200,xfx,--->). % for reactive rules
:- op(1190,xfx,priority). %... with priority
:- op(900,fy,terminated).
:- op(900,fy,initiated).

:- export lpsp2p_file/3, lpsp2p_file/2, gol/2, gol/1, golv/2, golv/1.

:- import append/3 from basics.
:- import concat_atom/2 from string.
:- import file_read/3 from xsb_read.
:- import closetail/1 from listutil.

:- import go/2 from interpreter.
:- import gov/2 from visualizer.

:- consult:add_this_lib_dir.

% Convert a file in LPSP into Wei syntax and execute it 
gol(LPSP_file,Options) :-
	concat_atom([LPSP_file,'_.P'],Pfile),
	lpsp2p_file(LPSP_file,Pfile,true),
	go(Pfile,Options).

gol(LPSP_file) :- gol(LPSP_file,[]).

golv(LPSP_file) :- golv(LPSP_file,[]).

golv(LPSP_file,Options) :-
	concat_atom([LPSP_file,'_.P'],Pfile),
	lpsp2p_file(LPSP_file,Pfile,true),
	gov(Pfile,Options).

% lpsp2p_file(?LPSPfile,?LPSWfile)
lpsp2p_file(LPSPfile,LPSWfile) :- atom(LPSPfile), !,
	(atom(LPSWfile)->true;concat_atom([LPSPfile,'_.lpsw'],LPSWfile)),
	lpsp2p_file(LPSPfile,LPSWfile,true).
lpsp2p_file(LPSPfile,LPSWfile) :- 
	atom(LPSWfile), 
	(atom(LPSPfile)->true;concat_atom([LPSWfile,'_.lpsp'],LPSPfile)),
	lpsp2p_file(LPSPfile,LPSWfile,false).

		
% lpsp2p_file(+LPSPfile,+Pfile,+ToWei)
% If ToWei==true it generates a .P file from the first file, else vice-versa
lpsp2p_file(Lfile,Pfile,ToWei) :-
	init_definition_newliner,
	retractall(head_hint(_,_)),
	current_prolog_flag(write_depth,Old), set_xsb_flag(write_depth,10000),
	(ToWei==true -> 
		file_exists(Lfile), open(Lfile,read,IStr), open(Pfile,write,OStr), 
		Convert = lpsp2p(Term,Vars,NewTerm)
		; 
		file_exists(Pfile), open(Pfile,read,IStr), open(Lfile,write,OStr),
		Convert = lpsp2p(NewTerm,Vars,Term)
		),
	IStr >= 0, OStr>=0,
	repeat,
	file_read(IStr,Term,Vars), closetail(Vars),
	( Term==end_of_file -> true
	;  
		Convert, 
		% When converting back to our syntax from Wei's, make sure T vars are not misinterpreted:
		% NO! Too strong
		% ((ToWei\==true, member(V,Vars), is_time_var(V)) -> true
		%	; 
		bindAllVars(Vars), 
		may_write_newline(NewTerm,OStr),
		pretty_write(NewTerm,OStr), writeln(OStr,'.'), 
		fail
	),
	!,
	close(OStr),close(IStr),
	set_xsb_flag(write_depth,Old).

% head_hint(HeadTemplate,Sort) Sort is l_timeless
%  a fact means that some head was read before tagged as Sort 
:- dynamic head_hint/2.
remember_hint(H) :- 
	functor(H,F,N), functor(HH,F,N),
	( head_hint(HH,l_timeless) ->  true; assert(head_hint(HH,l_timeless) )).

% lpsp2p(?LPSPterm,+Vars,?Pterm) Vars is a (closed tail) list of some_functor(Name,Variable)
% Either LPSPterm or Pterm must be bound; the other should be unbound
% Probably needs to evolve to return error messages
lpsp2p(L,_,PT) :- var(L), var(PT), !, fail.
lpsp2p((A--->C priority P),Vars,reactive_rule(NA,NC,P)) :- !, 
	lpsp2p_sequence(A,Vars,NA), lpsp2p_sequence(C,Vars,NC).
lpsp2p((A--->C),Vars,reactive_rule(NA,NC)) :- !, 
	lpsp2p_sequence(A,Vars,NA), lpsp2p_sequence(C,Vars,NC).
lpsp2p((H:-B),_,PT) :- var(PT), (var(H);var(B)), !, fail.
lpsp2p((H:-B),_,(H:-B)) :- do_not_transform(H,B), !.
lpsp2p(Fact,_,Fact) :- do_not_transform(Fact,true), !.
lpsp2p((false:-B),Vars,d_pre(IC)) :- !, 
	lpsp2p_sequence(B,Vars,IC).
lpsp2p((IT:-B),Vars,PT) :- % LPSP -> Wei term
	var(PT),
	IT=..[F,H], ((F==terminated) ; (F==initiated)), 
	!,
	lpsp2p_sequence(B,Vars,[NB1|NBn]), % should be strictier wrt NB1 ?
	PT=..[F,NB1,H,NBn].
lpsp2p(L,Vars,PT) :- % LPSP <- Wei term
	var(L), PT=..[F,NB1,H,NBn], 
	((F==terminated) ; (F==initiated)), 
	!,
	LH=..[F,H], L = (LH:-B),
	lpsp2p_sequence(B,Vars,[NB1|NBn]). % should be strictier wrt NB1 ?
lpsp2p(L,Vars,PT) :- 
	(var(PT) -> ToWei=true; ToWei=false),
	(L = (LH:-LB)->true;LH=L,LB=true), 
	(ToWei==true -> lpsp2p_literal(LH,Vars,NH); true),
	( 
	PT = l_events(NH,NB), NH=happens(H,_,_) ;
	PT = l_int(NH,NB), NH = holds(H,_) ;
	% if a timeless head, remember that to override "time looks" in body if need be:
	PT = l_timeless(NH,NB), \+ (nonvar(NH), (NH = holds(_,_);NH = happens(_,_,_)) ), remember_hint(NH)
	),
	!,
	(ToWei==false -> lpsp2p_literal(LH,Vars,NH) ; true),
	lpsp2p_sequence(LB,Vars,NB).

lpsp2p(Fact, _, Fact). % pass through for Wei terms or other Prolog facts

lpsp2p_sequence((L1,L2),Vars,[PT1|PT2]) :- PT2 \== [], !,
	lpsp2p_literal(L1,Vars,PT1), lpsp2p_sequence(L2,Vars,PT2).
lpsp2p_sequence(true,_,[]) :- !.
lpsp2p_sequence(L,Vars,[PT]) :- lpsp2p_literal(L,Vars,PT).

lpsp2p_literal(tc(TC),_Vars,tc(TC)) :- !. %TODO: check Vars for (some) Ts!!!
lpsp2p_literal(L,Vars,happens(NL,T1,T2)) :- 
	nonvar(L),
	L=..LL, append(Tless,[T1,T2],LL),  Tless=[_|_], % last 2 args of term 
	is_time_var(Vars,T1), is_time_var(Vars,T2),	
	\+ head_hint(L,l_timeless),
	!,
	NL=..Tless.
lpsp2p_literal(L,Vars,happens(NL,T1,T2)) :- 
	var(L),
	!,
	NL=..NLL, append(NLL,[T1,T2],Tplus),  
	!,
	check_time_var(T1,Vars), check_time_var(T2,Vars),
	L=..Tplus.
lpsp2p_literal(not(L),Vars,holds(not(NL),T)) :- 
	% Wei syntax seems to preclude 'not' elsewhere!
	!,
	lpsp2p_literal(L,Vars,holds(NL,T)),
	check_time_var(T,Vars).
	% Should probably ...? \+ head_hint(L,l_timeless),
lpsp2p_literal(L,Vars,holds(NL,T)) :- 
	nonvar(L),
	L=..LL, LL=[_,_|_], append(Tless,[T],LL), 
	is_time_var(Vars,T),
	\+ head_hint(L,l_timeless),
	!,
	NL=..Tless.
lpsp2p_literal(L,Vars,holds(NL,T)) :- 
	var(L),
	!,
	is_time_var(Vars,T),
	NL=..NLL, append(NLL,[T],Tplus),
	L=..Tplus.
lpsp2p_literal(L,_,L). % some timeless literal

check_time_var(V,Vars) :- is_time_var(Vars,V), !.
check_time_var(V,Vars) :-
	write('*** Warning: time variable in a time predicate should start with T:'), 
	\+ \+ (bindAllVars(Vars), writeln(V)).
	
% is_time_var(AllVars,Var)
% Accepting any Txxx variable as time variable
is_time_var([],_T) :-!, fail.
is_time_var([VV|_Vars], T) :- arg(2,VV,V), V==T, !,
	is_time_var(VV).
is_time_var([_VV|Vars], T) :- is_time_var(Vars, T).

is_time_var(VV) :- 
	arg(1,VV,Name), atom_codes(Name,Codes), 
	(append("T",Rest,Codes);append("_T",Rest,Codes)),
	!,
	(Rest=[] -> true ; 
		Rest=[C|_], 
		% T_... or T0/9...
		(C==95->true;C>=48,C=<57)
	).
	
% also closes var tailed lists
bindAllVars([]) :- !.
bindAllVars([VV|Vars]) :- 
	arg(1,VV,Name), arg(2,VV,Value), 
	(var(Value) -> Value=Name ; true), bindAllVars(Vars).

% Declare here predicates you wish to keep unchanged accross the transform
do_not_transform(observe(_,_),_). % to cater for observe/2 rules (in addition to facts)
do_not_transform(fluent(_),_).
do_not_transform(event(_),_).
do_not_transform(action(_),_).
do_not_transform(initial_state(_),_).

% pretty printing
pretty_write(Term,Stream) :- pretty_write(Term,0,Stream).

% pretty_write(Term,Indent,Stream)
pretty_write((A--->C priority P),I,S) :- !, 
	my_tab(S,I), write(S,A), writeln(S,' --->'), 
	NI is I+4, pretty_write(C,NI,S),
	write(S,'    priority '), write(S,P).
pretty_write((A--->C),I,S) :- !, 
	my_tab(S,I), write(S,A), writeln(S,' --->'), NI is I+4, pretty_write(C,NI,S).
pretty_write((H:-true),I,S) :- !, pretty_write(H,I,S).
pretty_write((H:-B),I,S) :- !, 
	my_tab(S,I), write(S,H), writeln(S,' :-'), NI is I+4, pretty_write(B,NI,S).
pretty_write((G1,G2),I,S) :- !, 
	my_tab(S,I), write(S,G1), writeln(S,','), pretty_write(G2,I,S).
pretty_write(G,I,S) :- my_tab(S,I), write(S,G).

my_tab(_S,0) :- !.
my_tab(S,I) :- I>0, write(S,' '), NI is I-1, my_tab(S,NI).

% predicate_for(Term,Spec)
predicate_for(V,none) :- var(V), !.
predicate_for((H:-_),F/A) :- !, functor(H,F,A).
predicate_for(H,F/A) :- functor(H,F,A).

:- dynamic '_currenty__defining'/1.

init_definition_newliner :- set_currently_defining(none).

set_currently_defining(P) :- 
	retractall('_currenty__defining'(_)), assert('_currenty__defining'(P)).
	
may_write_newline(Term,S) :- 
	predicate_for(Term,P), 
	( '_currenty__defining'(P) -> true ; set_currently_defining(P), writeln(S,'')).
