:- module(interpreter, [
	go/1, go/2, go_lps/1, go_lps/2,
	test_examples/0, build_all_test_results/0, do_test_suite/2, load_test_file_for/1,
	load_check_syntax/2, my_load_dyn/1, my_term_to_atom/2]).

%%% XSB specific section:
:- if(current_prolog_flag(dialect, xsb)).

:- consult:current_loaded_file(F), parse_filename(F,D,_,_), retractall(lps_engine_directory(_)), assert(lps_engine_directory(D)).
:- use_module(basics, [length/2, member/2, append/3, select/3, reverse/2]).
:- use_module(lists, [append_lists/2]).
% :- import unifiable/3 from constraintLib.
:- use_module(bounds,[(in)/2, /* unused: (#>)/2, (#>=)/2, */ (#<)/2, (#=<)/2, (#=)/2, labeling/2]).
:- use_module(subsumes,[variant/2]).
:- use_module(num_vars,[numbervars/1]).
:- use_module(string,[concat_atom/2, term_to_codes/2]).
:- use_module(format,[format/2]).
:- use_module(standard,[datime/1]).
date_stamp(D) :- datime(Date), fmt_write_string(D,"%d-%02d-%02d at %02d:%02d:%02d",Date).

:- use_module(machine,[conget/2, conset/2]).
:- use_module(shell,[list_directory/2, is_directory/1]).

lps_examples_directory(ED) :- 
	lps_engine_directory(D), 
	concat_atom([D,'/../examples'], E), expand_filename(E,ED).

my_load_dyn(F,_) :- load_dyn(F).

my_term_to_codes(T,C) :- atomize_zero_functors(T,NT), term_to_codes(NT,C).

% atomize_zero_functors(+Term,-NewTerm) replaces subterms foo() by 'foo'
% turnaround to bug reported by Miguel to XSB folks on May 24, 2016
atomize_zero_functors(T,NT) :- var(T), !, NT=T.
atomize_zero_functors(T,NT) :- functor(T,F,0), atom(F), !, NT=F.
atomize_zero_functors(T,NT) :- atomic(T), !, NT=T.
atomize_zero_functors([T1|Tn],[NT1|NTn]) :- !, atomize_zero_functors(T1,NT1), atomize_zero_functors(Tn,NTn).
atomize_zero_functors(T,NT) :- T=..[F|Args], atomize_zero_functors(Args,NewArgs), NT=..[F|NewArgs].

my_term_to_atom(T,A) :- my_term_to_codes(T,C), atom_codes(A,C).

:- use_module(usermod,[
	action/1, /*cacts/1,*/ current_time/1, d_pre/1 ,event/1,
	fluent/1, happens/3, (initiated)/3, l_events/2, l_int/2,
	l_timeless/2, observe/2, reactive_rule/2, reactive_rule/3, state/1,
	steps/1, succ_t/2, /*susp/1,*/ (terminated)/3, used/1,
	current_goal/1, depth/1, tried/3, failed/3, option/1,
	expanded_consequent/2, initial_state/1,
	lps_test_result/3, lps_test_result_item/3, lps_test_options/1, lps_source_position/3,
	lps_engine_directory/1]).
	
:- endif.

%%% end of XSB specific section; now for SWI:

:- if(current_prolog_flag(dialect, swi)).

:- prolog_load_context(directory, D), retractall(lps_engine_directory(_)), assert(lps_engine_directory(D)).
:- use_module(library(lists), [member/2, append/3, select/3, reverse/2]).
append_lists([],[]).
append_lists([X|Xs],L) :-
	append(X,T,L),
	append_lists(Xs,T).
% :- import unifiable/3 from constraintLib.
:- use_module(library(bounds),[(in)/2, /* unused: (#>)/2, (#>=)/2, */ (#<)/2, (#=<)/2, (#=)/2, labeling/2]).
:- use_module(library(terms),[variant/2]).
:- use_module(library(varnumbers),[numbervars/1]).
term_to_codes(T,C) :- term_to_atom(T,A), atom_codes(A,C).
my_term_to_atom(T,A) :- term_to_atom(T,A).
concat_atom(L,A) :- atomic_list_concat(L,A).
%:- use_module(format,[format/2]).
:- use_module(library(dialect/sicstus/system),[datime/1]).
date_stamp(D) :- datime(Date), Date=..[_|Args], format(atom(D),"~d-~d-~d at ~d:~d:~d",Args).
conget(Name,Value) :- nb_getval(Name, Value).
conset(Name,Value) :- nb_setval(Name, Value).

list_directory(D,F) :- directory_files(D,Files), member(F,Files).
is_directory(D) :- exists_directory(D).
expand_filename(F,Path) :- expand_file_name(F,[Path]).

:- use_module(library(filesex),[relative_file_name/3]).
lps_examples_directory(ED) :- 
	lps_engine_directory(D), 
	concat_atom([D,'/'],DD), % hack, don't know where to fetch OS-dependent separator
	relative_file_name(ED,DD,'../examples').

my_load_dyn(F,WithWarnings) :- 
	(style_check('?'(singleton))->Old=true;Old=false),
	(WithWarnings==true -> style_check('+'(singleton)) ; style_check('-'(singleton))),
	load_files([F],[module(user)]),
	(Old==true -> style_check('+'(singleton)) ; style_check('-'(singleton))).

cputime(T) :- T is cputime.

% TODO: somehow runing tests a second time still originates "Clauses of interpreter:terminated/3 , etc. are not together..."
:- discontiguous((  (initiated) /3, (terminated)/3, l_events/2, reactive_rule/3, reactive_rule/2, l_int/2, l_timeless/2 )).

% no need to import user module predicates

:- endif.

%%% end of SWI and Prolog engine-specific code
%%% From here on, generic Prolog code

my_load_dyn(F) :- my_load_dyn(F,true).

:- lps_engine_directory(D), concat_atom([D,'/db.P'],DB), my_load_dyn(DB).

maximum_time(1000000000). % large number, hardwired so our test result files are cross-engine
% ...otherwise these might move to the previous conditional segmnts:
% XSB: maximum_time(Max) :- current_prolog_flag(max_integer, Max).
% SWI: maximum_time(Max) :- current_prolog_flag(max_tagged_integer, Max).

% my_term_size(Item,Size)  
% could use XSB's native term_size, but I was having trouble aligning it with the following for SWI, so...
my_term_size(T,1) :- var(T), !.
my_term_size([T|TT],N) :- !, my_term_size(T,N1), my_term_size(TT,N2), N is N1+N2.
my_term_size([],1) :- !.
my_term_size(T,1) :- atomic(T), !.
my_term_size(T,N) :- T=..[_|L], my_term_size(L,N2), N is N2+1.

:- dynamic lps_test_result/3, lps_test_result_item/3, lps_test_options/1, lps_failed_test/2.
:- dynamic lps_source_position/3.
% This fact will contain this file's directory; its presence also denotes "LPS running"
:- dynamic lps_engine_directory/1.

% query(+P)
%   True if P holds in the augmented state {S*_i, ev*_i, L_int, L_timeless}.
% 
query(holds(not(P), Now)) :-
    current_time(Now_),
    % a little hack to allow access to the (still available) previous state,
    % because at step 0 of the OS Cycle we already incremented time:
    ( lps_updating_current_state -> succ_t(Now, Now_) ; Now=Now_),
    \+ l_int(holds(P, Now), _),
    \+ state(P).
query(holds(P, Now)) :-
    current_time(Now_),
    ( lps_updating_current_state -> succ_t(Now, Now_) ; Now=Now_),
    \+ l_int(holds(P, Now), _), 
    state(P).
query(happens(P, Prev, Now)) :-
    current_time(Now),
    succ_t(Prev, Now), 
    happens(P, Prev, Now).
query(holds(not(P), Now)) :-
    current_time(Now_),
    ( lps_updating_current_state -> succ_t(Now, Now_) ; Now=Now_),
    l_int(holds(P, Now), B),
    \+ holds_all(B).
query(holds(P, Now)) :-
    current_time(Now_),
    ( lps_updating_current_state -> succ_t(Now, Now_) ; Now=Now_),
    l_int(holds(P, Now), B),
    holds_all(B).
query(P) :-
    l_timeless(P, B),
    evaluate(B).

% evaluate(+Body)
%
evaluate([]).
evaluate([P|Rest]) :-
    l_timeless(P, _),
    query(P),
    evaluate(Rest).
evaluate([P|Rest]) :-
    call(P),
    evaluate(Rest).

% holds_all(+PL)
%   True if all predicates in PL hold in the augmented state {S*_i, ev*_i,
%   L_int, L_timeless}.
%
holds_all([]).
holds_all([P|Rest]) :-
    query(P),
    holds_all(Rest).

:- dynamic lps_updating_current_state/0.

enter_step_0 :- assert(lps_updating_current_state).
leave_step_0 :- retractall(lps_updating_current_state).

% update(+Ev)
%   Destructively update the state for a single event Ev.
%
update(Ev) :-
    assertz(Ev),
    findall(Fl, (terminated(Ev, Fl, Cond), holds_all(Cond)), Terms),
    findall(Fl, (initiated(Ev, Fl, Cond), holds_all(Cond)), Inits),
    forall((member(Fl, Terms),state(Fl)), retract(state(Fl))),
    forall((member(Fl, Inits),\+ state(Fl)), assertz(state(Fl))).

% update_all(+Evs)
%   Destructively update the state for a list of events Evs.
%
update_all([]).
update_all([Ev|Evs]) :-
    current_time(Now),
    succ_t(Prev, Now),
    update(happens(Ev, Prev, Now)),
    update_all(Evs).

% generate_id(GoalId)
%
generate_id(GoalId) :-
    % random(10000, 100000, RandN), 
    % Miguel sees no need for non determinism here, which is bad for tests, so:
    increment_goal_id(Id) ,
    ( used(Id) ->
        generate_id(GoalId)
    ;
        GoalId = Id
    ).

increment_goal_id(Id) :- 
	conget(lps_goal_id_counter,Id), 
	New is Id+1, conset(lps_goal_id_counter,New).

reset_goal_ids :- 
	conset(lps_goal_id_counter,10000).

% process(+Ri, -NextRi, +Gi, -NextGi)
%   Process reactive rules, both partially resolved from previous cycles Ri and
%   new.
%
%   If the antecedent of any reactive rule is resolved to be empty, then the
%   consequent is added to Gi.
%
process(Ri, NextRi, Gi, NextGi) :-
    ( setof([[HA|TA], C], (reactive_rule([HA|TA], C), query(HA)), Rs)
    ; Rs = []
    ),
    %findall([A,C], reactive_rule(A,C), Rs),
    do_process(normal,Rs, NRs, [], NGs),
    do_process(normal,Ri, NRi, Gi, NGi),
    append(NRi, NRs, NextRi),
    append(NGi, NGs, NextGi).


% do_process(+Mode,+Ri, -NRi, +Gi, -NGi)  Mode is normal or priority
%   Process a list of (fresh or existing partially resolved) reactive rules. Output a partially resolved
%   list of reactive rules NRi and a list of goals NGi.
do_process(_,[], [], Gi, Gi) :- !.
do_process(normal, [[[], C]|Ris], NewRi, Gi, [goal(GoalId, [C])|NewGi]) :- !,
    generate_id(GoalId),
    do_process(normal,Ris, NewRi, Gi, NewGi).
do_process(priority,[[[], C, P]|Ris], NewRi, Gi, [goal(P, GoalId, [C])|NewGi]) :-
    generate_id(GoalId),
    do_process(priority,Ris, NewRi, Gi, NewGi).
do_process(Mode,[[A|Rest]|Ris], TheNewRi, Gi, TheNewGi) :-
    %write('A: '),write(A),nl,
    % writeln(setof([NA|Rest], process2_(A, NA), Rs)),
    ( % setof([NA|Rest], process2_(A, NA), Rs) %XSB crashing because of some vars in Rest
    	% TODO: probably revert this to setof after XSB bug fix, Miguel emailed TS May 24, 2016
    	findall([NA|Rest], process2_(A, NA), Rs)
    ; Rs = []
    ), 
    % make sure unsolvable literals remain in the resolvent:
    ( (select([NA, _],Rs,Rs2), variant(A,NA)) -> 
    	   TheNewRi=[[A|Rest]|TheNewRi2] 
    	; Rs2=Rs, TheNewRi=TheNewRi2 ),
    do_process2(Mode,Rs2,Ris,NewRi,Gi,NewGi),
    do_process(Mode,NewRi,TheNewRi2,NewGi,TheNewGi).

% do_process_new2(Mode,ProcessedRis,Ris,NewRi,Gi,NewGi)
do_process2(_,[],Ris,Ris,Gi,Gi) :- !.
do_process2(normal,[[[], C]|PRis],Ris,NewRi,Gi,NewGi) :- !,
	generate_id(GoalId),
     do_process2(normal,PRis,Ris,NewRi,[goal(GoalId, [C])|Gi],NewGi).
do_process2(priority,[[[], C, P]|PRis],Ris,NewRi,Gi,NewGi) :- !,
	generate_id(GoalId),
     do_process2(priority,PRis,Ris,NewRi,[goal(P,GoalId,[C])|Gi],NewGi).
do_process2(Mode,[Rule|PRis],Ris,NewRis,Gi,NewGi) :-
	do_process2(Mode,PRis,[Rule|Ris],NewRis,Gi,NewGi).


% Similar to process/4, but using reactive rules with priorities
process_priority(Ri, NextRi, Gi, NextGi) :-
    ( setof([[HA|TA], C, P], (reactive_rule([HA|TA], C, P), query(HA)), Rs)
    ; Rs = []
    ),
    do_process(priority,Rs, NRs, [], NGs),
    do_process(priority,Ri, NRi, Gi, NGi),
    append(NRi, NRs, NextRi),
    append(NGi, NGs, NextGi).

	
% process2_(+A, -NA)
%   Resolve an antecedent A according to the operational semantics by querying
%   the augmented state without making temporal constraints false.
%
%   If nothing can be resolved, NA is unified with A.
%   If the antecedent can never be resolved, NA is unified with 'nosusp' to
%   indicate failure - NOT ANYMORE! Now it simply fails
process2_(A, NA) :- process2(A,NA). 
	
% process2(+A, -NA)
% Now fails instead of succeeding with 'nosusp' as older versions
% This is necessary to execute search over fluents, timeles predicates etc

process2([], []).

process2([L|Ls], _) :- \+ satisfy_all([L|Ls]), !, fail. % seems redundant

process2([holds(Fl, T)|Ls], NB) :-
    query(holds(Fl, T)),
    satisfy_all(Ls),
    process2(Ls, NB).

process2([holds(Fl, T)|Ls], [holds(Fl, T)|Ls]) :-
    var(T),
    % TODO: seems a bug! can't evaluate yet, right? : 
    query(holds(Fl, T)),
    \+ satisfy_all(Ls).

process2([holds(Fl, T)|Ls], _) :-
    number(T), current_time(Now), T == Now,
    query(holds(Fl, T)),
    \+ satisfy_all(Ls),
    !, fail.

process2([holds(_, T)|_], _) :-
    number(T), current_time(Now), T < Now,
    !, fail.

process2([holds(Fl, T)|_], _) :-
    number(T), current_time(Now), T == Now,
    \+ query(holds(Fl, T)),
    !, fail.

process2([holds(Fl, T)|Ls], [holds(Fl, T)|Ls]) :-
    number(T), current_time(Now), T > Now.


process2([happens(Ev, T1, T2)|Ls], NB) :-
    query(happens(Ev, T1, T2)),
    satisfy_all(Ls),
    process2(Ls, NB).

% TODO
process2([happens(Ev, T1, T2)|Ls], [happens(Ev, T1, T2)|Ls]) :-
    (var(T1);var(T2)),
    query(happens(Ev, T1, T2)),
    write('Ls: '),write(Ls),nl,
    \+ satisfy_all(Ls).

process2([happens(Ev, T1, T2)|Ls], _) :-
    (number(T1);number(T2)),
    query(happens(Ev, T1, T2)),
    \+ satisfy_all(Ls),
    !, fail.

process2([happens(Ev, T1, T2)|Ls], [happens(Ev, T1, T2)|Ls]) :-
    (var(T1);var(T2)),
    \+ query(happens(Ev, T1, T2)).

process2([happens(_, _, T2)|_], _) :-
    number(T2), current_time(Now), T2 < Now,
    !, fail.

process2([happens(Ev, T1, T2)|_], _) :-
    number(T2), current_time(Now), T2 == Now,
    \+ query(happens(Ev, T1, T2)),
    !, fail.

process2([happens(Ev, T1, T2)|Ls], [happens(Ev, T1, T2)|Ls]) :-
    number(T2), current_time(Now), T2 > Now.

process2([happens(_, T1, _)|_], _) :-
    number(T1), current_time(Now), T1 < Now,
    !, fail.

process2([happens(_, T1, _)|_], _) :-
    number(T1), current_time(Now), T1 == Now,
    !, fail.

process2([happens(Ev, T1, T2)|Ls], [happens(Ev, T1, T2)|Ls]) :-
    number(T1), current_time(Now), T1 > Now.


process2([TL|Ls], NB) :-
    l_timeless(TL, _),
    query(TL),
    process2(Ls, NB).

%process2([TL|Ls], [TL|Ls]) :-
%    l_timeless(TL, _), % why should we "delay" TL ???
%    \+ query(TL).

process2([tc(X)|Rest], NB) :-
    ground(X),
    process2(Rest, NB).

% expand_reactive_rules
%   Pre-expand composite events in the antecedents of all reactive rules.
%
expand_reactive_rules() :-
    findall(
        [A, C, EA],
        (
            reactive_rule(A, C),
            expand_antecedent(A, [], EA)
        ),
        NewRRs
    ),
    forall(
        member([A, C, EA], NewRRs),
        (
            /*( reactive_rule(A, C) ->
                retract(reactive_rule(A, C))
            ;
                true
            ), the following is safer: */
            retractall(reactive_rule(A, C)),
            assertz(reactive_rule(EA, C)) % TODO: should probably be a different "work" predicate
        )
    ).

expand_consequents() :-
    findall(
        [C, EC],
        (
            reactive_rule(_, C),
            expand_consequent(C, [], EC)
        ),
        ECs
    ),
    forall(
        member([C, EC], ECs),
        (
            assertz(expanded_consequent(C, EC))
        )
    ).

/*
expand_reactive_rules(foo) :-
    findall(
        [A, C, EA, EC],
        (
            reactive_rule(A, C),
            expand_antecedent(A, [], EA)
            add_time_consequents
        ),
        NewRRs
    ),
    forall(
        member([A, C, EA], NewRRs),
        (
            ( reactive_rule(A, C) ->
                retract(reactive_rule(A, C))
            ;
                true
            ),
            assertz(reactive_rule(EA, C))
        )
    ).
*/

% expand_antecedent(+A, +Acc, -EA)
%   Expand the antecedent A via backwards reasoning with l_events.
%
expand_antecedent([], EA, EA).
expand_antecedent([happens(E, T1, T2)|As], Acc, EA) :-
    l_events(happens(E, T1, T2), B),
    expand_antecedent(B, [], EB),
    append(Acc, EB, NewAcc),
    expand_antecedent(As, NewAcc, EA).
expand_antecedent([A|As], Acc, EA) :-
    \+ l_events(A, _),
    append(Acc, [A], NewAcc),
    expand_antecedent(As, NewAcc, EA).

% expand_consequent
%
%
expand_consequent([], EC, EC).
expand_consequent([happens(E, T1, T2)|As], Acc, EC) :-
    l_events(happens(E, T1, T2), B),
    expand_consequent(B, [], EB),
    append(Acc, EB, NewAcc),
    expand_consequent(As, NewAcc, EC).
expand_consequent([A|As], Acc, EC) :-
    \+ l_events(A, _),
    append(Acc, [A], NewAcc),
    expand_consequent(As, NewAcc, EC).

% select_actions(+Actions, +AccumulatedActions, -SelectedActions)
%   Select actions from a list Actions that satisfy all the preconditions in
%   the domain theory.
%
select_actions([], SAs, SAs).
select_actions([ca(_,A)|As], AccA, SAs) :-
    % Pre-conds
    findall(
        NewConds,
        (
            d_pre(Conds), select(A, Conds, NewConds)
        ),
        AllConds
    ),
    all_fail(AllConds, Ret),
    % Post-conds
    % what's the point, as update_action does it below?? Seems buggy as this must never fail:
    % forall(terminated(A, _Fl, Cond),holds_all(Cond)),
    ( Ret = [] ->
        update_action(A),
        append(AccA, [A], NAccA),
        select_actions(As, NAccA, SAs)
    ;
        select_actions(As, AccA, SAs)
    ).

update_action(Ev) :-
    assertz(Ev),
    findall(Fl, (terminated(Ev, Fl, Cond), holds_all(Cond)), Terms),
    findall(Fl, (initiated(Ev, Fl, Cond), holds_all(Cond)), Inits),
    forall((member(Fl, Terms),state(Fl)), retract(state(Fl))),
    forall((member(Fl, Inits),\+ state(Fl)), (assertz(state(Fl)))).

/* Dead code:
select_actions_concurrent([ca(_,A)|As], AllAs, AccA, SAs) :-
    % Pre-conds
    findall(
        NewConds,
        (
            d_pre(Conds), member(A, Conds), select(A, Conds, NewConds)
        ),
        AllConds
    ),
    all_fail(AllConds, Ret),
    % ConCURRENT
    action_concurrent(A, AllAs),
    ( Ret = [] ->
        update_action(A),
        append(AccA, [A], NAccA),
        select_actions(As, NAccA, SAs)
    ;
        select_actions(As, AccA, SAs)
    ).

action_concurrent(A, AllAs) :-
    findall(Fl, (terminated(A, Fl, Cond), holds_all(Cond)), Terms),
    findall(Fl, (initiated(A, Fl, Cond), holds_all(Cond)), Inits),
    forall(member(Fl, Terms), \+ conflict_init(Fl, AllAs)),
    forall(member(Fl, Inits), \+ conflict_term(Fl, AllAs)).

conflict_init(_Fl, []) :- false.
conflict_init(Fl, [ca(_,A)|As]) :-
    findall(Fl2, (initiated(A, Fl2, Cond), holds_all(Cond)), Inits),
    ( member(Fl, Inits) ->
        true
    ;
        conflict_init(Fl, As)
    ).

conflict_term(_Fl, []) :- false.
conflict_term(Fl, [ca(_,A)|As]) :-
    findall(Fl2, (terminated(A, Fl2, Cond), holds_all(Cond)), Terms),
    ( member(Fl, Terms) ->
        true
    ;
        conflict_term(Fl, As)
    ).
*/

% all_fail(Conditions,Result) Result is [] or failed (some succeeded)
% TODO
%
all_fail([], []).
all_fail([C|Cs], Ret) :-
    \+ holds_all(C),
    all_fail(Cs, Ret).
all_fail([C|_], failed) :-
    holds_all(C).

resolve_tree_breadth([], NG, NG, CA, CA).
resolve_tree_breadth([goal(GoalId, G)|Gs], AccG, NG, AccA, CA) :-
    retract(current_goal(_)),
    assertz(current_goal(GoalId)),
    write_verbose(['Goal: ',GoalId,nl]),
    resolve_goal_breadth(G, NextGoal, CandActs),
    retractall(tried(GoalId, 0, expanded_consequent(_, _))),
    ( NextGoal = [] ->
        resolve_tree_breadth(Gs, AccG, NG, AccA, CA)
    ;
        append(AccG, [goal(GoalId, NextGoal)], NAccG),
        append(AccA, CandActs, NAccA),
        resolve_tree_breadth(Gs, NAccG, NG, NAccA, CA)
    ).
resolve_tree_breadth_prio([], NG, NG, CA, CA).
resolve_tree_breadth_prio([goal(P, GoalId, G)|Gs], AccG, NG, AccA, CA) :-
    retract(current_goal(_)),
    assertz(current_goal(GoalId)),
    write_verbose(['Goal: ',GoalId,nl]),
    resolve_goal_breadth(G, NextGoal, CandActs),
    retractall(tried(GoalId, 0, expanded_consequent(_, _))),
    ( NextGoal = [] ->
        resolve_tree_breadth_prio(Gs, AccG, NG, AccA, CA)
    ;
        append(AccG, [goal(P, GoalId, NextGoal)], NAccG),
        append(AccA, CandActs, NAccA),
        resolve_tree_breadth_prio(Gs, NAccG, NG, NAccA, CA)
    ).

resolve_goal_breadth([], [], []) :- fail.
resolve_goal_breadth([B1|Bs], NextGoal, CandActs) :-
    \+ satisfy_all(B1),
    ( Bs == [] ->
        write_verbose(['Top-level goal can never be achieved. Dropping.',nl,nl]),
        NextGoal = [],
        CandActs = []
    ;
        write_verbose(['Backtracking.',nl,'0',nl,nl]),
        resolve_goal_breadth(Bs, NextGoal, CandActs)
    ).
resolve_goal_breadth([TLG|[]], NextGoal, CandActs) :-
    copy_term(TLG, TLGC),
    ( find_unused(ec(TLGC), EC) ->
    	   % TODO: this branch needs testing
    	   current_goal(GoalId),
        assertz(tried(GoalId, 0, expanded_consequent(TLGC, EC))),
        resolve_goal_breadth_end([EC,TLG], NG, CA),
        ( NG == nosusp ->
            resolve_goal_breadth([TLG], NextGoal, CandActs)
        ;
            NextGoal = [NG,TLG],
            CandActs = CA
        )
       ; % was tried_all:
       clear_tried(ec(TLGC)),
       NextGoal = [TLG],
       CandActs = []
	).
        
resolve_goal_breadth([B1,TLG], NextGoal, CandActs) :-
    ( resolveb(B1, NB, CA) ->
        ( NB == [] ->
            NextGoal = []
        ;
            NextGoal = [NB,TLG] % [] or [happens(...]
        ),
        ( CA == none ->
            CandActs = []
        ;
            CandActs = [CA]
        )
    ;
        resolve_goal_breadth([TLG], NextGoal, CandActs)
    ).
resolve_goal_breadth_end([B1,_TLG], NextGoal, CandActs) :-
    ( resolveb(B1, NB, CA) ->
        NextGoal = NB, % [] or [happens(...]
        ( CA == none ->
            CandActs = []
        ;
            CandActs = [CA]
        )
    ;
        NextGoal = nosusp,
        CandActs = none
    ).

resolveb([], [], none).
resolveb([holds(Fl, T)|Rest], NB, CA) :-
    query(holds(Fl, T)), satisfy_all(Rest),
    resolveb(Rest, NB, CA).
resolveb([happens(Ev, T1, T2)|Rest], NB, CA) :-
    query(happens(Ev, T1, T2)), satisfy_all(Rest),
    resolveb(Rest, NB, CA).
resolveb([TL|Rest], NB, CA) :-
    l_timeless(TL, _),
    query(TL),
    resolveb(Rest, NB, CA).
resolveb([tc(X)|Rest], NB, CA) :-
    ground(X),
    resolveb(Rest, NB, CA).
resolveb([happens(Ev, T1, T2)|Rest], NB, CA) :-
    copy_term([happens(Ev, T1, T2)|Rest], [happens(CEv, CT1, CT2)|CLs]),
    try_cand_act([happens(CEv, CT1, CT2)|CLs], CA),
    ( CA \== none ->
        NB = [happens(Ev, T1, T2)|Rest]
    ).
    % CA is none or ca(Earliest, happens)

/* Dead code, threads not used:
resolve_tree_threads([goal(GoalId, G)|Gs], NG, CA) :-
    retract(current_goal(_)),
    assertz(current_goal(GoalId)),
    write_verbose(['Goal: ',GoalId,nl]),
    make_threads([goal(GoalId, G)|Gs], ThreadIds, ThreadResults),
    join_threads(ThreadIds),
    merge_results([goal(GoalId, G)|Gs], ThreadResults, [], NG, [], CA).

merge_results([], [], NG, NG, CA, CA).
merge_results([goal(GoalId, G)|Gs], [gt(NextGoal,CandActs)|Rest], AccG, NG, AccA, CA) :-
    append(AccG, [goal(GoalId, NextGoal)], NAccG),
    append(AccA, CandActs, NAccA),
    merge_results(Gs, Rest, NAccG, NG, NAccA, CA).

make_threads([], [], []).
make_threads([goal(GoalId, G)|Gs], [Id|RestIds], [gt(NextGoal,CandActs)|RestGTs]) :-
    thread_create(resolve_goal(G, NextGoal, CandActs), Id),
    make_threads(Gs, RestIds, RestGTs).

join_threads([]).
join_threads([TId|Rest]) :-
    thread_join(TId, _),
    join_threads(Rest).
*/

% resolve_tree
%
resolve_tree([], NG, NG, CA, CA).
resolve_tree([goal(GoalId, G)|Gs], AccG, NG, AccA, CA) :-
    retract(current_goal(_)),
    assertz(current_goal(GoalId)),
    write_verbose(['Goal: ',GoalId,nl]),
    resolve_goal(G, NextGoal, CandActs),
    retractall(failed(GoalId, _, _)),
    retractall(tried(GoalId, _, happens(_,_,_))),
    ( NextGoal = [] ->
        resolve_tree(Gs, AccG, NG, AccA, CA)
    ;
        append(AccG, [goal(GoalId, NextGoal)], NAccG),
        append(AccA, CandActs, NAccA),
        resolve_tree(Gs, NAccG, NG, NAccA, CA) 
    ).
resolve_tree_prio([], NG, NG, CA, CA).
resolve_tree_prio([goal(P, GoalId, G)|Gs], AccG, NG, AccA, CA) :-
    retract(current_goal(_)),
    assertz(current_goal(GoalId)),
    write_verbose(['Goal: ',GoalId,nl]),
    resolve_goal(G, NextGoal, CandActs),
    retractall(failed(GoalId, _, _)),
    retractall(tried(GoalId, _, happens(_,_,_))),
    ( NextGoal = [] ->
        resolve_tree_prio(Gs, AccG, NG, AccA, CA)
    ;
        append(AccG, [goal(P, GoalId, NextGoal)], NAccG),
        append(AccA, CandActs, NAccA),
        resolve_tree_prio(Gs, NAccG, NG, NAccA, CA)
    ).

% resolve_goal(+Goal,-RemainingGoal,-CandidateActions)
%
resolve_goal([], [], []) :- fail.
resolve_goal([B1|Bs], NextGoal, CandActs) :-
    \+ satisfy_all(B1),
    !,
    length([B1|Bs], Depth),
    retractall(depth(_)),
    assertz(depth(Depth)),
    write_verbose(['Depth: ',Depth,nl,B1,' has expired.',nl]),
    ( Bs == [] ->
        write_verbose(['Top-level goal can never be achieved. Dropping.',nl,nl]),
        NextGoal = [],
        CandActs = []
    ;
        write_verbose(['Backtracking.',nl,'0',nl,nl]),
        resolve_goal(Bs, NextGoal, CandActs)
    ).
resolve_goal([B1|Bs], NextGoal, CandActs) :-
    length([B1|Bs], Depth),
    retractall(depth(_)),
    assertz(depth(Depth)),
    write_verbose(['Depth: ',Depth,nl]),
    resolve2(B1, NB, EB, CA),
    ( NB == [] ->
        write_verbose(['1',nl,nl]),
        NextGoal = [],
        CandActs = []
    ; NB == cont ->
        write_verbose(['7',nl,nl]),
        ( Bs == [] ->
            NextGoal = [B1],
            CandActs = []
        ;
            resolve_goal(Bs, NextGoal, CandActs)
        )
    ; EB \== [] ->
        write_verbose(['2',nl,nl]),
        resolve_goal([EB,B1|Bs], NextGoal, CandActs)
    ; CA \== none ->
        write_verbose(['3',nl,nl]),
        NextGoal = [NB|Bs],
        CandActs = [CA]
    ; NB == nosusp ->
        write_verbose([B1,nl,Bs,nl]),
        write_verbose(['4',nl,nl]),
        NextGoal = Bs,
        CandActs = []
    ; NB == B1 ->
        write_verbose(['5',nl,nl]),
        NextGoal = [B1|Bs],
        CandActs = []
    ;
        write_verbose(['6',nl,nl]),
        NextGoal = [NB|Bs],
        CandActs = []
    ).

% check_failed
%
check_failed([holds(Fl, T)|Ls], N) :-
    current_goal(GoalId),
    ( failed(GoalId, [holds(Fl, T)|Ls], N1) ->
        N2 is N1 + 1,
        retract(failed(GoalId, [holds(Fl, T)|Ls], N1)),
        assertz(failed(GoalId, [holds(Fl, T)|Ls], N2)),
        N = N1
    ;
        assertz(failed(GoalId, [holds(Fl, T)|Ls], 1)),
        N = 0
    ).
check_failed([happens(Ev, T1, T2)|Ls], N) :-
    current_goal(GoalId),
    ( failed(GoalId, [happens(Ev, T1, T2)|Ls], N1) ->
        N2 is N1 + 1,
        retract(failed(GoalId, [happens(Ev, T1, T2)|Ls], N1)),
        assertz(failed(GoalId, [happens(Ev, T1, T2)|Ls], N2)),
        N = N1
    ;
        assertz(failed(GoalId, [happens(Ev, T1, T2)|Ls], 1)),
        N = 0
    ).

% find_unused
%
find_unused(holds(Fl, T)) :-
    current_goal(GoalId),
    depth(Depth),
    query(holds(Fl, T)), 
    % can we assume Fl to be ground? If so, should use tried/3 instead:
    \+ tried_variant(GoalId, Depth, state(Fl)).
find_unused(happens(Ev, T1, T2), Body) :-
    current_goal(GoalId),
    depth(Depth),
    l_events(happens(Ev, T1, T2), Body),
    \+ tried_variant(GoalId, Depth, l_events(Ev, Body)).
find_unused(l_tl(TL), Body) :-
    current_goal(GoalId),
    depth(Depth),
    l_timeless(TL, Body),
    \+ tried_variant(GoalId, Depth, l_timeless(TL, Body)).
find_unused(ec(C), EC) :-
    current_goal(GoalId),
    expanded_consequent(C, EC),
    \+ tried_variant(GoalId, 0, expanded_consequent(C, EC)).

% TODO: we're loosing indexing here... should do something cleverer:
% ... AND we still have no example where variant is really necessary :-(
tried_variant(GoalId,Depth,X) :- tried(GoalId,Depth,XX), variant(X,XX).


% tried_all
% useless: tried_all(G) :- \+ find_unused(G), \+ find_unused(G,_).
/*
tried_all(holds(Fl, T)) :-
    current_goal(GoalId),
    depth(Depth),
    forall(
        query(holds(Fl, T)),
        ( 
            tried(GoalId, Depth, state(Fl))
        )
    ).
tried_all(happens(Ev, T1, T2)) :-
    current_goal(GoalId),
    depth(Depth),
    forall(
        l_events(happens(Ev, T1, T2), B),
        (
            tried(GoalId, Depth, l_events(Ev, B))
        )
    ).
tried_all(l_tl(TL)) :-
    current_goal(GoalId),
    depth(Depth),
    forall(
        l_timeless(TL, B),
        (
            tried(GoalId, Depth, l_timeless(TL, B))
        )
    ).
tried_all(ec(C)) :-
    current_goal(GoalId),
    forall(
        expanded_consequent(C, EC),
        (
            tried(GoalId, 0, expanded_consequent(C, EC))
        )
    ).
*/

% clear_tried
%
clear_tried(holds(Fl, _)) :-
    current_goal(GoalId),
    depth(Depth),
    retractall(tried(GoalId, Depth, state(Fl))).
clear_tried(l_events(Ev, _)) :-
    current_goal(GoalId),
    depth(Depth),
    retractall(tried(GoalId, Depth, l_events(Ev, _))).
clear_tried(happens(Ev, _, _)) :-
    current_goal(GoalId),
    depth(Depth),
    retractall(tried(GoalId, Depth, happens(Ev, _, _))).
clear_tried(l_tl(TL)) :-
    current_goal(GoalId),
    depth(Depth),
    retractall(tried(GoalId, Depth, l_timeless(TL, _))).
clear_tried(ec(C)) :-
    current_goal(GoalId),
    retractall(tried(GoalId, 0, expanded_consequent(C, _))).

% clear_failed
%
clear_failed(B) :-
    current_goal(GoalId),
    forall(
        failed(GoalId, B, _),
        retract(failed(GoalId, B, _))
    ).

% resolve
%
resolve2([L|Ls], [L|Ls], [], none) :-
    steps(0).
resolve2([holds(Fl, T)|Ls], NB, EB, CA) :-
    (
        resolve2_holds([holds(Fl, T)|Ls], NB, EB, CA)
    ;
        check_failed([holds(Fl, T)|Ls], N),
        /*
        write('Failed '),write(Fl),write(' '),write(N),write(' times.'),nl,
        write('Backtracking NOW.'),nl,
        NB = cont,
        EB = [],
        CA = none
        */
        ( N == 0 ->
            NB = cont,
            EB = [],
            CA = none
        ;
            write('Failed to resolve branch ['),write(holds(Fl)),
            write(', ...].'),nl,
            write('Backtracking next cycle.'),nl,
            clear_failed([holds(Fl, T)|Ls]),
            %current_goal(GoalId),
            %findall(X, failed(GoalId, X, _), Foo),
            %nl,nl,write(Foo),nl,nl,
            NB = nosusp,
            EB = [],
            CA = none
        )
    ).
resolve2([happens(Ev, T1, T2)|Ls], NB, EB, CA) :-
    \+ \+ l_events(happens(Ev, T1, T2), _), % TODO: Should use copy_term here..???
    /* old comment:
    l_events(CEH, CEB),
    unifiable(CEH, happens(Ev, T1, T2), _),
    */
    ( find_unused(happens(Ev, T1, T2), Body) ->
        write_verbose(['Bound composite event ',Ev,' to',nl,Body,nl]),
        current_goal(GoalId),
        depth(Depth),
        assertz(tried(GoalId, Depth, l_events(Ev, Body))),
        /*
        findall(X, tried(GoalId, Depth, l_events(Ev, X)), Foo),
        write(Foo),nl,
        */
        NB = [happens(Ev, T1, T2)|Ls],
        append(Body, Ls, EB),
        CA = none
    ;
        write_verbose(['All possible unifications for ',Ev,' failed',nl,'Backtracking.',nl]),
        clear_tried(l_events(Ev, _)),
        NB = cont,
        EB = [],
        CA = none
    ).
    /*
    % umm...old comment here:
    % TODO this needs to be checked and cleared when it all fails...
    % need to remember which l_events have been explored, ACROSS cycles
    current_goal(GoalId),
    depth(Depth),
    assertz(tried(GoalId, Depth, l_events(CEH, CEB))),
    append(B, Ls, EB),
    reduce_step.
    */
resolve2([happens(Ev, T1, T2)|Ls], NB, EB, CA) :-
    \+ l_events(happens(Ev, _, _), _),
    (
        resolve2_happens([happens(Ev, T1, T2)|Ls], NB, EB, CA)
    ;
        check_failed([happens(Ev, T1, T2)|Ls], N),
        %write('Failed '),write(happens(Ev)),write(' '),write(N),write(' times.'),nl,
        % TODO let user specify this?
        ( N =< 5 ->
            NB = [happens(Ev, T1, T2)|Ls],
            EB = [],
            copy_term([happens(Ev, T1, T2)|Ls], [happens(CEv, CT1, CT2)|CLs]),
            try_cand_act([happens(CEv, CT1, CT2)|CLs], CA)
        ;
            write('Failed to resolve branch ['),write(happens(Ev)),
            write(', ...].'),nl,
            write('Backtracking next cycle.'),nl,
            clear_failed([happens(Ev, T1, T2)|Ls]),
            /*
            current_goal(GoalId),
            findall(X, failed(GoalId, X, _), Foo),
            nl,nl,write(Foo),nl,nl,
            */
            NB = nosusp,
            EB = [],
            CA = none
        )
    ).
resolve2([TL|Ls], NB, EB, CA) :-
    l_timeless(TL, _),
    (
        resolve2_timeless([TL|Ls], NB, EB, CA)
    ;
        % derp, l_timeless(TL) failed
        % TODO 29 Aug 08:48 - Should l_timeless be kept and retried ACROSS cycles?
        write_verbose([l_timeless(TL),' failed.',nl,'Backtracking.',nl]),
        NB = cont,
        EB = [],
        CA = none
    ).
/*
% s
resolve2([TL|Ls], [TL|Ls], [], none) :-
    l_timeless(TL, _),
    copy_term([TL|Ls], [CTL|_]),
    \+ query(CTL),
    reduce_step.
*/

% Simplify time constraints
resolve2([tc(X)|Rest], NB, EB, CA) :-
    ground(X),
    resolve2(Rest, NB, EB, CA).
resolve2([], [], [], none).
    
% TODO
% if Fl in holds(Fl, T) is ground, then there's no need to actually create a
% new branch!

% resolve2_holds
%
resolve2_holds([holds(Fl, T)|Ls], cont, [], none) :-
    number(T), current_time(Now), T == Now,
    copy_term([holds(Fl, T)|Ls], [holds(CFl, CT)|CLs]),
    query(holds(CFl, CT)),
    \+ satisfy_all(CLs),
    write_verbose([holds(Fl, T),' but time constraints cannot be satisfied.',nl,'Backtracking.',nl]),
    reduce_step.

resolve2_holds([holds(Fl, T)|_], cont, [], none) :-
    number(T), current_time(Now), T == Now,
    copy_term(holds(Fl, T), holds(CFl, CT)),
    \+ query(holds(CFl, CT)),
    write_verbose([holds(Fl, T),' does not hold.',nl,'Backtracking.',nl]),
    reduce_step.

resolve2_holds([holds(Fl, T)|_], cont, [], none) :-
    number(T), current_time(Now), T < Now,
    write_verbose([holds(Fl, T),' was in the past!',nl,'Backtracking',nl]),
    reduce_step.

resolve2_holds([holds(Fl, T)|Ls], NB, EB, CA) :-
    %(var(T); (number(T), current_time(Now), T > Now)),
    copy_term(holds(Fl, T), holds(TFl, TT)),
    query(holds(TFl, TT)),
    copy_term([holds(Fl, T)|Ls], [holds(CFl, CT)|CLs]),
    ( find_unused(holds(CFl, CT)) ->
        satisfy_all(CLs),
        reduce_step,
        resolve2_same(CT, CLs, EB),
        write_verbose(['Bound fluent ',holds(Fl),' to ',holds(CFl),nl]),
        current_goal(GoalId),
        depth(Depth),
        assertz(tried(GoalId, Depth, state(CFl))),
        ( EB = [] ->
            NB = []
        ;%EB \= [] ->
            % it doesn't actually matter what NB is, just can't be unbound, or []
            NB = [holds(Fl, T)|Ls]
        )
        ;
        write_verbose(['All possible unifications for ',holds(Fl),' failed.',nl,'Backtracking.',nl]),
        % TODO 22 Aug 17:42
        clear_tried(holds(Fl, T)),
        NB = cont,
        EB = [],
        CA = none
    ).
    /* old comment:
    query(holds(CFl, CT)),
    */
    % check for ground here
    % so when we get here, Fl has become bound, need to track this ACROSS
    % cycles
    /*
    ( ground(Fl) ->
        ( EB = [] ->
            NB = []
        ;%EB \= [] ->
            NB = cont
        )
    */

% the only way for resolve2_same to succeed is for it to resolve all OR it
% returns some kind of happens(Act, T1, T2) where T1 is bound to Now.
%
% fluents that must hold in the same cycle as other fluents are expected to be
% written together.
%
% fluents that must hold in the same cycle as a certain action are expected to
% be written together.
%
resolve2_same(_, [], []).

resolve2_same(T1, [tc(X)|Ls], Ret) :-
    ground(X),
    resolve2_same(T1, Ls, Ret).

resolve2_same(_, [L|Ls], [L|Ls]) :-
    L \= holds(_, _).

resolve2_same(_, [holds(Fl, T)|Ls], [holds(Fl, T)|Ls]) :-
    var(T).

resolve2_same(T1, [holds(Fl, T2)|Ls], Ret) :-
    number(T2),
    ( T1 =:= T2 ->
        ( query(holds(Fl, T2)), satisfy_all(Ls) ->
            resolve2_same(T1, Ls, Ret)
        ;
            fail
        )
    ;
        Ret = [holds(Fl, T2)|Ls]
    ).

/*
resolve2_happens([happens(Ev, T1, T2)|Ls], cont, [], none) :-
    check_failed([happens(Ev, T1, T2)|Ls], N),
    write('hai: '),write(N),nl,
    reduce_step.
*/

% XXX 29 Aug 09:35 - Changed the nosusp to cont
resolve2_happens([happens(Ev, T1, T2)|Ls], cont, [], none) :-
    (number(T1);number(T2)),
    copy_term([happens(Ev, T1, T2)|Ls], [happens(CEv, CT1, CT2)|CLs]),
    query(happens(CEv, CT1, CT2)),
    \+ satisfy_all(CLs),
    reduce_step.

% TODO 22 Aug 18:11 Test
resolve2_happens([happens(Ev, T1, T2)|_Ls], cont, [], none) :-
    number(T1), current_time(Now), Prev is Now - 1, T1 = Prev,
    % unnecessary: copy_term([happens(Ev, T1, T2)|Ls], [happens(CEv, CT1, CT2)|CLs]),
    \+ query(happens(Ev, T1, T2)),
    write_verbose([happens(Ev, T1, T2),' did not happen!',nl,'Backtracking.',nl]),
    reduce_step.

resolve2_happens([happens(_, _, T2)|_], cont, [], none) :-
    number(T2), current_time(Now), T2 < Now,
    reduce_step.

resolve2_happens([happens(Ev, T1, T2)|_], cont, [], none) :-
    number(T2), current_time(Now), T2 == Now,
    copy_term(happens(Ev, T1, T2), happens(CEv, CT1, CT2)),
    \+ query(happens(CEv, CT1, CT2)),
    reduce_step.

resolve2_happens([happens(_, T1, _)|_], cont, [], none) :-
    number(T1), current_time(Now), Prev is Now - 1, T1 < Prev,
    reduce_step.

resolve2_happens([happens(Ev, T1, T2)|Ls], NB, EB, CA) :-
    number(T1), current_time(Now), T1 == Now,
    copy_term([happens(Ev, T1, T2)|Ls], [happens(CEv, CT1, CT2)|CLs]),
    % XXX 22 Aug 18:34 IF CA IS NULL --> then implies that PRECONDS FAILED
    % NEED to BACKTRACK here!!!11 -- DONE
    try_cand_act([happens(CEv, CT1, CT2)|CLs], CA),
    ( CA = none ->
        write_verbose(['Special1! Backtracking.',nl]),
        NB = cont,
        EB = []
    ;
        NB = [happens(Ev, T1, T2)|Ls],
        EB = []
    ),
    reduce_step.

resolve2_happens([happens(Ev, T1, T2)|Ls], NB, EB, CA) :-
    copy_term([happens(Ev, T1, T2)|Ls], [happens(CEv, CT1, CT2)|CLs]),
    current_goal(GoalId),
    depth(Depth),
    query(happens(CEv, CT1, CT2)),
    ( \+ tried(GoalId, Depth, happens(CEv, CT1, CT2)) ->
        satisfy_all(CLs),
        reduce_step,
        resolve2_same(CT2, CLs, EB),
        assertz(tried(GoalId, Depth, happens(Ev, T1, T2))),
        ( EB = [] ->
            NB = []
        ;%EB \= [] ->
            % doesn't matter what NB is
            % XXX 22 Aug 19:31 When the happens(Ev) binds, remove it from the
            % state! Only let it do this once.
            %retract(happens(Ev, _, _)),
            NB = [happens(Ev, T1, T2)|Ls]
        )
    ;
        clear_tried(happens(CEv, CT1, CT2)),
        % XXX 25 Aug 15:27
        % It happened, it failed, see if it can be done again next cycle.
        copy_term([happens(Ev, T1, T2)|Ls], [happens(AEv, AT1, AT2)|ALs]),
        try_cand_act([happens(AEv, AT1, AT2)|ALs], CA),
        ( CA = none ->
            write_verbose(['Special2! Backtracking.',nl]),
            NB = cont,
            EB = []
        ;
            NB = [happens(Ev, T1, T2)|Ls],
            EB = []
        )
        /*
        NB = cont,
        EB = [],
        write('aip'),nl,
        write('Backtracking NOW.'),nl
        */
    ).

resolve2_timeless([TL|Ls], NB, EB, CA) :-
    copy_term([TL|Ls], [CTL|CLs]),
    ( find_unused(l_tl(CTL), Body) ->
        copy_term(CTL-Body,CTL_-Body_), % remember the clause as found...
        % TODO: all this brutal management of backtracking should have a lighter approach...
        satisfy_all(CLs),
        reduce_step,
        query(CTL),
        write_verbose(['Calculated ',TL,' to ',CTL,nl]),
        current_goal(GoalId),
        depth(Depth),
        assertz(tried(GoalId, Depth, l_timeless(CTL_, Body_))),
        NB = [TL|Ls],
        EB = CLs,
        CA = none
        ;
        write_verbose(['All possible unifications for ',l_timeless(TL),' failed.',nl,'Backtracking.',nl]),
        clear_tried(l_tl(TL)),
        NB = cont,
        EB = [],
        CA = none
    ).

%
%
try_cand_act([happens(Ev, T1, T2)|Bs], CA) :-
    maximum_time(MaxTime),
    (
        (
        	action(Ev),
        current_time(T1), T2 is T1 + 1,
        satisfy_all(Bs),
        % T3 is T1 - 1,
        findall(
            NewConds,
            (
                d_pre(Conds),
                select(happens(Ev, T1, T2), Conds, NewConds)
            ),
            AllConds
        ),
        all_fail(AllConds, [])
        )
    ->
        find_deadline(Bs, Deadlines),sort(Deadlines, Sorted),
        ( Sorted = [Earliest|_] ->
            true
        ;
            % Earliest = 9999999999999999999
            Earliest = MaxTime
        ),
        CA = ca(Earliest, happens(Ev, T1, T2)),
        write_verbose(['Adding candidate action ',Ev,'.',nl])
    ;
        CA = none,
        write_verbose(['Could not add action ',Ev,' to candidate actions.',nl])
    ).

find_deadline([], []).

find_deadline([tc(<(X,Y))|T], [Z|Res]) :-
    \+ ground(X), ground(Y),
    bind_vars(X),
    #=(X,Z),
    #<(Z,Y),
    labeling([max(Z)], [Z]),
    find_deadline(T, Res).

/*
find_deadline([tc(<(X,Y))|T], [Z|Res]) :-
    no_vars(X), no_vars(Y),
    parse(X, RX),
    parse(Y, RY),
    Z is Y - X - 1,
    find_deadline(T, Res).
*/

find_deadline([tc(=<(X,Y))|T], [Z|Res]) :-
    \+ ground(X), ground(Y),
    bind_vars(X),
    #=(X,Z),
    #=<(Z,Y),
    labeling([max(Z)], [Z]),
    find_deadline(T, Res).

/*
find_deadline([tc(=<(X,Y))|T], [Z|Res]) :-
    no_vars(X), no_vars(Y),
    parse(X, RX),
    parse(Y, RY),
    Z is Y - X,
    find_deadline(T, Res).
*/

find_deadline([_H|T], Res) :-
    find_deadline(T, Res).

%
%
reduce_step() :-
    steps(C),
    NC is C-1,
    retract(steps(C)),
    assertz(steps(NC)).

% satisfy_all(+L) 
% check that all time constraints are not known to be unsatisfiable...
% TODO: this or some other predicate should check antecedents "solvability" properly
satisfy_all([]).

satisfy_all([tc(X)|Rest]) :-
    !,
    \+ \+ satisfy(X),
    satisfy_all(Rest).

satisfy_all([_Y|Rest]) :-
    % This won't do, we need a query(..) less eager to evaluate: \+ \+ query(Y),
    satisfy_all(Rest).

/* Dead code:
% satisfy_upper
%
satisfy_upper(L) :-
    copy_term(L, LC),
    do_satisfy_upper(LC).

%
%
do_satisfy_upper([]).

do_satisfy_upper([tc(<(X,Y))|Rest]) :-
    var(X), no_vars(Y),
    current_time(Now),
    current_prolog_flag(max_integer, Max),
    in(X, ..(Now,Max)),
    #<(X, Y),
    do_satisfy_upper(Rest).

do_satisfy_upper([tc(<(X,Y))|Rest]) :-
    no_vars(X), var(Y),
    current_time(Now),
    current_prolog_flag(max_integer, Max),
    in(Y, ..(Now,Max)),
    #<(X, Y),
    do_satisfy_upper(Rest).

do_satisfy_upper([tc(<(X,Y))|Rest]) :-
    var(X), var(Y),
    do_satisfy_upper(Rest).

do_satisfy_upper([tc(<(X,Y))|Rest]) :-
    no_vars(X), no_vars(Y),
    parse(X, RX), parse(Y, RY),
    RX < RY,
    do_satisfy_upper(Rest).

do_satisfy_upper([tc(=<(X,Y))|Rest]) :-
    var(X), no_vars(Y),
    current_time(Now),
    current_prolog_flag(max_integer, Max),
    in(X, ..(Now,Max)),
    #=<(X, Y),
    do_satisfy_upper(Rest).

do_satisfy_upper([tc(=<(X,Y))|Rest]) :-
    no_vars(X), var(Y),
    current_time(Now),
    current_prolog_flag(max_integer, Max),
    in(Y, ..(Now,Max)),
    #=<(X, Y),
    do_satisfy_upper(Rest).

do_satisfy_upper([tc(=<(X,Y))|Rest]) :-
    var(X), var(Y),
    do_satisfy_upper(Rest).

do_satisfy_upper([tc(=<(X,Y))|Rest]) :-
    no_vars(X), no_vars(Y),
    parse(X, RX), parse(Y, RY),
    RX =< RY,
    do_satisfy_upper(Rest).

do_satisfy_upper([H|Rest]) :-
    H \= tc(_),
    do_satisfy_upper(Rest).
*/

% no_vars(Exp) Exp was replaced ground(Exp)

bind_vars(Exp) :-
    var(Exp),
    current_time(Now),
    maximum_time(Max),
    in(Exp, ..(Now,Max)).

bind_vars(Exp) :-
    nonvar(Exp),
    Exp =.. L,
    do_bind_vars(L).

do_bind_vars([]).

do_bind_vars([H|T]) :-
    compound(H),
    H =.. L,
    do_bind_vars(L),
    do_bind_vars(T).

do_bind_vars([H|T]) :-
    atomic(H),
    do_bind_vars(T).

do_bind_vars([H|T]) :-
    var(H),
    current_time(Now),
    maximum_time(Max),
    in(H, ..(Now,Max)),
    do_bind_vars(T).


%
%
parse(Exp, Res) :-
    ( number(Exp) ->
        Res = Exp
    ; Exp = (L + R) ->
        parse(L, RL),
        parse(R, RR),
        Res is RL + RR
    ; Exp = (L - R) ->
        parse(L, RL),
        parse(R, RR),
        Res is RL - RR
    ; Exp = (L * R) ->
        parse(L, RL),
        parse(R, RR),
        Res is RL * RR
    ; Exp = (L / R) ->
        parse(L, RL),
        parse(R, RR),
        Res is RL / RR
    ; Exp = abs(E) ->
        parse(E, RE),
        Res is abs(RE)
    ).

% satisfy a temporal constraint
%
satisfy(<(X,Y)) :-
    \+ ground(X), ground(Y),
    bind_vars(X),
    #<(X, Y).

satisfy(<(X,Y)) :-
    ground(X), \+ ground(Y),
    bind_vars(Y),
    #<(X, Y).

satisfy(<(X,Y)) :-
    \+ ground(X), \+ ground(Y).

satisfy(<(X,Y)) :-
    ground(X), ground(Y),
    parse(X, RX), parse(Y, RY),
    RX < RY.

satisfy(=<(X,Y)) :-
    \+ ground(X), ground(Y),
    bind_vars(X),
    #=<(X, Y).

satisfy(=<(X,Y)) :-
    ground(X), \+ ground(Y),
    bind_vars(Y),
    #=<(X, Y).

satisfy(=<(X,Y)) :-
    \+ ground(X),
    \+ ground(Y).

satisfy(=<(X,Y)) :-
    ground(X), ground(Y),
    parse(X, RX), parse(Y, RY),
    RX =< RY.

% check_syntax(+File,-Notices) Returns a list of notice(Type,Message,Position)
%  Type is 'error' or 'warning', Position is some term denoting a source file location
%  Position will be 'unknown'... unless our environment provides a definition for lps_source_position/2
%  Predicates called here typically have as second argument a notices list with a single
%  element... or they simply fail
check_syntax(F,Notices) :-
	findall(N, 
		(
			( Rule = reactive_rule(A, C) ; Rule = reactive_rule(A,C,_)), % TODO: should check priority too
			Rule,
			(source_position(Rule,F,Pos), 
			(check_reactive_rule(A,Pos,[N]) ; check_reactive_rule(C,Pos,[N])))
			), 
		RR),
	findall(N, 
		(
			l_int(P, B), 
			source_position(l_int(P, B),F,Pos), 
			( 
				\+ ((nonvar(P), P = holds(_,_))), 
				buildError(P,' is not a valid intensional predicate',ET),
				N=notice(error,ET,Pos) 
				; 
				check_lp_int(B,Pos,[N])) ), 
		IP), 
	findall(N, 
		(
			l_events(P, B), 
			source_position(l_events(P, B),F,Pos),
			( 
				\+ ((nonvar(P), P = happens(_,_,_))), 
				buildError(P,' is not a valid composite event predicate',ET), 
				N=notice(error,ET,Pos) 
				; 
				check_lp_events(B,Pos,[N])) ), 
		CE),
	findall(N, (d_pre(B),source_position(d_pre(B),F,Pos),check_d(B, d_pre, Pos, [N])), PC),
	findall(N,(
		initiated(Ev, Fl, Cond), 
		source_position(initiated(Ev, Fl, Cond),F,Pos),
		(
			((nonvar(Ev), Ev = happens(Ev2, _, _)) -> 
				( d_event(Ev2) -> fail 
				; 
				buildError(Ev2,' in initiated post-condition must be a simple event (event/action) predicate',ET), 
				N=notice(error,ET,Pos)
				)
			; 
				buildError(Ev,' is not a valid domain initiated post-condition predicate',ET), 
				N=notice(error,ET,Pos)
			)
		;
			\+ d_head(Fl), 
			buildError(Fl,' in initiated post-condition must be an extensional fluent predicate',ET), 
			N=notice(error,ET,Pos)
		;
			check_d(Cond, 'D_post', Pos, [N])
		) ), 
		PostI),
	findall(N,(
		terminated(Ev, Fl, Cond), 
		source_position(terminated(Ev, Fl, Cond),F,Pos),
		(
			((nonvar(Ev), Ev = happens(Ev2, _, _)) -> 
				( d_event(Ev2) -> fail 
				; 
				buildError(Ev2,' in terminated post-condition must be a simple event (event/action) predicate',ET), 
				N=notice(error,ET,Pos)
				)
			; 
				buildError(Ev,' is not a valid domain terminated post-condition predicate',ET), 
				N=notice(error,ET,Pos)
			)
		;
			\+ d_head(Fl), 
			buildError(Fl,' in terminated post-condition must be an extensional fluent predicate',ET), 
			N=notice(error,ET,Pos)
		;
			check_d(Cond, 'D_post', Pos, [N])
		) ), 
		PostT),
	append_lists([RR,IP,CE,PC,PostI,PostT],Notices).

% buildError(BadSubterm,Message,NoticeSubterm)
buildError(X,M,subterm(X,MM)) :- concat_terms([X,M],MM).

% May call an external predicate hook to find the position
source_position(Term,F,Position) :- lps_source_position(Term,F,Position), !.
source_position(_,_,unknown).
	
% fails if errors occur:
print_errors(File) :- 
	check_syntax(File,Notices), nl,
	( 
		member(notice(Type,M,_),Notices), 
		(M=subterm(_,M_)->true;M=M_),
		write('SYNTAX '), write(Type), write(': '), writeln(M_), 
		fail 
	; Notices=[]),
	((option(priority), \+ reactive_rule(_,_,_)) 
		-> writeln('WARNING: no rules with priority present!') 
		; true),
	(( \+ option(priority), \+ reactive_rule(_,_))
		-> writeln('WARNING: no priority-less reactive rules are present!')
		; true).
	

% this may be called by environment tools; see check_syntax/2
load_check_syntax(File,Notices) :-
	cleanup,
	% Let's assume Prolog syntactic errors are reported elsewhere:
	catch(my_load_dyn(File),_E,true), 
	check_syntax(File,Notices).

	 
concat_terms(Terms,Atom) :- concat_terms(Terms,[],Codes), atom_codes(Atom,Codes).

concat_terms([T1|Tn],C,Cn) :- term_to_codes(T1,C1), append(C,C1,C2), concat_terms(Tn,C2,Cn).
concat_terms([],C,C).

check_reactive_rule([H|T], Pos, NT) :-
    reactive_conjunct(H),
    !,
    check_reactive_rule(T, Pos, NT).
check_reactive_rule([H|_], Pos, [notice(error,ET,Pos)]) :- !,
    buildError(H,' is not a valid reactive rule conjunct',ET).
check_reactive_rule(H, Pos, [notice(error,ET,Pos)]) :- \+ is_list(H),
    buildError(H,' must be a list',ET).
    
check_lp_int([H|T], Pos, NT) :-
    l_int_body(H), !,
    check_lp_int(T, Pos, NT).
check_lp_int([H|_], Pos, [notice(error,ET,Pos)]) :-
    buildError(H,' is not a valid L_int body',ET).

check_lp_events([H|T], Pos, NT) :-
    l_events_body(H), !,
    check_lp_events(T, Pos, NT).
check_lp_events([H|_], Pos, [notice(error,ET,Pos)]) :-
    buildError(H,' is not a valid L_events body',ET).

check_d([H|T], What, Pos, NT) :-
    d_body(H), !,
    check_d(T, What, Pos, NT).
check_d([H|_], What, Pos, [notice(error,ET,Pos)]) :-
    concat_terms([' is not a valid ',What,' body'],M),
    buildError(H,M,ET).
    

% assert_list
%
assert_list([]).

assert_list([H|T]) :-
    assertz(state(H)),
    assert_list(T).

%
%
pprint_goal([]).

pprint_goal([goal(_, [H|_])|Rest]) :-
    write(H),nl,
    pprint_goal(Rest).

pprint_goal([goal(_, _, [H|_])|Rest]) :-
    write(H),nl,
    pprint_goal(Rest).

% next_time()
%   Succeeds to the next time point. Destructively updates current_time/1 and
%   succ_t/2.
%
next_time() :-
    current_time(This),
    retract(current_time(This)),
    Next is This + 1,
    assertz(current_time(Next)),
    assertz(succ_t(This, Next)),
    retract(steps(_)),
    assertz(steps(1000)).

% go_lps(File,Options)  Same as go/2; for the sake of compatibility with Wei's thesis
go_lps(File,Options) :- go(File,Options).

% go_lps(File,Options)  Same as go/1
go_lps(File) :- go(File).

% go(+File)
%
go(File) :- go(File, []).

go(File, OptionsList) :-
    cleanup,
    parse_options(OptionsList),
    init_test_file(File),
    % no longer needed: datime_setrand,
    my_load_dyn(File),
    
    print_errors(File), % fails if errors occur

    (option(meta_actions) -> add_meta_reactive_rules ; true),
    ( initial_state(IS) -> assert_list(IS) ; true),
    cputime(T0),
    expand_reactive_rules,
    ( option(breadth) ->
        expand_consequents
    ;
        true
    ),
    assertz(current_time(1)),
    assertz(succ_t(0, 1)),
    assertz(steps(1000)),
    assertz(current_goal(0)),
    assertz(depth(0)),
    (option(ultra_verbose)->
    		current_prolog_flag(write_depth,Old), 
    		set_xsb_flag(write_depth,10000) % ultra_verbose only remembered for xsb
   	;true),
    cputime(T1),
    (
	cycle_options([], [], [])
	; 
	cputime(T2),
	print_statistics(T0,T1,T2),
	close_test_file(File),
	(option(ultra_verbose)->set_xsb_flag(write_depth,Old);true)
		% ultra_verbose only remembered for xsb
    	).

	 
read_obs(Obs) :-
    read(user_input, Obs),
    ( \+ is_list(Obs) ->
        write(user_error, 'ERROR: Input must be a proper list.'),nl,
        read_obs(Obs)
    ;
        true
    ).

print_statistics(T0,T1,T2) :- 
	TI is T1-T0, TotalT is T2-T0,
	current_time(Next), Cycles is Next-1,
	nl, format("** ~d cycles took ~f seconds (~f expanding rules) **\n",[Cycles,TotalT,TI]).
% parse_options(OptionsList)
%
parse_options(Options) :- 
	% when running a test the options will be imposed by the test file:
	(member(run_test,Options) -> Options=[_]; true),
	parse_options_(Options).

parse_options_([]) :- !.
parse_options_([manual|Rest]) :- !, 
    assertz(option(manual)),
    parse_options_(Rest).
parse_options_([verbose|Rest]) :- !,
    assertz(option(verbose)),
    parse_options_(Rest).
% Increase the default maximum written term depth, to avoid '...' output
parse_options_([ultra_verbose|Rest]) :- !,
    assertz(option(verbose)),
    (current_prolog_flag(dialect, xsb) 
    	-> assertz(option(ultra_verbose)) 
    	; writeln(user_error, 'WARNING: ultra_verbose option considered only for XSB Prolog ')
    	),
    parse_options_(Rest).
parse_options_([goal_strat(breadth)|Rest]) :- !,
    assertz(option(breadth)),
    parse_options_(Rest).
parse_options_([goal_strat(depth)|Rest]) :- !,
    parse_options_(Rest).
parse_options_([priority|Rest]) :- !,
    assertz(option(priority)),
    parse_options_(Rest).
parse_options_([make_test|Rest]) :- !,
	(member(manual,Rest) ->  
		writeln(user_error, 'ERROR in options: with make_test you can not use ''manual''.'), fail
		; true),
	assertz(option(make_test)),
	parse_options_(Rest).
parse_options_([run_test|Rest]) :- !,
	assertz(option(run_test)),
	parse_options_(Rest).
parse_options_([meta_actions|Rest]) :- !,
	assertz(option(meta_actions)),
	parse_options_(Rest).
parse_options_([O|Rest]) :- 
    write(user_error, 'WARNING: Ignored option '), writeln(user_error,O),
    parse_options_(Rest).

write_verbose(What) :-
    ( option(verbose) ->
        do_write(What)
    ;
        true
    ).

% init_test_file(Filename)
% Load test file for this program file  
% if not running tests does nothing
init_test_file(F) :- option(run_test), !, % guaranteed to be the only option
	load_test_file_for(F),
	lps_test_options(Options),
	% add the options:
	parse_options(Options).
init_test_file(_F).

load_test_file_for(F) :-
	test_filename(F,TF),
	catch(my_load_dyn(TF,false),E,true),
	(nonvar(E) -> 
		write(user_error, 'ERROR: could not load test file '), writeln(user_error,TF), writeln(user_error,E),
		writeln(user_error,' To obtain a test file you need to execute your program with the make_test option: go(YourFile,[make_test])'),
		fail
		; true).

% close_test_file(ProgramFile)
close_test_file(F) :- option(make_test), !,
	test_filename(F,TF),
	telling(Old), tell(TF),
	date_stamp(D),
	writeln('/*'), write('  LPS test results file generated on '), writeln(D), 
	write('  on Prolog '), current_prolog_flag(version_data,P), write(P),
	writeln(' for program file:'),
	write('  '), writeln(F), writeln('*/'), nl,
	write((:- dynamic lps_test_result/3, lps_test_result_item/3, lps_test_options/1)), writeln('.'),
	nl,
	writeln('% LPS options prior to the test:'),
	setof(O,option(O),Options),
	select(make_test,Options,RealOptions),
	write(lps_test_options(RealOptions)), writeln('.'), nl,
	writeln('% lps_test_result(Stage,Cycle,TestTerm)'),
	(lps_test_result(S,C,T), writeq(lps_test_result(S,C,T)), writeln('.'), fail ; true),
	writeln('% lps_test_result_item(Stage,Cycle,TestTerm)'),
	(lps_test_result_item(S,C,T), writeq(lps_test_result_item(S,C,T)), writeln('.'), fail ; true),
	told, tell(Old).
close_test_file(F) :- option(run_test), !,  
	test_filename(F,TF),
	nl,
	( \+ lps_failed_test(_,_) -> Result=' (ok)'; Result=' (FAILED)'),
	write('*** Tests ended with '), write(TF), write(Result), writeln(' ****').
close_test_file(_F).

% test_filename(+ProgramFile,-TestFile)
% Names the test file as the programs's plus '.lpst' (LPS test file)
test_filename(PF,TF) :- 
	expand_filename(PF,Path),
	concat_atom([Path,'.lpst'],TF).
	
% test(Stage,Cycle,Term)
% Remembers or checks that at this Stage and Cycle, Term is obtained
% Requires the Term to be a LIST
% if term size is too big an abstraction is stored, and it is NOT verified
test(Stage,Cycle,Term) :- option(make_test), !,
	is_list(Term),
	\+ \+ (( 
		numbervars(Term), length(Term,N), assert(lps_test_result(Stage,Cycle,N)),
		forall(member(Item,Term),assert_lps_test_result_item(Stage,Cycle,Item))
		)).
test(Stage,Cycle,Term) :- option(run_test), !,
	% fails if the test fails:
	( lps_test_result(Stage,Cycle,N) -> true 
	  ; 
	  	write('FAILED test '), writeln(Stage/Cycle/Term), 
	  	writeln('Missing test fact.'), 
	  	assert(lps_failed_test(lps_test_result(Stage,Cycle,Term),missing_fact)), 
	  	fail),
	findall(Item,lps_test_result_item(Stage,Cycle,Item),Test), 
	% numbervars(Test),
	( \+ \+ ((length(Term,N), /*numbervars(Term),*/ test_items_ok(Term,Test)) )
		-> true
		; 
		write('FAILED test '), writeln(Stage/Cycle/Term), write('Expected '), writeln(Test), 
		assert(lps_failed_test(lps_test_result(Stage,Cycle,Term),Test)),
		fail).
test(_,_,_).

% test_items_ok(+Actual,+Test)
test_items_ok([A|An],[lps_gigantic(Size)|Tn]) :- !,
	% Must recalculate term size after numbervars, otherwise would be different:
	\+ \+ (numbervars(A),my_term_size(A,Size_), Size_ == Size), 
	test_items_ok(An,Tn).
test_items_ok([A|An],[T|Tn]) :- !,
	variant(A,T),
	test_items_ok(An,Tn).
test_items_ok([],[]).

% assert_lps_test_result_item(Stage,Cycle,Item) Gigantic terms are abstracted as lps_gigantic(Size)
assert_lps_test_result_item(Stage,Cycle,Item) :- 
	my_term_size(Item,Size), 
	( Size > 1000 -> Item_=lps_gigantic(Size) ; Item_=Item),
	assert(lps_test_result_item(Stage,Cycle,Item_)).
	
% test all programs in the LPS examples directory tree which have a .lpst file present
test_examples :- 
	lps_examples_directory(ED),
	all_files_in(ED,'.lpst',TFiles),
	atom_codes('.lpst',LPST),
	findall(ProgramFile,(
		member(TFile,TFiles), atom_codes(TFile,Tcodes),
		append(PCodes,LPST,Tcodes),atom_codes(ProgramFile,PCodes)
		),Files),
	/*findall( ProgramFile, (
		list_directory(ED,F), atom_codes(F,FC), 
		append(PFcodes,".lpst",FC), atom_codes(PF,PFcodes),
		concat_atom([ED,'/',PF],ProgramFile)
		),
		Files),*/
	do_test_suite(Files,[run_test]).

% Suffix typically being .extension
all_files_in(Directory,Suffix,Files) :-
	(is_list(Suffix)->Suffix=SuffixCodes;atom_codes(Suffix,SuffixCodes)),
	findall( File, (
		list_directory(Directory,F), 
		F \== '.', F \== '..',
		concat_atom([Directory,'/',F],FullF),
		(is_directory(FullF) -> 
			all_files_in(FullF,Suffix,DFiles), member(File,DFiles) 
			; 
			atom_codes(F,FC), 
			append(_PFcodes,SuffixCodes,FC), 
			concat_atom([Directory,'/',F],File))
		),
		Files).

% for each .lpsw file (Wei syntax), generate its test result file
% BEWARE, this will assume the WHOLE examples subtree runs well!
build_all_test_results :- 
	lps_examples_directory(ED),
	all_files_in(ED,'.lpsw',Files),
	writeln(files-Files),
	do_test_suite(Files,[make_test,verbose]).

% do_test_suite(Files,Options)  
%  Options must contain make_test or run_test, optionally more; Files are either LPS or test result files resp.

do_test_suite(Files,Options) :-
	(member(run_test,Options);member(make_test,Options)), 
	!,
	writeln('*** Starting test suite, will report at the end...'),
	do_test_suite(Files,Options,Results),
	nl, write('*** Test suite ended ('), write(Options), writeln('):'),
	( member(F-R,Results), write(F), write(': '), writeln(R), fail; true),
	writeln('*** End of test suite results').

% do_test_suite(Files,Options,Results)  Results is a list of File - ok/failed
do_test_suite([],_Option,[]) :- !.
do_test_suite([F|Files],Options,[F-R|Results]) :- 
	expand_filename(F,Path),
	go(Path,Options),
	( \+ lps_failed_test(_,_) -> R=ok 
	; 
	findall(LPSR/Expected,lps_failed_test(LPSR,Expected),Failures), R=failed(Failures) 
	),
	do_test_suite(Files,Options,Results).
	

do_write([]).

do_write([pprint_goal(What)|Rest]) :- !,
    pprint_goal(What),
    do_write(Rest).

do_write([nl|Rest]) :- !,
    nl,
    do_write(Rest).

do_write([What|Rest]) :- !,
    write(What),
    do_write(Rest).

pick_highest_tier(NGi_P, NGi, RGi) :-
    sort(NGi_P, NGi_P_sorted),
    reverse(NGi_P_sorted, [goal(P, GoalId, G)|OtherGoals]),
    Lower is (P // 10) * 10,
    pick_highest_tier2(Lower, [goal(P, GoalId, G)|OtherGoals], NGi, RGi).

pick_highest_tier2(_, [], [], []).

pick_highest_tier2(Lower, [goal(P, GoalId, G)|OtherGoals], [goal(P, GoalId, G)|NGi], RGi) :-
    P >= Lower,
    pick_highest_tier2(Lower, OtherGoals, NGi, RGi).

pick_highest_tier2(Lower, [goal(P, GoalId, G)|OtherGoals], [], [goal(P, GoalId, G)|OtherGoals]) :-
    P < Lower.

% add rules to trigger "meta" actions which document the occurrence of composite events
add_meta_reactive_rules :-
	forall( l_events(E,_), 
		assert( reactive_rule([E],[happens(lps_meta(E),_T3,_)]) ) ),
	assert(action(lps_meta(_))).
	
% cleanup
%
cleanup :-
    retractall(action(_)),
    % retractall(cacts(_)),
    retractall(current_goal(_)),
    retractall(current_time(_)),
    retractall(d_pre(_)),
    retractall(depth(_)),
    retractall(event(_)),
    retractall(expanded_consequent(_,_)),
    retractall(failed(_, _, _)),
    retractall(fluent(_)),
    retractall(happens(_, _, _)),
    retractall(initial_state(_)),
    retractall(initiated(_, _, _)),
    retractall(l_events(_, _)),
    retractall(l_int(_, _)),
    retractall(l_timeless(_, _)),
    retractall(observe(_, _)),
    retractall(option(_)),
    retractall(reactive_rule(_, _)),
    retractall(reactive_rule(_, _, _)),
    retractall(state(_)),
    retractall(steps(_)),
    retractall(succ_t(_, _)),
    % retractall(susp(_)),
    retractall(terminated(_, _, _)),
    retractall(tried(_, _, _)),
    retractall(used(_)),
    reset_goal_ids,
    % retractall(this_initiated(_)),
    retractall(lps_failed_test(_,_)),
    retractall(lps_test_result(_,_,_)),
    retractall(lps_test_result_item(_,_,_)),
    retractall(lps_test_options(_)).

my_event(X) :- event(X).
my_event(X) :- action(X).
    
% cycle_options(CandidateActions,PartialReactiveRules,GoalState)
%  GoalState is a list (conjunction) of goal(Id,Tree)
cycle_options(CAi, Ri, Gi) :-
    current_time(Time),
    retractall(happens(_, _, _)),
    enter_step_0, % during "Update the current state" we need a hack to query the previous state
    nl,
    write_verbose(['====================',nl]),
    write('* Cycle '),write(Time),write(' *'),nl,
    write_verbose(['====================',nl,nl]),
    StageO='Observations:',
    ( (option(manual) ->read_obs(Observations);observe(Observations, Time)) -> true 
      ; writeln('* No more observations, terminating.'), fail ),
    write_verbose([StageO,nl,Observations,nl,nl]), test(StageO,Time,Observations),
    update_all(Observations),
    StageCA='Candidate actions:',
    write_verbose([StageCA,nl,CAi,nl,nl]), test(StageCA,Time,CAi),
    sort(CAi, SortedCAi),
    select_actions(SortedCAi, [], Actions),
    % retractall(this_initiated(_)),
    StageSA='Selected actions:',
    write_verbose([StageSA,nl,Actions,nl,nl]), test(StageSA,Time,Actions),
    leave_step_0,
    findall(Fl, state(Fl), State),
    StageDS='Database state:',
    write_verbose([StageDS,nl,State,nl,nl]), test(StageDS,Time,State),
    ( option(priority) ->
        process_priority(Ri, NRi, Gi, NGi_P)
    ;
        process(Ri, NRi, Gi, NGi)
    ),!,
    ( option(priority) ->
        pick_highest_tier(NGi_P, NGi, RGi)
    ;
        true
    ),
    StageNPRR='New partial reactive rules:',
    write_verbose([StageNPRR,nl,NRi,nl,nl]), test(StageNPRR,Time,NRi),
    StageNG = 'New goals:',
    write_verbose([StageNG,nl,pprint_goal(NGi),nl]), test(StageNG,Time,NGi),
    write('********************'),nl,nl,
    ( option(priority) ->
        ( option(breadth) ->
            resolve_tree_breadth_prio(NGi, [], NewGi, [], CA)
        ;
            resolve_tree_prio(NGi, [], NewGi, [], CA)
        ),
        append(NewGi, RGi, NextGi)
    ;
        ( option(breadth) ->
            resolve_tree_breadth(NGi, [], NextGi, [], CA)
        ;
            resolve_tree(NGi, [], NextGi, [], CA)
        )
    ),
    write('********************'),nl,nl,
    StageRG='Resolved goals:',
    ( NextGi = [] ->
        write(StageRG),nl,write(NextGi),nl
    ;
        write(StageRG),nl,pprint_goal(NextGi),nl
    ),
    test(StageRG,Time,NextGi),
    !,
    next_time,
    cycle_options(CA, NRi, NextGi).


%% Follows the contents of the old preprocessos.pl file:

% fluent_pred(+Fl)
%   True if Fl is a fluent predicate symbol.
%
fluent_pred(Fl) :-
    % Extensional predicates, represent facts in the state S_i.
    fluent(Fl).
fluent_pred(not(Fl)) :-
    fluent(Fl).
fluent_pred(Fl) :-
    % Intensional predicates, defined in L_int.
    functor(Fl,F,N), functor(Fll,F,N),
    l_int(holds(Fll, _), _).
fluent_pred(not(Fl)) :-
    l_int(holds(Fl, _), _).


% event_pred(+Ev)
%   True if Ev is an event predicate symbol.
%
event_pred(Ev) :-
    % Simple event predicates, externally generated events.
    my_event(Ev).
event_pred(Ev) :-
    % Simple event predicates, internally generated actions.
    action(Ev).
event_pred(Ev) :-
    % Composite event predicates, defined in L_events.
    functor(Ev,F,N), functor(Evv,F,N),
    l_events(happens(Evv, _, _), _).


% temp_constraint(+Term)
%   True if Term is an atomic temporal constraint formula.
%
temp_constraint(<(_,_)).
temp_constraint(=<(_,_)).


% reactive_conjunct(+Conj)
%   True if Conj is a valid conjunct in the antecedent or consequent of a
%   reactive rule.
%
reactive_conjunct(holds(P, _)) :-
    functor(P,F,N), functor(PP,F,N),
    fluent_pred(PP).
reactive_conjunct(X) :-
    X \= holds(_, _),
    X \= happens(_, _, _),
    X \= tc(_),
    l_timeless(X, _).
reactive_conjunct(happens(E, _, _)) :-
    event_pred(E).
reactive_conjunct(tc(T)) :-
    temp_constraint(T).


/* Dead code; and seems unfineshed anyway
% l_timeless_body(P)
%
l_timeless_body(P) :-
    \+ holds(_, _), 
    \+ happens(_, _, _).
*/

% l_int_body(+P)
%
l_int_body(holds(P, _)) :-
    functor(P,F,N), functor(PP,F,N),
    fluent_pred(PP).
l_int_body(P) :-
    functor(P,F,N), functor(PP,F,N),
    l_timeless(PP, _).


% l_events_body(+P)
%
l_events_body(holds(P, _)) :-
    functor(P,F,N), functor(PP,F,N),
    fluent_pred(PP).
l_events_body(P) :-
    functor(P,F,N), functor(PP,F,N),
    l_timeless(PP, _).
l_events_body(happens(P, _, _)) :-
    functor(P,F,N), functor(PP,F,N),
    event_pred(PP).
l_events_body(tc(P)) :-
    temp_constraint(P).


% d_head(+H)
%
d_head(H) :-
    fluent(H).

% d_event(+H)
%
d_event(H) :-
    my_event(H).


% d_body(+B)
%
d_body(happens(B, _, _)) :-
    my_event(B).
d_body(holds(not(B), _)) :-
    fluent(B).
d_body(holds(B, _)) :-
    fluent(B).
d_body(B) :-
    functor(B,F,N), functor(BB,F,N),
    l_timeless(BB, _).