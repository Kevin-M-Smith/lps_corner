/* 
LPS Interpreter, by Bob Kowalski and Fariba Sadri. 
Contributions by David Wei and Miguel Calejo.

Copyright (c) 2016, Imperial College, London
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

1. Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

% RAK interpreter, based partly on Wei's interpreter. November-December
% 2016.

%%% LOAD THIS FILE to start LPS

:- module(interpreter, [
	go/0, go/1, go/2, go/3,
	test_examples/0, build_all_test_results/0, do_test_suite/2, load_test_file_for/1, regenerate_file/1,
	load_check_syntax/2, print_error/3, my_term_to_atom/2, collect_current_fluents/2, collect_current_actions/2, collect_guessed_declarations/1,
	intensional/1,macroaction/1,d_event/1,
	lps_engine_directory/1, uassert/1, uretractall/1,
	bindAllVars/1, lps_welcome_message/0, endTime/1]).

% This fact will contain this file's directory; its presence also denotes "LPS running"
:- dynamic lps_engine_directory/1.

%%% XSB specific section:
:- if(current_prolog_flag(dialect, xsb)).

:- consult:current_loaded_file(F), parse_filename(F,D,_,_), retractall(lps_engine_directory(_)), assert(lps_engine_directory(D)).
:- lps_engine_directory(D), string:concat_atom([D,'../engine/db.P'],DB), ensure_loaded(DB).

:- use_module(db,[ d/2,
	action/1, current_time/1, d_pre/1, event/1,
	fluent/1, happens/3, (initiated)/3, l_events/2, l_int/2,
	l_timeless/2, (observe)/2, reactive_rule/2, reactive_rule/3, state/1,
	steps/1, (terminated)/3, used/1, maxTime/1,
	current_goal/1, depth/1, tried/3, option/1, initial_state/1, lps_updating_current_state/0,
	lps_test_result_item/3, lps_test_result/3, lps_test_options/1, 
	lps_failed_test/2,
	(events)/1, (fluents)/1, (actions)/1,
	my_load_dyn/2, head_hint/3]).

:- use_module(usermod,[lps_source_position/4]). % support Prolog Studio error reporting

% assert in usermod, if X imported from there... see SWI comment below
uassert(X) :- assert(X). 
uassertz(X) :- assertz(X).
uretract(X) :- retract(X).
uretractall(X) :- retractall(X).
u_user_predicate(X) :- functor(X,F,N), current_predicate(F/N).
callprolog(G) :- catch(G,_,fail).

:- use_module(basics, [length/2, member/2, append/3, select/3, reverse/2]).
:- use_module(lists, [append_lists/2]).
:- use_module(subsumes,[variant/2]).
:- use_module(num_vars,[numbervars/1]).
:- use_module(string,[concat_atom/2, term_to_codes/2]).
:- use_module(format,[format/2]).
:- use_module(standard,[datime/1]).
date_stamp(D) :- datime(Date), fmt_write_string(D,"%d-%02d-%02d at %02d:%02d:%02d",Date).

:- use_module(shell,[list_directory/2, is_directory/1]).

lps_examples_directory(ED) :- 
	lps_engine_directory(D), 
	concat_atom([D,'/../examples'], E), expand_filename(E,ED).

my_term_to_codes(T,C) :- atomize_zero_functors(T,NT), term_to_codes(NT,C).

% atomize_zero_functors(+Term,-NewTerm) replaces subterms foo() by 'foo'
% turnaround to bug reported by Miguel to XSB folks on May 24, 2016
atomize_zero_functors(T,NT) :- var(T), !, NT=T.
atomize_zero_functors(T,NT) :- functor(T,F,0), atom(F), !, NT=F.
atomize_zero_functors(T,NT) :- atomic(T), !, NT=T.
atomize_zero_functors([T1|Tn],[NT1|NTn]) :- !, atomize_zero_functors(T1,NT1), atomize_zero_functors(Tn,NTn).
atomize_zero_functors(T,NT) :- T=..[F|Args], atomize_zero_functors(Args,NewArgs), NT=..[F|NewArgs].

my_term_to_atom(T,A) :- my_term_to_codes(T,C), atom_codes(A,C).

print_error(Type,Message,_Position) :- write('OTHER '), write(Type), write(': '), writeln(Message).
print_syntax_error(Type,Message,_Position) :- write('SYNTAX '), write(Type), write(': '), writeln(Message).


lps_welcome_message.

% No time limit on XSB; may be however implementable with timed_call and friends;
% should throw 'time_limit_exceeded' 
% http://www.swi-prolog.org/pldoc/doc_for?object=call_with_time_limit/2 
call_with_time_limit(_Time, Goal) :- Goal.

:- endif.

%%% end of XSB specific section; now for SWI:

:- if((current_prolog_flag(dialect, swi), current_module(swish))).

% First a SWISH specificity - rather than use the db module, will use pengine's dynamic module

:- use_module(library(pengines),[pengine_self/1]).

% If performance becomes bad (due to nonindexed access inside the pengine_self predicate) we should pass M as arg
% Implementation note: execution specific states (cf. cleanup_engine) might be stored instead by simply using thread_local declarations

d(X,Props) :- pengine_self(M), catch(M:d(X,Props),_,fail).
action(X) :- pengine_self(M), catch(M:action(X),_,fail).
current_goal(X) :- pengine_self(M), M:current_goal(X).
current_time(X) :- pengine_self(M), M:current_time(X).
lps_updating_current_state :- pengine_self(M), catch(M:lps_updating_current_state,_,fail).
d_pre(X) :- pengine_self(M), catch(M:d_pre(X),_,fail).
depth(X) :- pengine_self(M), catch(M:depth(X),_,fail).
event(X) :- pengine_self(M), catch(M:event(X),_,fail).
fluent(X) :- pengine_self(M), catch(M:fluent(X),_,fail).
happens(X,Y,Z) :- pengine_self(M), catch(M:happens(X,Y,Z),_,fail).
initial_state(X) :- pengine_self(M), catch(M:initial_state(X),_,fail).
initiated(X,Y,Z) :- pengine_self(M), catch(M:initiated(X,Y,Z),_,fail).
l_events(X,Y) :- pengine_self(M), catch(M:l_events(X,Y),_,fail).
l_int(X,Y) :- pengine_self(M), catch(M:l_int(X,Y),_,fail).
l_timeless(X,Y) :- pengine_self(M), catch(M:l_timeless(X,Y),_,fail).
maxTime(X) :- pengine_self(M), catch(M:maxTime(X),_,fail).
observe(X,Y) :- pengine_self(M), catch(M:observe(X,Y),_,fail).
% TODO: interference with SWI ???
option(X) :- pengine_self(M), catch(M:option(X),_,fail).
reactive_rule(X,Y) :- pengine_self(M), catch(M:reactive_rule(X,Y),_,fail).
reactive_rule(X,Y,Z) :- pengine_self(M), catch(M:reactive_rule(X,Y,Z),_,fail).
state(X) :- pengine_self(M), catch(M:state(X),_,fail).
steps(X) :- pengine_self(M), M:steps(X).
terminated(X,Y,Z) :- pengine_self(M), catch(M:terminated(X,Y,Z),_,fail).
tried(X,Y,Z) :- pengine_self(M), catch(M:tried(X,Y,Z),_,fail).
used(X) :- pengine_self(M), catch(M:used(X),_,fail).
lps_test_options(X) :- pengine_self(M), catch(M:lps_test_options(X),_,fail).
lps_test_result_item(X,Y,Z) :- pengine_self(M), catch(M:lps_test_result_item(X,Y,Z),_,fail).
lps_test_result(X,Y,Z) :- pengine_self(M), catch(M:lps_test_result(X,Y,Z),_,fail).
lps_failed_test(X,Y) :- pengine_self(M), catch(M:lps_failed_test(X,Y),_,fail).
events(X) :- pengine_self(M), catch(M:events(X),_,fail).
fluents(X) :- pengine_self(M), catch(M:fluents(X),_,fail).
actions(X) :- pengine_self(M), catch(M:actions(X),_,fail).
% probably not used:
my_load_dyn(X,Y) :- pengine_self(M), M:my_load_dyn(X,Y).

uassert(X) :- pengine_self(M), catch(assert(M:X),_,true). 
uassertz(X) :- pengine_self(M), catch(assertz(M:X),_,true).
% uretractall(X) :- pengine_self(M), catch(retractall(M:X),_,true).
uretractall(X) :- pengine_self(M), retractall(M:X).
uretract(X) :- pengine_self(M), retract(M:X).
u_user_predicate(X) :- functor(X,F,N),  pengine_self(M), current_predicate(M:F/N).
callprolog(G) :- predicate_property(G,built_in), !, catch(G,_E,fail). % TODO: should print error message before failing
callprolog(G) :- pengine_self(M), catch(call(M:G),_,fail).

u_swiclause(H,B,Ref) :- pengine_self(M), clause(M:H,B,Ref).
:- endif.


:- if((current_prolog_flag(dialect, swi), \+ current_module(swish))).
% Now support for vanilla SWI Prolog
:- use_module('../engine/db.P',[d/2,
	action/1, current_time/1, d_pre/1 ,event/1,
	fluent/1, happens/3, (initiated)/3, l_events/2, l_int/2,
	l_timeless/2, (observe)/2, reactive_rule/2, reactive_rule/3, state/1,
	steps/1, (terminated)/3, used/1, maxTime/1,
	current_goal/1, depth/1, tried/3, option/1, lps_updating_current_state/0,
	initial_state/1,
	lps_test_result_item/3, lps_test_result/3, lps_test_options/1, 
	lps_failed_test/2,
	(events)/1, (fluents)/1, (actions)/1,
	my_load_dyn/2,
	head_hint/3]).

uassert(X) :- assert(db:X). 
uassertz(X) :- assertz(db:X).
uretractall(X) :- retractall(db:X).
uretract(X) :- retract(db:X).
u_user_predicate(X) :- functor(X,F,N), current_predicate(db:F/N).

callprolog(G) :- predicate_property(G,built_in), !, catch(G,_E,fail). % TODO: should print error message before failing
callprolog(G) :- catch(db:G,_,fail).

u_swiclause(H,B,Ref) :- clause(db:H,B,Ref).

:- endif.

:- if(current_prolog_flag(dialect, swi)).
% ...and finally the generic SWI support

:- prolog_load_context(directory, D), retractall(lps_engine_directory(_)), assert(lps_engine_directory(D)).

:- op(900,fy,not).

:- use_module(library(lists), [member/2, append/3, select/3, reverse/2]).
:- use_module(library(prolog_clause),[clause_info/5]).
:- use_module(library(time)).

append_lists([],[]).
append_lists([X|Xs],L) :-
	append(X,T,L),
	append_lists(Xs,T).
:- use_module(library(terms),[variant/2]).
:- use_module(library(varnumbers),[numbervars/1]).
term_to_codes(T,C) :- term_to_atom(T,A), atom_codes(A,C).
my_term_to_atom(T,A) :- term_to_atom(T,A).
concat_atom(L,A) :- atomic_list_concat(L,A).
%:- use_module(format,[format/2]).
:- use_module(library(dialect/sicstus/system),[datime/1,file_exists/1]).
date_stamp(D) :- datime(Date), Date=..[_|Args], format(atom(D),"~d-~d-~d at ~d:~d:~d",Args).

list_directory(D,F) :- directory_files(D,Files), member(F,Files).
is_directory(D) :- exists_directory(D).
expand_filename(F,Path) :- expand_file_name(F,[Path]).

:- use_module(library(filesex),[relative_file_name/3]).
lps_examples_directory(ED) :- 
	lps_engine_directory(D), 
	concat_atom([D,'/'],DD), % hack, don't know where to fetch OS-dependent separator
	relative_file_name(ED,DD,'../examples').

cputime(T) :- T is cputime.

% NO LONGER returns Pos as in http://www.swi-prolog.org/pldoc/man?predicate=read_term/2 (subterm_positions)
% returns Pos as file(File,LineNumber,_one,_Char) - one line is known
lps_source_position(Term,FileWithExt,file(FileWithExt,LineNumber,_One,_Char),Vars) :- 
	functor(Term,F,N), functor(Term_,F,N), 
	u_swiclause(Term_,Body,Ref), 
	variant(Term,Term_),
	!,
	% clause_info(Ref,FileWithExt,Pos,_VO).
	clause_info(Ref, FileWithExt, _TermPos, _VarOffsets, [variable_names(Vars)]),
	term_variables((Term_:-Body),VarValues), 
	Term=Term_,
	bindAllVars(VarValues,Vars),
	clause_property(Ref,line_count(LineNumber)).

:- multifile prolog:message//1.
prolog:message(lps_error(M, _)) --> [ 'LPS: ~w'-[M]].
                
print_syntax_error(Type,Message,Position) :- 
	print_message(Type,error(syntax_error(Message),Position)). % SWI's universal messaging pipeline

print_error(Type,Message,Position) :- 
	print_message(Type,lps_error(Message,Position)). % SWI's universal messaging pipeline


:- dynamic git_version_cache/1.
:- use_module(library(git),[git_describe/2]).
lps_welcome_message :-
	lps_engine_directory(D),
	(git_version_cache(V) -> true ; git_describe(V,[directory(D)]), assert(git_version_cache(V))),
	concat_atom(['LPS version ',V],M), writeln(M).


%% Now for an implementation available only on SWI:

% resolveUntilAction(Goal) 
% Execute goal until finding a literal that needs delaying or parallel execution, 
% then calls shift(...), suspending computation; shift's argument conveys the reason for suspending:
% - a fluent or action was found that needs delaying
% - a timeless goal, a fluent or action subgoal has more than one solution; by default (e.g. unless option(no_parallel)),
%   all solutions to these are used in paralell, adding new goals to the "goal tree", that include the full continuation;
%   see dc_resolve_goals_suspended/6 below; when one of these goals succeeds the others are marked discardable, and thus ignored 
%
resolveUntilAction(V) :- var(V), !, throw(lps_var_goal). % a bug somewhere!
resolveUntilAction([]) :- !.
resolveUntilAction([G1|Gn]) :- !, 
	resolveUntilAction(G1), resolveUntilAction(Gn).
resolveUntilAction((G1,Gn)) :- !, % this for convenience in dc_resolve_goals_suspended
	resolveUntilAction(G1), resolveUntilAction(Gn).
% resolveUntilAction(Goal) :- write_verbose(['  ',Goal,nl]), fail.  % uncomment for debugging
% fluents:
resolveUntilAction(G) :- 
	(G = not(holds(_F,T)) ; G = holds(_F,T)), 
	nonvar(T), current_time(Now), T>Now, % premature, delay
	!, 
	shift(later(G)), resolveUntilAction(G).
resolveUntilAction(not(holds(F,T))) :- query(not(holds(F,T))).
resolveUntilAction(holds(F,T)) :- option(no_parallel), query(holds(F,T)).
resolveUntilAction(holds(F,T)) :- % spawn a new disjunctive goal for each fluent answer:
	\+ option(no_parallel),
	findall(holds(F,T),query(holds(F,T)),Answers), Answers\=[],
	(Answers = [holds(F,T)] -> true ; shift(disjunction(holds(F,T),Answers))).
resolveUntilAction(holds(F,T)) :- !, var(T), % on failure, delay if that makes sense
	shift(later(holds(F,T))), resolveUntilAction(holds(F,T)).
% events/actions:
resolveUntilAction(happens(E,T1,T2)) :- 
	(nonvar(T1)/*heuristic condition dispensing parallelism*/ ; option(no_parallel)), 
	macroaction(E), 
	!,
	l_events(happens(E,T1,T2),Body), resolveUntilAction(Body).
resolveUntilAction(happens(E,T1,T2)) :- macroaction(E), !, % general case, spawn disjuntive goals
	findall(l_events(happens(E,T1,T2),Body),  l_events(happens(E,T1,T2),Body), Alternatives), Alternatives\=[],
	(Alternatives = [l_events(happens(E,T1,T2),Body)] -> 
		resolveUntilAction(Body) 
		; shift(l_events_disjunction(l_events(happens(E,T1,T2),Body),Alternatives))
	).
resolveUntilAction(happens(_E,T1,T2)) :- % outdated action, we fail
	current_time(Now),
	(nonvar(T1),T1<Now ; nonvar(T2),T2<Now+1), 
	!, fail. 
resolveUntilAction(happens(E,T1,T2)) :- % premature, we delay
	current_time(Now), 
	(nonvar(T1), T1>Now ; nonvar(T2),T2>Now+1), 
	!,
	shift(later(happens(E,T1,T2))), 
	resolveUntilAction(happens(E,T1,T2)). 
resolveUntilAction(happens(E,T1,T2)) :- happens(E,T1,T2).
resolveUntilAction(happens(E,T1,T2)) :- % select action:
	\+ happens(E,T1,T2), 
	current_time(T1), 
	T2 is T1+1,
	action_(E), uassertz(happens(E,T1,T2)), 
	( (d_pre(Conds),holds_all(Conds)) -> % inadmissible action, undo it:
		uretractall(happens(E,T1,T2)), fail 
		; true),
	(true ; uretractall(happens(E,T1,T2)), fail). % undo on backtracking
resolveUntilAction(happens(E,T1,T2)) :- !, 
	(var(T1),var(T2)), % worth delaying
	\+ happens(E,T1,T2),
	action_(E), 
	shift(later(happens(E,T1,T2))),
	resolveUntilAction(happens(E,T1,T2)).
% timeless and time constraints:
resolveUntilAction(tc(G)) :- ground(G), G.
resolveUntilAction(tc(G)) :- !, \+ ground(G), shift(later(tc(G))), resolveUntilAction(tc(G)).
resolveUntilAction(call_continuation(G)) :- !, call_continuation(G).
% TODO: should we deprecate/remove l_timeless ?
resolveUntilAction(G) :- option(no_parallel), !, 
	(\+l_timeless(G,_Body) -> callprolog(G) ; l_timeless(G,Body), evaluate(Body)).
resolveUntilAction(G) :- 
	findall(G, ( \+l_timeless(G,Body) -> callprolog(G) ; l_timeless(G,Body), evaluate(Body)), Answers), Answers\=[],
	(Answers = [G] -> true ; shift(disjunction(G,Answers))).


% dc_resolve_goals(+Goals,-NewGoals) Alternative implementation of resolve_tree, used with option(dc)
% Based on SWI's delimited continuations (reset/shift, cf. http://www.swi-prolog.org/pldoc/man?section=delcont )
% Continuations allow us to push down to the engine maintenance of backtracking, which resolve_tree implements explicitly
% Goals is list of goal(Discard,G):
% if Discard==yes, some alternative to G was solved, we can ignore G; 
% if Discard is a variable, G is one of several alternatives still under consideration; 
% if Discard==non_discardable, it's a "normal" goal
% Fails if all Goals can not be solved with admissible actions
dc_resolve_goals([],[]) :- !.
dc_resolve_goals([goal(Discard,_G)|Goals],NewGoals) :- Discard == yes, !, % some alternative already succeeded! we can drop this goal
	dc_resolve_goals(Goals,NewGoals).
dc_resolve_goals(_Unfinished, end):-
	steps(N), N < 1, !.
dc_resolve_goals([goal(Discard,G)|Goals],NewGoals) :-
	write_verbose(['Goal is ',G,'.',nl]),
	reset(resolveUntilAction(G),Ball,Continuation),
	(true;write_verbose(['BACKTRACKING into previous goal ',G,nl]),fail),
	(Continuation==0 -> % resolved G completely:
		dc_resolve_goals(Goals,NewGoals) 
	; % we suspended the execution:
		% writeln('CONTINUATION:'), write_continuations(Continuation), nl, % uncomment for debugging
		dc_resolve_goals_suspended(G,Discard,Goals,Ball,Continuation,NewGoals)
	).
dc_resolve_goals([goal(Discard,G)|Goals],[goal(Discard,G)|NewGoals]) :- % do NOT retry the failed goal later...
	write_verbose(['FAILED resolveUntilAction for ',G,' (',Discard,')',nl]),
	Discard \== non_discardable, % disjunctive alternatives can stay, otherwise we backtrack
	dc_resolve_goals(Goals,NewGoals).
	
% Decide what to do, depending on the cause of suspension
% dc_resolve_goals_suspended(+GoalWithSuspendedSubgoal,?Discard,+MoreGoals,+Ball,+Continuation,-NewGoals)
dc_resolve_goals_suspended(_TopG,Discard,Goals,later(G),Continuation,NewGoals) :- !,
	write_verbose([' Delayed ',G, /* ' while executing ',_TopG,*/ nl]),
	dc_resolve_goals(Goals,NewGoals_),
	%NewGoals = [goal(Continuation)|NewGoals_].
	append(NewGoals_,[goal(Discard,Continuation)],NewGoals). % push it to end of queue
dc_resolve_goals_suspended(_G,_,Goals,disjunction(SuspendedG,Answers),Continuation,NewGoals) :-
	% build new goals, including the common Continuation albeit reflecting the different bindings in Answers,
	% and ending with the setting of the common variable Discard
	findall(goal(Discard,(Continuation,Discard=yes)), member(SuspendedG,Answers), ExtraGoals),
	bind_discarders(ExtraGoals,Discard),
	length(ExtraGoals,N),
	write_verbose([' Spawning ',N,' disjunctive goals because of ',SuspendedG, nl]),
	append(ExtraGoals,Goals,Goals_),
	dc_resolve_goals(Goals_,NewGoals).
dc_resolve_goals_suspended(_G,_,Goals,l_events_disjunction(l_events(happens(E,T1,T2),Body),Answers),Continuation,NewGoals) :-
	% similar to the previous clause, except that in addition to different bindings there are different Body terms to consider:
	findall(goal(Discard,(Body,Continuation,Discard=yes)), member(l_events(happens(E,T1,T2),Body),Answers), ExtraGoals),
	bind_discarders(ExtraGoals,Discard),
	length(ExtraGoals,N),
	write_verbose([' Spawning ',N,' disjunctive goals because of ',l_events(happens(E,T1,T2),Body), nl]),
	append(ExtraGoals,Goals,Goals_),
	dc_resolve_goals(Goals_,NewGoals).

bind_discarders([goal(Discard,_)|Goals],Discard) :- !, bind_discarders(Goals,Discard).
bind_discarders([],_Discard).

write_continuations(call_continuation(L)) :- write_continuations_(L).
write_continuations_([]) :- !.
write_continuations_(['$cont$'(Clause,  _PC,   Environment)|Continuations]) :- 
	clause(H,B,Clause), writeln((H:-B)/Environment), write_continuations_(Continuations).

:- endif.

%%% end of SWI and Prolog engine-specific code

%%% From here on, generic Prolog code

my_load_dyn(F) :- my_load_dyn(F,false).

% my_term_size(Item,Size)  
% could use XSB's native term_size, but I was having troublbuildEe aligning it with the following for SWI, so...
my_term_size(T,1) :- var(T), !.
my_term_size([T|TT],N) :- !, my_term_size(T,N1), my_term_size(TT,N2), N is N1+N2.
my_term_size([],1) :- !.
my_term_size(T,1) :- atomic(T), !.
my_term_size(T,N) :- T=..[_|L], my_term_size(L,N2), N is N2+1.

% Suffix typically being .extension
% collects all files in Directory subtree, recursively
all_files_in(Directory,Suffix,Files) :-
	(is_list(Suffix)->Suffix=SuffixCodes;atom_codes(Suffix,SuffixCodes)),
	findall( File, (
		list_directory(Directory,F), 
		F \== '.', F \== '..',
		concat_atom([Directory,'/',F],FullF),
		(is_directory(FullF) -> 
			all_files_in(FullF,Suffix,DFiles), member(File,DFiles) 
			; 
			atom_codes(F,FC), 
			append(_PFcodes,SuffixCodes,FC), 
			concat_atom([Directory,'/',F],File))
		),
		Files).

% for each .lpsw file (Wei syntax), generate its test result file
% BEWARE, this will assume the WHOLE examples subtree runs well!
build_all_test_results :- 
	lps_examples_directory(ED),
	all_files_in(ED,'.lpsw',Files),
	writeln('Generating test results for files:'), writeln(Files),
	do_test_suite(Files,[make_test,verbose]).

% add rules to trigger "meta" actions which document the occurrence of composite events
add_meta_reactive_rules :-
	forall( l_events(E,_), 
		uassert( expanded_reactive_rule([E],[happens(lps_meta(E),_T3,_)]) ) ),
	uassert(action(lps_meta(_))). % No swish support, needs revision!
	
% Clean up execution of a single LPS program.
cleanup_engine :- 
    uretractall(expanded_reactive_rule(_,_)),
    uretractall(expanded_reactive_rule(_,_,_)),
    uretractall(current_goal(_)),
    uretractall(current_time(_)),
    uretractall(depth(_)),
    uretractall(expanded_consequent(_,_)),
    uretractall(failed(_, _, _)),
    uretractall(happens(_, _, _)),
    uretractall(state(_)),
    uretractall(steps(_)),
    uretractall(tried(_, _, _)),
    uretractall(used(_)),
    % uretractall(this_initiated(_)),
    uretractall(lps_failed_test(_,_)),
    uretractall(lps_test_result(_,_,_)),
    uretractall(lps_test_result_item(_,_,_)),
    uretractall(lps_test_options(_)).

% Clear an LPS program to run another LPS program.
cleanup_program :- option(swish), !. % program is loaded into dynamic module
cleanup_program :-
    uretractall(actions(_)),
    uretractall(action(_)),
    uretractall(d_pre(_)),
    uretractall(events(_)),
    uretractall(event(_)),
    uretractall(fluents(_)),
    uretractall(fluent(_)),
    uretractall(initial_state(_)),
    uretractall(initiated(_, _, _)),
    uretractall(l_events(_, _)),
    uretractall(l_int(_, _)),
    uretractall(l_timeless(_, _)),
    uretractall(observe(_, _)),
    uretractall(reactive_rule(_, _)),
    uretractall(reactive_rule(_, _, _)),
    uretractall(terminated(_, _, _)),
    uretractall(maxTime(_)).


% obtained from Kowalski's gorak 
%
% go(+File)
%
go(File) :- go(File, []).

go :- go(_,[swish]). % makes sense only on swish

go(File, OptionsList) :- go(File, OptionsList,[]).

% ResultFluents is a list of Fluent-Instances, obtained at the end of execution in the final state
%  Instances is a list (ordered by setof)
go(File, OptionsList, ResultFluents) :-
	forall(member(RF,ResultFluents), (nonvar(RF), RF=_-_)),
	parse_options(OptionsList),
	(nonvar(File) -> true; 
			( (option(make_test), \+ option(swish)) -> writeln(user_error, 'ERROR in options: make_test requires a File name'), fail 
			; true)),
	cleanup_program, cleanup_engine,
	init_test_file(File,OptionsList),
	(\+ option(swish) -> 
		my_load_dyn(File)
		; true),
	collect_guessed_declarations(Facts),
	forall(member(Fact,Facts),uassert(Fact)),
	% fails if errors occur:
	print_errors(File), 
	(option(meta_actions) -> add_meta_reactive_rules ; true),
	( initial_state(IS), assert_list(IS), fail ; true),
	( option(delta_state(State)), member(F,State),
		(F = + Fluent -> uassert(state(Fluent)) ; F = - Fluent -> uretractall(state(Fluent))),
		fail
		; true
	),
	cputime(T0),
    	uassertz(current_time(0)), next_time,
    	uassertz(current_goal(0)),
    	uassertz(depth(0)),
	uassertz(used(0)),
    	(option(ultra_verbose)->
    		current_prolog_flag(write_depth,Old), 
    		set_xsb_flag(write_depth,10000) % ultra_verbose only remembered for xsb
   	;true),
    	cputime(T1),
	findall(reactive_rule(A, C), (reactive_rule(A, C);reactive_rule(A,C,_P)), R0), % drop priorities, if any
	findall(S,state(S),IS_),
	test(fluents,0,IS_),
	cycle(R0, []),
	!,
	cputime(T2),
	print_statistics(T0,T1,T2),
	close_test_file(File),
	(option(ultra_verbose)->set_xsb_flag(write_depth,Old);true),
		% ultra_verbose only remembered for xsb
	collect_results(ResultFluents).

% These internal predicates are necessary to aggregate all declarations
% TODO: generate and assert all, to get indexing
action_(A) :- action(A) ; actions(Actions), member(A,Actions).
event_(E) :- event(E) ; events(Events), member(E,Events).
fluent_(F) :- fluent(F) ; fluents(Fluents), member(F,Fluents).

% collect_guessed_declarations(-List). 
%  This was originally in psyntax; it may be called more than once, but only the first run actually does anything
collect_guessed_declarations(L) :-
	findall(Fact,(
		option(auto_declarations), uretract(head_hint(X,Type,false)), Type \== timeless, Fact=..[Type,X]
		), L).

collect_results([]) :- !.
collect_results([F-R|FR]) :- (setof(F,query(holds(F,_)),R)->true;R=[]), collect_results(FR).

% collect_fluents(Fluents,Instances)
collect_current_fluents([F|Fluents],Instances) :- !,
	(setof(F,query(holds(F,_)),R)->true;R=[]),
	collect_current_fluents(Fluents,Instances1),
	append(R,Instances1,Instances).
collect_current_fluents([],[]).

% collect_actions(Actions,Instances)  actions or events
collect_current_actions([A|Actions],Instances) :- !,
	(setof(A, happens(A,_,_) , R)->true;R=[]),
	collect_current_actions(Actions,Instances1),
	append(R,Instances1,Instances).
collect_current_actions([],[]).
	
print_statistics(_,_,_) :- option(silent), !.
print_statistics(T0,_T1,T2) :- 
	TotalT is T2-T0,
	current_time(Next), Cycles is Next-1,
	nl, format("** ~d cycles took ~f seconds **\n",[Cycles,TotalT]).

% check_syntax(+File,-Notices) Returns a list of notice(Type,Message,Position)
%  Type is 'error' or 'warning', Position is some term denoting a source file location
%  Position will be 'unknown'... unless our environment provides a definition for lps_source_position/4
%  Predicates called here typically have as second argument a notices list with a single
%  element... or they simply fail
check_syntax(F,Notices) :-
	findall(N, 
		(
			( Rule = reactive_rule(A, C) ; Rule = reactive_rule(A,C,_)), % TODO: should check priority too
			Rule,
			(source_position(Rule,F,Pos,Vars), 
			(check_reactive_rule(A,Pos,Vars,[N]) ; check_reactive_rule(C,Pos,Vars,[N])))
			), 
		RR),
	findall(N, 
		(
			l_int(P, B), 
			source_position(l_int(P, B),F,Pos,Vars), 
			( 
				\+ ((nonvar(P), P = holds(_,_))), 
				buildError(P,Vars,' is not a valid intensional predicate',ET),
				N=notice(error,ET,Pos) 
				; 
				check_lp_int(B,Pos,Vars,[N])) ), 
		IP), 
	findall(N, 
		(
			l_events(P, B), 
			source_position(l_events(P, B),F,Pos,Vars),
			( 
				\+ ((nonvar(P), P = happens(_,_,_))), 
				buildError(P,Vars,' is not a valid composite event predicate',ET), 
				N=notice(error,ET,Pos) 
				; 
				check_lp_events(B,Pos,Vars,[N])) ), 
		CE),
	findall(N, (d_pre(B),source_position(d_pre(B),F,Pos,Vars),check_d(B, d_pre, Pos, Vars, [N])), PC),
	findall(N,(
		initiated(Ev, Fl, Cond), 
		source_position(initiated(Ev, Fl, Cond),F,Pos,Vars),
		(
			((nonvar(Ev), Ev = happens(Ev2, _, _)) -> 
				( d_event(Ev2) -> fail 
				; 
				buildError(Ev2,Vars,' in initiated post-condition must be a simple event (event/action) predicate',ET), 
				N=notice(error,ET,Pos)
				)
			; 
				buildError(Ev,Vars,' is not a valid domain initiated post-condition predicate',ET), 
				N=notice(error,ET,Pos)
			)
		;
			\+ d_head(Fl), 
			buildError(Fl,Vars,' in initiated post-condition must be an extensional fluent predicate',ET), 
			N=notice(error,ET,Pos)
		;
			check_d(Cond, 'i post-condition', Pos, Vars,[N])
		) ), 
		PostI),
	findall(N,(
		terminated(Ev, Fl, Cond), 
		source_position(terminated(Ev, Fl, Cond),F,Pos,Vars),
		(
			((nonvar(Ev), Ev = happens(Ev2, _, _)) -> 
				( d_event(Ev2) -> fail 
				; 
				buildError(Ev2,Vars,' in terminated post-condition must be a simple event (event/action) predicate',ET), 
				N=notice(error,ET,Pos)
				)
			; 
				buildError(Ev,Vars,' is not a valid domain terminated post-condition predicate',ET), 
				N=notice(error,ET,Pos)
			)
		;
			\+ d_head(Fl), 
			buildError(Fl,Vars,' in terminated post-condition must be an extensional fluent predicate',ET), 
			N=notice(error,ET,Pos)
		;
			check_d(Cond, 't post-condition', Pos, Vars,[N])
		) ), 
		PostT),
	append_lists([RR,IP,CE,PC,PostI,PostT],Notices).

% buildError(BadSubterm,Vars,Message,NoticeSubterm)  Assume the new syntax to be the preferred for reporting errors:
%  this introduces a dependency on psyntax, should probably have a hook or refactor further... oh well.
buildError(BadSubterm,Vars,Message,NoticeSubterm) :-
	copy_term(BadSubterm+Vars,BadSubterm_+Vars_),
	buildError(BadSubterm_,Vars_,Vars,Message,NoticeSubterm).
buildError(X,Vars_,Vars,M,subterm(X,MM)) :- catch(psyntax:syntax2p_literal(NicerTerm,[],lps2p,_,_,X),_,fail), !, 
	Vars=Vars_, bindAllVars(Vars),
	concat_terms([NicerTerm,M],MM). % should probably use SWI's term_string and make sure M quotes do not make it to the output
buildError(X,Vars,Vars,M,subterm(X,MM)) :- bindAllVars(Vars), concat_terms([X,M],MM).

% also closes var tailed lists
bindAllVars([]) :- !.
bindAllVars([VV|Vars]) :- 
	arg(1,VV,Name), arg(2,VV,Value), 
	(var(Value) -> Value=Name ; true), bindAllVars(Vars).

% bindAllVars(+VarValues,?NameValuePairs).
bindAllVars(Values,Pairs) :- length(Values,N), length(Pairs,N), !,
	bindAllVars_(Values,Pairs).
bindAllVars(_Values,_Pairs). % probably extra time vars, we lost information in the transform, can't recover var names
	
bindAllVars_([V|Vs],[Pair|Pairs]) :- !, arg(2,Pair,V), bindAllVars_(Vs,Pairs).
bindAllVars_([],_NameValuePairs).

% May call an external predicate hook to find the position
% position for Prolog Studio is t(CharPosition,TermIndex), for SWI / swish see lps_source_position/4 above
source_position(Term,F,Position,Vars) :- catch(lps_source_position(Term,F,Position,Vars),_,fail), !.
source_position(_,_,unknown,[]).
	
% fails if errors occur:
print_errors(File) :- 
	check_syntax(File,Notices), nl,
	( 
		member(notice(Type,M,Position),Notices), 
		(M=subterm(_,M_)->true;M=M_),
		print_syntax_error(Type,M_,Position), 
		fail 
	; Notices=[]),
	((option(priority), \+ reactive_rule(_,_,_)) 
		-> writeln('WARNING: no rules with priority present!') 
		; true),
	(( \+ option(priority), \+ reactive_rule(_,_))
		-> writeln('WARNING: no reactive rules are present!')
		; true).

concat_terms(Terms,Atom) :- concat_terms(Terms,[],Codes), atom_codes(Atom,Codes).

concat_terms([T1|Tn],C,Cn) :- term_to_codes(T1,C1), append(C,C1,C2), concat_terms(Tn,C2,Cn).
concat_terms([],C,C).

check_reactive_rule([H|T], Pos, Vars,NT) :-
    reactive_conjunct(H),
    !,
    check_reactive_rule(T, Pos, Vars,NT).
check_reactive_rule([H|_], Pos, Vars,[notice(error,ET,Pos)]) :- !,
    buildError(H,Vars,' is not a valid reactive rule conjunct',ET).
check_reactive_rule(H, Pos, Vars,[notice(error,ET,Pos)]) :- \+ is_list(H),
    buildError(H,Vars,' must be a list',ET).
    
check_lp_int([H|T], Pos, Vars,NT) :-
    l_int_body(H), !,
    check_lp_int(T, Pos,Vars, NT).
check_lp_int([H|_], Pos, Vars,[notice(error,ET,Pos)]) :-
    buildError(H,Vars,' is not a valid L_int body',ET).

check_lp_events([H|T], Pos, Vars,NT) :-
    l_events_body(H), !,
    check_lp_events(T, Pos, Vars,NT).
check_lp_events([H|_], Pos, Vars, [notice(error,ET,Pos)]) :-
    buildError(H,Vars,' is not a valid L_events body',ET).

check_d([H|T], What, Pos, Vars, NT) :-
    d_body(H), !,
    check_d(T, What, Pos, Vars, NT).
check_d([H|_], What, Pos, Vars, [notice(error,ET,Pos)]) :-
    concat_terms([' is not a valid ',What,' body'],M),
    buildError(H,Vars,M,ET).
    
% this may be called by environment tools; see check_syntax/2
load_check_syntax(File,Notices) :-
	cleanup_program,
	% Let's assume Prolog syntactic errors are reported elsewhere:
	catch(my_load_dyn(File),_E,true), 
	check_syntax(File,Notices).

assert_list([H|T]) :- !,
    uassertz(state(H)),
    assert_list(T).
assert_list([]).


% last cycle
endTime(T) :- maxTime(T), !.
endTime(20). % default duration of execution

% parse_options(OptionsList)  See code and comments below for precise semantics of each option...
%
parse_options(Options) :- 
	uretractall(option(_)),
	% when running a test the options will be imposed by the test file:
	% (member(run_test,Options) -> Options=[_]; true),  commenting this out to allow 'dc' option to be added
	( (member(silent,Options), (member(verbose,Options);member(ultra_verbose,Options))) ->
		writeln(user_error, 'ERROR in options: silent incompatible with verbose and ultra_verbose.'), fail
		; true),
	( (member(cycle_hook(_),Options), (member(make_test,Options) ; member(manual,Options))) ->
		writeln(user_error, 'ERROR in options: cycle_hook incompatible with make_test and with manual.'), fail
		; true),
	( (member(meta_actions,Options), member(swish,Options)) ->
		writeln(user_error, 'ERROR in options: meta_actions not supported on SWISH.'), fail
		; true),	
	( (member(manual,Options), member(make_test,Options), \+ member(swish,Options)) ->
		writeln(user_error, 'ERROR in options: make_test incompatible with manual option.'), fail
		; true),				
	parse_options_(Options).

parse_options_([]) :- !.
parse_options_([timeout(Max)|Rest]) :- !, 
    (number(Max)->true; writeln(user_error, 'ERROR in options: timeout must be a float (seconds) '), fail),
    uassertz(option(timeout(Max))),
    parse_options_(Rest).
parse_options_([swish|Rest]) :- !, % don't cleanup db (nor load the program), the environment will do it
    uassertz(option(swish)),
    parse_options_(Rest).
parse_options_([dc|Rest]) :- !,
    (current_prolog_flag(dialect, swi) 
    	-> uassertz(option(dc)) 
    	; 
    	writeln(user_error, 'ERROR in options: delimited continuations are available only for SWI Prolog '),
    	fail
    	),
    parse_options_(Rest).
parse_options_([no_parallel|Rest]) :- !,
    (current_prolog_flag(dialect, swi) 
    	-> uassertz(option(no_parallel)) 
    	; 
    	writeln(user_error, 'ERROR in options: no_parallel is a delimited continuations option, available only for SWI Prolog '),
    	fail
    	),
    parse_options_(Rest).
parse_options_([verbose|Rest]) :- !,
    uassertz(option(verbose)),
    parse_options_(Rest).
% Increase the default maximum written term depth, to avoid '...' output
parse_options_([ultra_verbose|Rest]) :- !,
    uassertz(option(verbose)),
    (current_prolog_flag(dialect, xsb) 
    	-> uassertz(option(ultra_verbose)) 
    	; writeln(user_error, 'WARNING: ultra_verbose option considered only for XSB Prolog ')
    	),
    parse_options_(Rest).
parse_options_([silent|Rest]) :- !,
    uassertz(option(silent)),
    parse_options_(Rest).
parse_options_([make_test|Rest]) :- !,
	uassertz(option(make_test)),
	parse_options_(Rest).
parse_options_([run_test|Rest]) :- !,
	uassertz(option(run_test)),
	parse_options_(Rest).
parse_options_([meta_actions|Rest]) :- !,
	uassertz(option(meta_actions)),
	parse_options_(Rest).
parse_options_([cycle_hook(Predicate,Fluents,Actions)|Rest]) :- !,
	% Fluents and (basic) Actions are lists of templates; the cycle hook predicate should collect all matching tuples
	((atom(Predicate),is_list(Fluents),is_list(Actions))->true
	; writeln(user_error, 'ERROR in options: cycle_hook first argument must be an atom, a predicate name; then fluent and action lists.'), fail),
	uassertz(option(cycle_hook(Predicate,Fluents,Actions))),
	parse_options_(Rest).
parse_options_([observations(Obs)|Rest]) :- !,
	((is_list(Obs), forall(member(observe(L,T),Obs),(is_list(L),integer(T))) ) -> true
	; writeln(user_error, 'ERROR in options: observations must contain a list of observe(List,Time).'), fail),
	uassertz(option(observations(Obs))),
	parse_options_(Rest).
parse_options_([delta_state(State)|Rest]) :- !,
	((is_list(State), forall(member(F,State), (nonvar(F), (F = + _ ; F = - _ ))) ) -> true
	; writeln(user_error, 'ERROR in options: delta_state must contain a list of +Fluent or -Fluent.'), fail),
	uassertz(option(delta_state(State))),
	parse_options_(Rest).
% parameter for declaration generation by alternative syntaxes; default (absent) may help LPS program debugging
% auto_declarations. 'true' will add fluent, event and action declarations guessed from usage; 
parse_options_([auto_declarations|Rest]) :- !,
	uassertz(option(auto_declarations)),
	parse_options_(Rest).
parse_options_([manual|Rest]) :- !,
	(observe(_, _) -> 
		writeln(user_error, 'ERROR in options: with ''manual'', no observations in the program are allowed.'), fail
		;true),
	uassertz(option(manual)),
	parse_options_(Rest).
parse_options_([O|Rest]) :- 
    write(user_error, 'WARNING: Ignored option '), writeln(user_error,O),
    parse_options_(Rest).


write_verbose(What) :-
    ( option(verbose) ->
        do_write(What)
    ;
        true
    ).

do_write(_) :- option(silent), !.
do_write([]) :- !.
do_write([What|Rest]) :- var(What), !,
    write(What),
    do_write(Rest).
do_write([pprint_goal(What)|Rest]) :- !,
    pprint_goal(What),
    do_write(Rest).
do_write([nl|Rest]) :- !,
    nl,
    do_write(Rest).
do_write([What|Rest]) :- !,
    write(What),
    do_write(Rest).

pprint_goal([]).

pprint_goal([goal(_, [H|_])|Rest]) :-
    write(H),nl,
    pprint_goal(Rest).

pprint_goal([goal(_, _, [H|_])|Rest]) :-
    write(H),nl,
    pprint_goal(Rest).

% init_test_file(+Filename,+Options)
% Load test file for this program file  
% if not running tests does nothing
init_test_file(F,TopOptions) :- select(run_test,TopOptions,Extra), !, 
	nl, write('*** Testing '), write(F), write(' ('), write(TopOptions), writeln(') ****'),
	load_test_file_for(F),
	lps_test_options(Options),
	append(Options,Extra,RealOptions),
	% add the options:
	parse_options(RealOptions), % cleans options and loads from file...
	uassert(option(run_test)). %...this one not being there
init_test_file(_F,_O).

load_test_file_for(F) :-
	test_filename(F,TF),
	catch(my_load_dyn(TF,false),E,true),
	(nonvar(E) -> 
		write(user_error, 'ERROR: could not load test file '), writeln(user_error,TF), writeln(user_error,E),
		writeln(user_error,' To obtain a test file you need to execute your program with the make_test option: go(YourFile,[make_test])'),
		fail
		; true).

% close_test_file(ProgramFile)
close_test_file(F) :- var(F), !.
close_test_file(F) :- option(make_test), \+ option(swish),  !,
	test_filename(F,TF),
	telling(Old), tell(TF),
	date_stamp(D),
	writeln('/*'), write('  LPS test results file generated on '), writeln(D), 
	write('  on Prolog '), current_prolog_flag(version_data,P), write(P),
	writeln(' for program file:'),
	write('  '), writeln(F), writeln('*/'), nl,
	write((:- dynamic lps_test_result/3, lps_test_result_item/3, lps_test_options/1)), writeln('.'),
	nl,
	writeln('% LPS options prior to the test:'),
	setof(O,option(O),Options),
	select(make_test,Options,RealOptions),
	write(lps_test_options(RealOptions)), writeln('.'), nl,
	writeln('% lps_test_result(Stage,Cycle,TestTerm)'),
	(lps_test_result(S,C,T), writeq(lps_test_result(S,C,T)), writeln('.'), fail ; true),
	writeln('% lps_test_result_item(Stage,Cycle,TestTerm)'),
	(lps_test_result_item(S,C,T), writeq(lps_test_result_item(S,C,T)), writeln('.'), fail ; true),
	told, tell(Old).
close_test_file(F) :- option(run_test), !,  
	test_filename(F,TF),
	nl,
	( \+ lps_failed_test(_,_) -> Result=' (ok)'; Result=' (FAILED)'),
	write('*** Tests ended with '), write(TF), write(Result), writeln(' ****').
close_test_file(_F).

% test_filename(+ProgramFile,-TestFile)
% Names the test file as the programs's plus '.lpst' (LPS test file)
test_filename(PF,TF) :- 
	expand_filename(PF,Path),
	concat_atom([Path,'.lpst'],TF).
	
	
% test(Stage,Cycle,Term)
% Remembers or checks that at this Stage and Cycle, Term is obtained
% Requires the Term to be a LIST
% if term size is too big an abstraction is stored, and it is NOT verified
test(Stage,Cycle,Term) :- option(make_test), !,
	is_list(Term),
	\+ \+ (( 
		numbervars(Term), length(Term,N), uassert(lps_test_result(Stage,Cycle,N)),
		forall(member(Item,Term),assert_lps_test_result_item(Stage,Cycle,Item))
		)).
test(Stage,Cycle,Term) :- option(run_test), !,
	% fails if the test fails:
	( lps_test_result(Stage,Cycle,N) -> true 
	  ; 
	  	write('FAILED test '), writeln(Stage/Cycle/Term), 
	  	writeln('Missing test fact.'), 
	  	uassert(lps_failed_test(lps_test_result(Stage,Cycle,Term),missing_fact)), 
	  	fail),
	findall(Item,lps_test_result_item(Stage,Cycle,Item),Test), 
	% numbervars(Test),
	( \+ \+ ((length(Term,N), /*numbervars(Term),*/ test_items_ok(Term,Test)) )
		-> true
		; 
		write('FAILED test '), writeln(Stage/Cycle/Term), write('Expected '), writeln(Test), 
		uassert(lps_failed_test(lps_test_result(Stage,Cycle,Term),Test)),
		fail).
test(_,_,_).

test_items_ok(Actual,Test) :- member(lps_gigantic(_),Test), !, 
	test_items_ok_(Actual,Test).
% other than for the above, which is too strict (likely not worthy implementing less strict...), 
% order doesn't matter:
test_items_ok(Actual,Test) :- sort(Actual,A), sort(Test,T), variant(A,T).

% test_items_ok(+Actual,+Test)
test_items_ok_([A|An],[lps_gigantic(Size)|Tn]) :- !,
	% Must recalculate term size after numbervars, otherwise would be different:
	\+ \+ (numbervars(A),my_term_size(A,Size_), Size_ == Size), 
	test_items_ok_(An,Tn).
test_items_ok_([A|An],[T|Tn]) :- !,
	variant_(A,T),
	test_items_ok(An,Tn).
test_items_ok_([],[]).

% assert_lps_test_result_item(Stage,Cycle,Item) Gigantic terms are abstracted as lps_gigantic(Size)
assert_lps_test_result_item(Stage,Cycle,Item) :- 
	my_term_size(Item,Size), 
	( Size > 1000 -> Item_=lps_gigantic(Size) ; Item_=Item),
	uassert(lps_test_result_item(Stage,Cycle,Item_)).
	

% test all programs in the LPS examples directory tree which have a .lpst file present
% NOTICE that .lps files are transformed into .P files, so these are used for testing!!
test_examples :- test_examples([]).

test_examples(Options) :- 
	lps_examples_directory(ED),
	all_files_in(ED,'.lpst',TFiles),
	atom_codes('.lpst',LPST),
	findall(ProgramFile,(
		member(TFile,TFiles), atom_codes(TFile,Tcodes),
		append(PCodes,LPST,Tcodes),atom_codes(ProgramFile,PCodes)
		),Files),
	% check whether we need to regenerate some of these Files
	regenerate(Files), !,
	do_test_suite(Files,[run_test|Options]).

regenerate([F|Files]) :- !, 
	atom_codes(F,Fcodes), 
	(regenerate_file(Fcodes)->true;true), regenerate(Files).
regenerate([]).

:- multifile regenerate_file/1.
% regenerate(FileAtom) regenerate this file, foo.P or foo.lpsw, from foo.SomeSyntaxSpecificFileExpension, if this exists
% alternative syntaxes should asserta a the generator
regenerate_file(_) :- fail. % default case, do not generate (meaning, no source file exists that produced this one)

% do_test_suite(Files,Options)  
%  Options must contain make_test or run_test, optionally more; Files are either LPS or test result files resp.

do_test_suite(Files,Options) :-
	(member(run_test,Options);member(make_test,Options)), 
	!,
	writeln('*** Starting test suite, will report at the end...'),
	do_test_suite(Files,Options,Results),
	nl, write('*** Test suite ended ('), write(Options), writeln('):'),
	( member(F-R,Results), write(F), write(': '), writeln(R), fail; true),
	length(Results,N), findall(f,member(_-failed(_),Results),FL), length(FL,NF),
	(NF==0->write('All '), write(N), writeln(' tests succeeded:-) !') ; write('FAILED '), write(NF/N), writeln(' tests:-(')),
	writeln('*** End of test suite results').

% do_test_suite(Files,Options,Results)  Results is a list of File - ok/failed
do_test_suite([],_Option,[]) :- !.
do_test_suite([F|Files],Options,[F-R|Results]) :- 
	expand_filename(F,Path),
	file_exists(Path),
	!,
	
	( (go(Path,Options), \+ lps_failed_test(_,_)) -> R=ok 
	; 
	findall(LPSR/Expected,lps_failed_test(LPSR,Expected),Failures), R=failed(Failures) 
	),
	do_test_suite(Files,Options,Results).
do_test_suite([_|Files],Options,Results) :- do_test_suite(Files,Options,Results).

% time_limited(+StepName,+G,?Timeout) 
% Skips G if Timeout is true; timeout will be bound to true if time runs out; will remain unbound otherwise
time_limited(_Step,_G,Timeout) :- nonvar(Timeout), !.
time_limited(Step,G,Timeout) :-
	(option(timeout(MaxTime)) -> true ; MaxTime = 0.5), % by default, half second max in each of the following steps
	catch(call_with_time_limit(MaxTime,G),Ex,(Ex=time_limit_exceeded->Timeout=true;throw(Ex))),
	(Timeout==true -> 
		print_error(error,'execution timeout'(Step),null),
		fail
		; true).

%  cycle(PartialReactiveRules,GoalState)
%  GoalState is a list (conjunction) of goal(Id,Tree)
%  Tree is a list representing the current branch of the tree.
cycle(_Ri, Gi) :-
	current_time(Time), endTime(M), M < Time,
	!,nl,
	do_write([' Time is up. Unsolved goals: ',nl,Gi]).
%	write_verbose([' Time is up. Unsolved goals: ',nl,Gi]).

cycle(Ri, Gi) :-
	current_time(Time),  Previous is Time - 1 ,Next is Time +1,
    	( option(cycle_hook(Predicate,_,_)) -> 
    		HookGoal =.. [Predicate,ExternalObservations],
		(HookGoal -> true ; writeln('* LPS cycle hook goal failed, terminating.'), fail)
    	; ExternalObservations=[]),

    	(option(manual) ->read_obs(UserObservations) ; UserObservations=[]),
    	append(UserObservations,ExternalObservations,ExternalObservations_),
    	
	(Time = 1 -> updateEvents(0, 1, ExternalObservations_)   ; true),
	
	% At this point last cycle events are still available
    	% TODO: ExternalObservations to be injected as new events
	findall(Action, happens(Action, Previous, Time), Actions),
%	write_verbose([nl, '----- time is now ',Time,' -----',nl]),
%	write_verbose([nl, ' Events and actions from ', Previous, ' to
%	', Time,' are ',Actions,nl]),
	do_write([nl, '----- time is now ',Time,' -----',nl]),
	do_write([nl, ' Events and actions from ', Previous, ' to ', Time,' are ',Actions,nl]),
	test(events,Time,Actions),
	enter_step_0, % during updateFluents we need a hack to query the previous state
	time_limited(updateFluents,updateFluents(Time),Timeout),
	findall(Fluent, state(Fluent), Fluents), % setof doesn't work.
	do_write([nl,' State at time ',Time,' is ',Fluents, nl]),
%	write_verbose([nl,' State at time ',Time,' is ',Fluents, nl]),
	test(fluents,Time,Fluents),
	leave_step_0,
	% This processes antecedents of rules:
	time_limited(process, (option(dc) -> dc_process(Ri, [], NRi, [], NewGi) ; process(Ri, [], NRi, [], NewGi)), Timeout),
	(nonvar(Timeout) -> NRi=Ri, NewGi=[] ; true),
	write_verbose([nl,
		' Process reactive rules at time ',Time, nl,'Old:  ',Ri, nl, ' New:  ', NRi,  nl,
		' Process goal tree at time ',Time, nl,' New: ',NewGi, nl]),
	append(Gi, NewGi, NGi), % Puts new goals at the end of the queue.
	write_verbose([nl,
		' Process reactive rules at time ',Time, nl,' New: ',
		NRi, nl,
		' Current goal tree at time ',Time, nl,' All: ',NGi,
		nl]),
	forall( action_(A), uretractall(tried(_, _, lpsClause(happens(A, _, _), [])))),
	uretractall(happens(_, _, _)),
	updateEvents(Time, Next, ExternalObservations_),
	% This resolves goals in the goal state.
	time_limited(resolve, (option(dc) -> once(dc_resolve_goals(NGi,GoalTree) ) ; resolve_tree(NGi, [], GoalTree)), Timeout),
	(GoalTree = end -> % this will execute on timeout too
		do_write([nl,' Exceeded number of steps. ',nl])	
		;	
		(option(dc) -> NextGi=GoalTree ; removeSolvedGoals(GoalTree, [], NextGi)),
		next_time, 
		cycle(NRi, NextGi)
	).

% Obtain events (observations) from the user
read_obs(Obs) :-
	writeln('What happened? Please type a list of events, ending with .'),
    	read(Obs),
    	( \+ is_list(Obs) ->
        	write(user_error, 'ERROR: Input must be a list of valid events (possibly empty), e.g. [event3].'),nl,
        	read_obs(Obs)
    	;true).

% Update any observed events, including events injectd from the outside, e.g. Java API
updateEvents(Time, Next, ExternalObservations) :-  
	forall( (observe(Evs, Next),member(E, Evs) ; member(E,ExternalObservations)), uassertz(happens(E, Time, Next))) -> true
     ; true.

enter_step_0 :- uassert(lps_updating_current_state).
leave_step_0 :- uretractall(lps_updating_current_state).

%   Destructively update the state.
updateFluents(Time) :-
	findall(Fl, (happens(Ev, Previous, Time), terminated(happens(Ev, Previous, Time), Fl, Cond), holds_all(Cond)), Terms),
	findall(Fl, (happens(Ev, Previous, Time), initiated(happens(Ev, Previous, Time), Fl, Cond), holds_all(Cond)), Inits),
	forall((member(Fl, Terms), state(Fl)), uretractall(state(Fl))),
    	forall((member(Fl, Inits), \+ state(Fl)), uassertz(state(Fl))).

removeSolvedGoals([], NextGi, NextGi).

removeSolvedGoals([goal(GId, Branch) | GoalTree], AccGi, FinalGi):-
     (Branch = [[] | _] ->
        uretractall(tried(GId, _, _)), removeSolvedGoals(GoalTree, AccGi, FinalGi)
      ; removeSolvedGoals(GoalTree, [goal(GId, Branch) | AccGi], FinalGi)).

% process(RulesToProcess, RulesProcessed, FinalRules, GoalsSoFar, FinalGoals).
%	
process([], Rs, Rs, NG, NG) :- !.

% Antecedent is []. Add Consequent as new goal/tree.
process([reactive_rule([], C) | Rs], AccRi, NRi, AccG, NGi):- !, generate_id(GId),
	process(Rs, AccRi, NRi, [goal(GId, [C]) | AccG], NGi ).

% Cannot be resolved now. Leave for later.
process([reactive_rule([L | Ls], C) | Rs], AccRi, NRi, AccG, NGi):-
	(L = holds(_, T); L = happens(_,_, T)),
	ground(T), current_time(Now), T > Now,
	!,
	process(Rs, [reactive_rule([L | Ls], C) | AccRi], NRi, AccG, NGi).

% Negation of fluent P at time T = current time. If P holds then drop
% the reactive rule. If P doesn't hold, then delete not P from the rule.
% Need similar case for prolog atom.
process([reactive_rule([L | Ls], C) | Rs], AccRi, NRi, AccG, NGi):-
	(L = not(holds(P, T)); L = (holds(not(P), T))),!,
	copy_term( reactive_rule([holds(P, T) |Ls], C), reactive_rule([holds(CP, CT) |CLs], CC) ),
	current_time(Now),
	(   query(holds(CP, Now)) -> (T==Now -> process(Rs, AccRi, NRi, AccG, NGi)
				     ;	 process(Rs, [reactive_rule([L | Ls], C) | AccRi], NRi, AccG, NGi))
	;   (T==Now ->  process([reactive_rule( CLs, CC) | Rs], AccRi, NRi, AccG, NGi)
	    ;   (CT = Now, process([reactive_rule( CLs, CC)| Rs], [reactive_rule([L | Ls], C) |AccRi], NRi, AccG, NGi)))) .

% Cannot be resolved now. Too late, no longer relevant.
process([reactive_rule([L |_],_) | Rs], AccRi, NRi, AccG, NGi):-
	(L = holds(_, T); L = happens(_,_, T)),
	ground(T), current_time(Now), T < Now,
	!,
	process(Rs, AccRi, NRi, AccG, NGi).

%Cannot be resolved now. Either delete or leave for later cycles.
% Perhaps this clause can be made into or already is a special case of
% the next clause. In fact, it might be possible to combine all four
% clauses into one clause. Desirable?
process([reactive_rule([L |Ls], C) | Rs], AccRi, NRi, AccG, NGi):-
%	copy_term([L|Ls], [CL|_]), %copy_term not needed?
	\+ lpsClause(L, _),
	!,
	(mustBeProcessedNow(L) -> process(Rs, AccRi, NRi, AccG, NGi)
	;  process(Rs, [reactive_rule([L | Ls], C) | AccRi], NRi, AccG, NGi)).

% Can be resolved now.
process([reactive_rule([L |Ls], C) | Rs], AccRi, NRi, AccG, NGi) :-
      copy_term(reactive_rule([L |Ls], C) , reactive_rule([CL |CLs], CC)),
%      lpsClause(CL, Body),
%	setof(lpsClause(CL, Body), lpsClause(CL, Body), AllClauses),
%	nl, write(' all clauses that match the head of the reactive rule
%	'), write(AllClauses), nl, setof(reactive_rule(Resolvent,CC),
%	(member(lpsClause(CL, Body), AllClauses), append(Body, CLs,
%	Resolvent)), NewR ),
	findall(reactive_rule(Resolvent,CC) , 
	(lpsClause(CL, Body),append(Body, CLs, Resolvent)), NewR ),
%	nl, write(' all resolvents of the head '),write(L), write(' of
%	the reactive rule are '),
%	write(NewR), nl,
	append(NewR, Rs, NextRs),
       (mustBeProcessedNow(L)
%	nl, write(' must be processed now '),write(L),
            -> process(NextRs, AccRi, NRi, AccG, NGi)
            ;  process(NextRs,[reactive_rule([L | Ls], C) | AccRi], NRi, AccG, NGi)).

generate_id(New) :-
	used(Id),New is Id+1, uretract(used(Id)), uassertz(used(New)).

/* resolve_tree.
% Goals already processed are in reverse of the original order. Original order needs to be recovered.
% Difference lists could be used instead. Retract all tried actions is a
% hack, to remove and tried actions not removed by clause 4 of resolve.
% There should be a more elegant solution.
%
% There was a problem here, because removeSolvedGoals also reverses the goal tree
% and better there than here. Also retracting tried clauses is better done elsewhere.
resolve_tree([], NewAccG, FinalG) :-
	reverse(NewAccG, FinalG),nl,
	write('accumulated goals, and reversed goals:'), nl, write(NewAccG), nl, write(FinalG), nl,
	uretractall(tried(_GoalId, _Depth, lpsClause(happens(_A,_T,_), []))).

Notice that this assumes that atoms in goal lpsClauses B1 are written in temporal order.
Otherwise it would be necessary to skip over L but retain L and continue to process Ls.
This would be tricky.

*/

% resolve_tree(Goal/tree/branches still to be processed, Goals already processed, Final goals)
% candidate actions happens(e,t, t+1) are asserted in the form happens(e,t, t+1) and,
% if necessary, deleted on backtracking. Otherwise, they persist.
%
resolve_tree([], FinalG, FinalG).

% terminate with message: Exceeded number of steps.
resolve_tree(_Unfinished, _AccG, end):-
	steps(N), N < 1, !.

/*
Alternatively, continue:
resolve_tree(Unfinished, AccG, NextGoals):-
	steps(N), N < 1, reverse(AccG, RevAccG), append(Unfinished, RevAccG, NextGoals),
	nl,write(' Exceeded number of steps. '), nl.
*/

% An alternative to asserting and retracting depth is simply to compute
% depth when necessary, or pass as a parameter of resolve.
resolve_tree([goal(GoalId, [ [L|Ls] | Bs]) | Gs], AccG, FinalG) :-
    steps(N), N > 1,
	uretractall(current_goal(_)), uassertz(current_goal(GoalId)),
	uretractall(depth(_)),length([ [L|Ls] | Bs], Depth),
	uassertz(depth(Depth)),
     resolve([L|Ls], Result),
	write_verbose([' Goal is ',L, nl,'. Result/resolvent is ',Result,nl]),
	(Result = fail -> (backtrack([goal(GoalId,[[L|Ls]|Bs])|Gs], NextTree, AccG, NewAccG)
%	 nl, write(L), write(' fails. Backtracking: next tree '),
%	 write(NextTree) nl, write('new accumulated tree '),
%	 write(NewAccG), nl
	 )
	; (Result = later -> (continue([goal(GoalId,[[L|Ls]|Bs])|Gs], NextTree, AccG, NewAccG)
%	nl, write('continue next tree '), write(NextTree),
%	nl, write(' new accumulated tree '), write(NewAccG), nl
	 )
	; (advance(Result, [goal(GoalId, [ [L|Ls] | Bs]) | Gs], NextTree, AccG, NewAccG)
%	nl, write('advance next tree '), write(NextTree),
%	nl, write(' new accumulated tree '), write(NewAccG), nl
	  ))
	 
	 ),
	resolve_tree(NextTree, NewAccG, FinalG).

% Clause -1. Time is earlier or later than Now: Result = fail or later.
resolve([L|_], Result) :-
	(L = holds(_, T); L = happens(_, T, _); L = not(holds(_, T))),
	ground(T), current_time(Now),
	(T > Now -> Result = later ; (T < Now -> Result = fail ; fail)),
	!.

% Clause 0. Negation of fluent P at time T = current time. If P holds
% then fail. If P doesn't hold, then delete not P from the goal.
% Need similar case for L the negation of a prolog atom.
resolve([L | Ls],Result):-
	(L = not(holds(P, T)); L = (holds(not(P), T))),!,
	reduce_step, current_time(Now),
	current_goal(GoalId),
	depth(Depth),
	copy_term([holds(P)|Ls],[holds(CP)| CLs]),
	(tried(GoalId, Depth, not(CP))
	-> ( uretractall(tried(GoalId, Depth, not(CP))),
	      ((ground(T), T=<Now) -> Result = fail ; Result = later))
	   ;(query(holds(CP, Now)) -> (T==Now -> Result = fail ; Result = later)
	    ;  ( Result = CLs,  uassertz(tried(GoalId, Depth, not(CP))) ) )).


%Clause 1. No clause resolves with L.
resolve([L|_], Result) :-
%		copy_term([L|Ls], [CL|_]), %copy_term not needed?
		\+ (L = happens(A, _, _), action_(A)),
		\+ lpsClause(L, _),
		reduce_step,
%		steps(S),
%		write_verbose([nl,' no clause resolves with ', L,' after
%		', S, ' steps', nl]),
		\+ (L = happens(A, _, _), action_(A)),
		(mustBeResolvedNow(L) -> Result = fail
		; Result = later).

% Clause 2. Untried clause resolves with L.
resolve([L|Ls], Result) :-
	copy_term([L|Ls], [CL|CLs]),
	\+ (L = happens(A, _, _), action_(A)),
	lpsClause(CL, Body),
	reduce_step,
%	steps(S),
%	write_verbose([nl, ' Number of steps is ',S, nl]),
	current_goal(GoalId), depth(Depth),
	\+ tried(GoalId, Depth, lpsClause(CL, Body)),
     uassertz(tried(GoalId, Depth, lpsClause(CL, Body))),
	append(Body, CLs, Result).
%	write(' -------- tried '), write([GoalId, Depth, lpsClause(CL,
%	Body)]) , nl.

% Clause 3. Clauses resolve with L, but all have been tried.
resolve([L|Ls], Result) :-
	%current_time(Now), Next is Now+1,
	copy_term([L|Ls], [CL|_]),  %Don't need copy_term?
	\+ (L = happens(A, _, _), action_(A)), % It seems we need something like this clause also for actions.
	lpsClause(CL, _),
	% !,
	reduce_step,
%	steps(S),
%	write_verbose([nl, ' Number of steps is ',S, nl]),
	current_goal(GoalId), depth(Depth),	!,
    	findall(lpsClause(CL, Body), lpsClause(CL, Body), AllClauses),
		%findall(lpsClause(L, Body), lpsClause(L, Body), AllClauses),
%    write(' All clauses that resolve with '), write(L), write(' are '),
%    nl, write(AllClauses), nl,
    	forall(member(Clause, AllClauses), tried(GoalId, Depth, Clause) ),% Problem if this fails?
%    write(' All clauses that resolve with '), write(L), write(' have
%    been tried. '), nl,
	(mustBeResolvedNow(L) -> (Result = fail
%				 ,
%	 write('failed all clauses tried  '), write(L), nl
				 )
	; (Result = later
%	 , write('Try again later '), write(L), nl
	  )
	).

% Clause 4. L is an action.
resolve([L|Ls], Result) :-
	L = happens(A, T, _), action_(A), current_time(Now),
	copy_term([L|Ls], [CL|CLs]),
	reduce_step,
	current_goal(GoalId),
	depth(Depth),
%	do_write([nl, 'Trying action  ', L, nl]),
	(tried(GoalId, Depth, lpsClause(CL, []))
	-> ( uretractall(tried(GoalId, Depth, lpsClause(CL, []))),
	   ((ground(T),  T =< Now) ->
		      Result = fail
	    ;  true),
	   (tried(_,_, lpsClause(CL, [])) ->
	      Result = fail
	   ; (Result = later, uassertz(tried(GoalId, Depth, lpsClause(CL, []))), uretractall(happens(A,Now,_))  ) )  )
        ;   (happens(A, Now, _) ->
	              (	  Result = CLs, uassertz(tried(GoalId, Depth, lpsClause(CL, []))))
	             ;candidateAction([L | Ls], Result) )).

% candidateAction([CA| _], Result) Result == fail   Result==later...
candidateAction([L| Ls], Result) :-
	copy_term([L|Ls], [CL|CLs]),
	current_time(Now), Next is Now+1,current_goal(GoalId),
	L = happens(A, T, _), CL = happens(A, Now, Next),
	depth(Depth),
	( happens(A, Now, Next)-> true ; uassertz(happens(A, Now, Next))),
	uassertz(tried(GoalId, Depth, lpsClause(CL, []))),
%	do_write([nl, 'Trying candidate action ', L, nl]),
	(( d_pre(Conds), holds_all(Conds)
%	 , do_write([nl, 'Constraint ',Conds,' failed  ', nl])
	 )->
	(uretractall(happens(A, Now, Next)),
	 (   T == Now -> Result = fail
	            ;   (	 (member(happens(B,Now,Next), Conds), action_(B), B\=A) ->
			                     Result = fail; Result = later )	) )
	;  Result = CLs ).

lpsClause(Head, Body) :-  l_timeless(Head, Body).
lpsClause(Head, Body) :-  l_events(Head, Body).
lpsClause(Head, Body) :-  l_int(Head, Body).
lpsClause(happens(X, Y, Z), []) :- happens(X, Y, Z).
lpsClause(holds(X, Y), []) :- current_time(Y), state(X).
lpsClause(tc(P), []) :- callprolog(P).
lpsClause(P, []) :- \+l_timeless(P,_),\+l_events(P,_),\+l_int(P,_),
	\+P = happens(_,_,_), \+P= holds(_,_), callprolog(P).

% mustBeProcessedNow(L) is used when unfolding atoms in antecedents of rules.
% true if L is extensional fluent or basic event with known time, intensional fluent/composite event or timeless/Prolog
mustBeProcessedNow(holds(_, T)) :-
	ground(T), current_time(Now),  T =< Now, !.
mustBeProcessedNow(happens(_, _, T)) :-
	ground(T), current_time(Now),  T =< Now, !.
mustBeProcessedNow(holds(P, _)) :-
	intensional(P), \+ fluent_(P),!.
	% Not necessary if extensional and intentional predicates are disjoint.
mustBeProcessedNow(happens(A,_,_)) :-
	macroaction(A), \+ action_(A),  !.
	% Not necessary if actions and macroactions are disjoint.
mustBeProcessedNow(P) :- prolog(P).

prolog(P) :- \+ P = happens(_,_,_), \+ P = holds(_,_).

intensional(P) :-  P =.. [Pred | Args], length(Args, L),
	length(Args2, L), Q =.. [Pred |Args2],
	 l_int(holds(Q, _), _).
% TODO: this should use compound_name_arity(X,F,N) to deal with e.g. newbelief(), or with (slower) A=..L, ...
macroaction(A):- functor(A,F,N), functor(Q,F,N), l_events(happens(Q, _,_), _), !.

%mustBeResolvedNow is used when unfolding atoms in goal clauses.
%
mustBeResolvedNow(happens(_, T, _)) :- ground(T), current_time(Now), T =< Now, !.

mustBeResolvedNow(holds(_, T)) :-  ground(T), current_time(Now), T =< Now, !.

mustBeResolvedNow(P) :-	\+ P = happens(_, _, _), \+ P = holds(_,_).

	/*
mustBeResolvedNow(happens(X, T, _)) :-
	action_(X), ground(T), current_time(Now), T == Now, !.
mustBeResolvedNow(P) :- mustBeProcessedNow(P),
	\+ (P = happens(_, _, T),ground(T), current_time(Now), T =< Now).

*/

% Top-level goal lpsClause B1 failed. Backtrack to LastB. Save B1 to retry later.
%
backtrack([goal(GoalId, [ B1]) | Gs], [NextBranch, goal(GoalId, [B1]) | Gs],
	  [LastBranch | PreviousBs], PreviousBs):-
	LastBranch = goal(GId, [LastLeaf | LastBs] ),
	length(LastBs, Depth),
	uretract(current_goal(_)), uassertz(current_goal(GId)),
	uretract(depth(_)),
	uretractall(tried(GoalId, _, _)),
	(LastLeaf = []
	->  (NextBranch = goal(GId, LastBs), uassertz(depth(Depth) ))
	; (NextBranch = LastBranch, D is Depth+1, uassertz(depth(D)))).

% Pop up one level.
%
backtrack([goal(GoalId,[_B1|Bs])|Gs], NextTree, AccG, NewAccG):-
	Bs \= [],
	depth(Depth), NewDepth is Depth - 1,
	uretractall(depth(_)), uassertz(depth(NewDepth)),
	uretractall(tried(GoalId, Depth, _)),
	NextTree = [goal(GoalId, Bs)|Gs],
	NewAccG = AccG.


advance([], [goal(GoalId, [B1|Bs]) | Gs] , NextTree, AccG, NewAccG):-
	!, NextTree = Gs,
%	nl,write(' Next tree is  '), write(NextTree),nl,
	NewAccG = [goal(GoalId,[[], B1 | Bs])| AccG],
	(Gs = [] -> true ;(Gs =	[goal(GId, NextBranch) | _] ,
	uretract(depth(_)), length(NextBranch,D), uassertz(depth(D)),
	uretract(current_goal(_)), uassertz(current_goal(GId)))).

advance(Resolvent, [goal(GoalId, [B1|Bs]) | Gs] , NextTree, AccG, NewAccG):-
	\+ Resolvent = [],
	NextTree = [goal(GoalId, [Resolvent, B1 | Bs]) | Gs], NewAccG = AccG,
	depth(Depth), NewDepth is Depth +1, uretract(depth(Depth)),
	uassertz(depth(NewDepth)).

% Similar to advance with [].
continue([goal(GoalId, [B1|Bs]) | Gs], NextTree,  AccG, NewAccG):-
	NextTree = Gs,
	uretractall(current_goal(_)), depth(Depth),
	uretractall(depth(_)),
	uretractall(tried(GoalId, Depth, _)),
%	nl,write(' Next tree is  '), write(NextTree),nl,
	NewAccG = [goal(GoalId,  [B1 | Bs] ) | AccG],
	(Gs = [] -> true ;(Gs =	[goal(GId, NextBranch) | _] ,
	length(NextBranch,D), uassertz(depth(D)),
	uassertz(current_goal(GId)))).


% From Wei's interpreter:
%
% % next_time().  Succeeds to the next time point. Destructively updates current_time/1
next_time :-
    uretract(current_time(This)), !,
    Next is This + 1,
    uassertz(current_time(Next)),
    uretractall(steps(_)),
    uassertz(steps(1000)).

reduce_step() :-
    steps(C),
    NC is C-1,
    uretractall(steps(C)),
    uassertz(steps(NC)).

% holds_all(+PL). True if all predicates in PL hold in the augmented
% state {S*_i, ev*_i, L_int, L_timeless}.
holds_all([]).
holds_all([P|Rest]) :-
    query(P),
    holds_all(Rest).

% query(+P). True if P holds in the augmented state {S*_i, ev*_i, L_int,
% L_timeless}.
%

query(L) :- option(dc), !, dc_query(L).

query(holds(not(P), Now)) :-
%    current_time(Now),  % Needs looking at more closely.
    \+ l_int(holds(P, Now), _),
    \+ state(P).
query(holds(P, Now)) :-
%    current_time(Now),  % Needs looking at more closely.
    \+ l_int(holds(P, Now), _),
    state(P).

query(happens(P, X, Y)) :-
    happens(P, X, Y).

/*
query(happens(P, Prev, Now)) :-
    current_time(Now), % Needs looking at more closely.
    succ_t(Prev, Now),
    happens(P, Prev, Now).
*/

query(holds(not(P), Now)) :-
%    current_time(Now), % Needs looking at more closely.
    l_int(holds(P, Now), B),
    \+ holds_all(B).
query(holds(P, Now)) :-
 %   current_time(Now), % Needs looking at more closely.
    l_int(holds(P, Now), B),
    holds_all(B).

query(P) :-  
	P \= holds(_, _), P \= happens(_,_, _),
	% (l_timeless(P, B)-> evaluate(B); call(P)).
    	(\+ l_timeless(P, _B) -> callprolog(P) ; l_timeless(P, B), evaluate(B)).

evaluate([]).
evaluate([P|Rest]) :-query(P), evaluate(Rest).


% fluent_pred(+Fl)
%   True if Fl is a fluent predicate symbol.
%
fluent_pred(Fl) :-
    % Extensional predicates, represent facts in the state S_i.
    fluent_(Fl).
fluent_pred(not(Fl)) :-
    fluent_(Fl).
fluent_pred(Fl) :-
    % Intensional predicates, defined in L_int.
    functor(Fl,F,N), functor(Fll,F,N),
    l_int(holds(Fll, _), _).
fluent_pred(not(Fl)) :-
    l_int(holds(Fl, _), _).


% event_pred(+Ev)
%   True if Ev is an event predicate symbol.
%
event_pred(Ev) :-
    % Simple event predicates, internally generated actions.
    action_(Ev) ; event_(Ev).
event_pred(Ev) :-
    % Composite event predicates, defined in L_events.
    macroaction(Ev).

% temp_constraint(+Term)
%   True if Term is an atomic temporal constraint formula.
%
temp_constraint(<(_,_)).
temp_constraint(=<(_,_)).

% reactive_conjunct(+Conj)
%   True if Conj is a valid conjunct in the antecedent or consequent of a
%   reactive rule.
%
reactive_conjunct(true) :- !.
reactive_conjunct(holds(P, _)) :- !,
    functor(P,F,N), functor(PP,F,N),
    fluent_pred(PP).
reactive_conjunct(happens(E, _, _)) :- !,
    event_pred(E).
reactive_conjunct(X) :-
    l_timeless(X, _), !.
reactive_conjunct(tc(T)) :- !, % TODO: relax or revise
    temp_constraint(T).
reactive_conjunct(X) :- u_user_predicate(X).


% l_int_body(+P)
%
l_int_body(holds(P, _)) :- !,
    functor(P,F,N), functor(PP,F,N),
    fluent_pred(PP).
l_int_body(P) :-
    functor(P,F,N), functor(PP,F,N),
    l_timeless(PP, _), !.
l_int_body(P) :- u_user_predicate(P).

% l_events_body(+P)
%
l_events_body(holds(P, _)) :- !,
    functor(P,F,N), functor(PP,F,N),
    fluent_pred(PP).
l_events_body(happens(P, _, _)) :- !,
    functor(P,F,N), functor(PP,F,N),
    event_pred(PP).
l_events_body(tc(P)) :-
    temp_constraint(P).
l_events_body(P) :-
    functor(P,F,N), functor(PP,F,N),
    l_timeless(PP, _), !.
l_events_body(P) :- u_user_predicate(P).

% d_head(+H)
%
d_head(H) :-
    fluent_(H).

% d_event(+H)
%
d_event(H) :- action_(H).
d_event(H) :- event_(H).

% d_body(+B)
%
d_body(happens(B, _, _)) :- !,
    d_event(B).
d_body(holds(not(B), _)) :- !,
    fluent_(B).
d_body(holds(B, _)) :- !,
    fluent_(B).
d_body(B) :-
    functor(B,F,N), functor(BB,F,N),
    l_timeless(BB, _), !.
d_body(B) :- u_user_predicate(B).

% Although this predicate is "generic", it works with SWI-only predicates, see resolveUntilAction etc. above
% dc_process(RulesToProcess, RulesProcessed, FinalRules, GoalsSoFar, FinalGoals) 
%  called as dc_process(Ri, [], NRi, [], NewGi)
% alternative implementation of process/5 using delimited continuations (http://www.swi-prolog.org/pldoc/man?section=delcont)
% Goals are represented as goal(G)
dc_process([], Rs, Rs, NG, NG) :- !.

% Antecedent is []. Add Consequent as new goal/tree.
dc_process([reactive_rule([], C) | Rs], AccRi, NRi, AccG, NGi):- !, 
	dc_process(Rs, AccRi, NRi, [goal(non_discardable,C) | AccG], NGi ).

% Too late to solve, no longer relevant.
dc_process([reactive_rule([L |_],_) | Rs], AccRi, NRi, AccG, NGi):-
	current_time(Now), Next is Now+1,
	(
		L = holds(_, T), nonvar(T), T<Now
		; 
		L = happens(_,T1, T2), (nonvar(T1),T1<Now-1;nonvar(T2),T2<Next-1)
	),
	!,
	dc_process(Rs, AccRi, NRi, AccG, NGi).

% negation case, not covered by the findall below
dc_process([reactive_rule([L |Ls],C) | Rs], AccRi, NRi, AccG, NGi):-
	(L = not(holds(_,_)); L = (holds(not(_),_))),
	!,
	( \+ \+ query(L) -> 
		dc_process([reactive_rule(Ls,C) | Rs], AccRi, NRi, AccG, NGi)
		; dc_process(Rs, AccRi, NRi, AccG, NGi) 
	).

dc_process([reactive_rule([E | Ls], C) | Rs], AccRi, NRi, AccG, NGi):- 
	( mustBeProcessedNow(E) -> ItMust=true; ItMust=false),
	findall( reactive_rule(Antecedent,C), 
		( lpsClause(E,Body), append(Body,Ls,Antecedent ) ),
		NewRules),
	(NewRules==[] -> % rule antecedent fails, discard it or postpone it:
		( ItMust==true -> dc_process(Rs,AccRi, NRi, AccG, NGi) ; dc_process(Rs,[reactive_rule([E | Ls], C)|AccRi], NRi, AccG, NGi))
		; % else, consider all new rules instead of the given one:
		%( ItMust==true -> append(NewRules,Rs,RulesToProcess), AlreadyProcessed=AccRi ; RulesToProcess=Rs, append(NewRules,AccRi,AlreadyProcessed)),
		append(NewRules,Rs,RulesToProcess), 
		% dc_process(RulesToProcess,[reactive_rule([E | Ls], C)|AccRi], NRi, AccG, NGi)		
		(ItMust==true  -> dc_process(RulesToProcess,AccRi, NRi, AccG, NGi) ; dc_process(RulesToProcess,[reactive_rule([E | Ls], C)|AccRi], NRi, AccG, NGi)	)
	).
%dc_process([R|Rs],AccRi,NRi,AccG, NGi) :- dc_process(Rs,[R|AccRi],NRi,AccG, NGi).

% Slightly different verion of query for 'dc' option, separated to make sure it doesn't break the other variant of the interpreter
dc_query(not(holds(P, Now))) :- !, \+ dc_query(holds(P,Now)).
dc_query(holds(not(P), Now)) :- !, \+ dc_query(holds(P,Now)).
dc_query(holds(P, T)) :- 
	current_time(Now),
	( lps_updating_current_state -> RealNow is Now-1 ; RealNow=Now),
	% ( nonvar(T), T\== RealNow, throw(bad_dc_query(holds(P, T),Now,RealNow)) ; true),
	( nonvar(T), T<RealNow, !, fail ; true),
	T=RealNow, state(P).
dc_query(holds(P, Now)) :- !, l_int(holds(P, Now), B), holds_all(B).
dc_query(happens(P, X, Y)) :- !, happens(P, X, Y).
dc_query(P) :-
    	(\+ l_timeless(P, _B) -> callprolog(P) ; l_timeless(P, B), evaluate(B)).




