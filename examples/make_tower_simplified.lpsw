% blocks world simplified.

maxTime(5).

initial_state([
	location(b, a), location(c,b),
	location(a, table)]
).

/* teleo-reactive version. To be done.

reactive_rule(
	[holds(not(tower([a, b,c,table])), T2)],
	[happens(make_tower([a, b,c,table]), T2, T3)]  ).

*/

% This version doesn't work for making tower [a,b,c].
reactive_rule(
	[true],
	[happens(make_tower([a, b,c,table]), T2, T3)]  ).


l_int(
	holds(clear(Block), T),
	[holds(not(location(_,Block)),T)]
).

l_int(
	holds(clear(table), T),
	[]
).

l_events(
	happens(make_tower([Block, Place | Places]), T1, T3),
	[happens(make_tower([Place | Places]), T1, T2), happens(make_on(Block, Place), T2, T3)]
).

l_events(
	happens(make_tower([Block, table]), T1, T2),
	[happens(make_on(Block, table), T1, T2)]
).

% make-on and make_clear seem to work also if the order of the two clauses is
% reversed.

l_events(
	happens(make_on(Block, Place), T1, T4),
	[holds(not(location(Block, Place)), T1), happens(make_clear(Place), T1, T2), happens(make_clear(Block), T2, T3),
	happens(move(Block, Place), T3, T4)]
).

l_events(
	happens(make_on(Block,Place), T, T),
	[holds(location(Block, Place), T)]
).

l_events(
	happens(make_clear(Place), T, T),
	[holds(clear(Place), T)]
	).

l_events(
	happens(make_clear(Block), T1, T2),
	[holds(location(Block1, Block), T1), happens(make_on(Block1, table), T1, T2)]
).


initiated( happens(move(Block, Place), _T1, _T2), location(Block, Place), []).
terminated( happens(move(Block, _), T1, _T2), location(Block, Place), [holds(location(Block, Place), T1)]).



fluent(location(_, _)).
action(move(_,_)).

/* Observations no longer needed.
observe([start], 1).
observe([], 2).
observe([], 3).
observe([], 4).
observe([], 5).
*/

/* event declarations no longer needed.
event(start).
intensional(clear(_)).
macroaction(make_clear(_)).
macroaction(make_on(_,_)).
macroaction(make_tower(_)).
*/
